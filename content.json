{"meta":{"title":"Technical blog","subtitle":"IT小白的成长之旅","description":"请乐观，请珍惜","author":"Li Yudong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"archives","date":"2020-08-16T14:58:35.000Z","updated":"2020-08-16T14:58:35.251Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-16T14:49:27.000Z","updated":"2020-08-16T14:52:47.789Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-16T14:45:00.000Z","updated":"2020-08-16T14:48:55.034Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"广告位招租","date":"2020-08-16T15:01:00.000Z","updated":"2020-08-16T15:02:08.971Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"首屏优化实践","slug":"前端/首屏优化实践","date":"2021-03-12T12:02:33.000Z","updated":"2021-03-12T14:51:23.641Z","comments":true,"path":"2021/03/12/前端/首屏优化实践/","link":"","permalink":"http://yoursite.com/2021/03/12/%E5%89%8D%E7%AB%AF/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"前言之前的项目在部署之后首屏加载过慢了，因此最近有想进行简单的优化一下，顺便就想以一个初学者的角度将项目优化的思路有条理的梳理一下，因为水平原因，很多方法可能只能写下思路，没办法应用在自己的项目上，而且可能很多的优化方案已经略有过时。主要还是想做一下有关优化知识的梳理吧，毕竟优化是一个永恒不变的话题。项目是基于vue框架开发的，但优化方法的思路是不拘泥于框架的。 代码层面优化代码层面的优化这一部分其实比较杂乱，浅显的意思是要怎么去编写高性能点的代码？emm主要还是讲一下从一个新手的角度，避免出现一些影响性能的操作吧。 路由、模块懒加载很常用的懒加载代码， 不用一次加载所有的路由或者模块，到需要引用时再进行加载，用函数来代替对象进行引入模块与路由，属于用vue框架时的基本操作吧。 12345678910111213141516171819202122//路由懒加载export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;HelloWorld&#x27;, // 方法一：vue异步组件实现 // component: resolve =&gt; (require([&#x27;@/components/HelloWorld&#x27;], resolve)) // 方法二：import方法(常用) component: () =&gt; import(&#x27;@/components/HelloWorld&#x27;) &#125; ]&#125;)//模块懒加载export default &#123; components: &#123; // 方法一 &#x27;HelloWorld&#x27;: () =&gt; import(&#x27;./HelloWorld&#x27;), // 方法二 // HelloWorld&#x27;: resolve =&gt; ([&#x27;./HelloWorld&#x27;], resolve) &#125;&#125; 图片懒加载图片懒加载其实通常更多地应用于图片较多的网站，我自己的项目上由于图片比较少，就没有用到复杂的长屏懒加载。只是在图片或模块的ajax请求没有返回时，使用一个loading的特效来代替图片、组件进行填充，简单地实现了基础的懒加载？思路很简单：大概就是预设一个div的z-index，让其覆盖图片、组件的上面，默认为show。同时在ajax请求的异步回调上修改其CSS，变为hidden。elementUI等开源组件库上应该有类似的loading组件。 对于含有多图片的长页面，在你没有滚动到图片所在位置的页面中时，是用空的div来填充代替图片位置的。一旦我们通过滚动使得这个 div 出现在了可见范围内，那么 div 元素的内容就会发生变化，呈现其中的内容，这就是图片的懒加载。 下面我们简单实现下懒加载：其实该功能的关键在于获取两个值：1、当前可视区域的高度，通常用window.innerHeight 属性获取。 2、元素距离可视区域顶部的高度，我们这里选用 getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。该方法的返回值是一个DOMRect。DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。其中top 属性代表了元素距离可视区域顶部的高度，正好用来实现功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Lazy-Load&lt;/title&gt; &lt;style&gt; .img &#123; width: 200px; height:200px; background-color: gray; &#125; .pic &#123; // 必要的img样式 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;img&quot;&gt; // 注意我们并没有为它引入真实的src &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/1.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/2.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/3.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/4.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/5.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/6.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/7.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/8.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/9.png&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img&quot;&gt; &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/10.png&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 获取所有的图片标签 const imgs = document.getElementsByTagName(&#x27;img&#x27;) // 获取可视区域的高度 const viewHeight = window.innerHeight || document.documentElement.clientHeight // num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出 let num = 0 function lazyload()&#123; for(let i=num; i&lt;imgs.length; i++) &#123; // 用可视区域高度减去元素顶部距离可视区域顶部的高度 let distance = viewHeight - imgs[i].getBoundingClientRect().top // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出 if(distance &gt;= 0 )&#123; // 给元素写入真实的src，展示图片 imgs[i].src = imgs[i].getAttribute(&#x27;data-src&#x27;) // 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出 num = i + 1 &#125; &#125; &#125; // 监听Scroll事件 window.addEventListener(&#x27;scroll&#x27;, lazyload, false);&lt;/script&gt; ajax请求现在项目中通常都不会去手写原生的ajax，毕竟因为异步的回调地狱嘛。我自己的项目用的是axios，定义如下：axios 是一个轻量的 HTTP客户端，它基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端。但往往我们需要封装一下axios，毕竟如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作都重写一遍就太麻烦了。这里贴一下我自己很简单的axios封装。 1234567891011121314151617181920212223242526import Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;var service = axios.create(&#123; baseURL: &#x27;&#x27;, // http://qinghai.free.idcfengye.com/ timeout:400000,&#125;);// 添加请求拦截器service.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;);// 添加响应拦截器service.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response;&#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error);&#125;);Vue.prototype.$http = service;//挂载在vue的原型上，这样你后续在vue文件中使用this.$http便可以获取到service。 当然，这里ajax的优化其实并不是指简单的axios封装，毕竟这个属于常用操作。这个优化问题也是出自项目的主页，由于某些问题，主页中同一时间进行地ajax请求过多，一次跑过多的异步任务会导致页面的卡顿。开始时，我用的便是上述封装后的axios请求，为解决卡顿问题，开始时我希望能够使用fetch()来代替ajax请求，希望能达到目的；fetch()定义如下： Fetch API是新的ajax解决方案 Fetch会返回Promise, fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。fetch(url, options).then()。 其实我感觉优点就三个：1、使用promise，这样也支持了async，编写异步时更加方便；2、可自定义是否携带cookie；3、fetch在ServiceWorker中使用。但实际项目中，ajax往往都被封装好了，例如上面的axios，这样前两项其实并没有所谓。但关键就在于第三项了。service work是基于web worker而来。 众所周知，javaScript 是单线程的，随着web业务的复杂化，开发者逐渐在js中做了许多耗费资源的运算过程，这使得单线程的弊端更加凹显。web worker正是基于此被创造出来，它是脱离在主线程之外的，我们可以将复杂耗费时间的事情交给web worker来做。但是web worker作为一个独立的线程，他的功能应当不仅于此。service work便是在web worker的基础上增加了离线缓存的能力。 特点：1、必须是https环境，本地调试localhost或者127.0.0.1环境也是可以的，2、依赖于cache api进行实现的3、依赖于h5的fetch Api；4、依赖于promise进行实现。但这里我自己并没有用这么复杂的优化方案，就不赘述了。 我自己运用基本的处理有：1、使用了axios对多并发请求的处理方案，当页面某个数据来源于多个互不关联的请求时，需要统一处理然后呈现。即使用axios.all(iterable)，参数：请求数组；axios.spread(callback)，参数： 对应请求返回值。API的应用实例如下： 1234567891011121314151617181920212223methods: &#123; getAllTask() &#123; return axios.get(&#x27;/data.json&#x27;, &#123; params: &#123; id: 10 &#125; &#125;) &#125;, getAllCity() &#123; return axios.get(&#x27;/city.json&#x27;, &#123; params: &#123; id: 11 &#125; &#125;) &#125;&#125;,mounted() &#123; axios.all([this.getAllTask(), this.getAllCity()]) .then(axios.spread(function(allTask, allCity) &#123; console.log(&#x27;请求1结果&#x27;, allTask) console.log(&#x27;请求2结果&#x27;, allCity) &#125;))&#125;, 2、尽量复用ajax请求，当不同模块间可以公用同一接口的同一信息时，不要在两个模块中分别请求两次，而是尽量利用组件间通信来实现信息的共享； 2、设置HTTP缓存。HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为强缓存和协商缓存。 强缓存优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。expires写的是一个绝对的时间戳，例如：xxx年x月x日。而在 Cache-Control 中，我们通过 max-age字段 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。max-age 是一个相对时间，这就意味着它有能力规避掉 expires 可能会带来的时差问题。同样，因此cache-control的优先级比expires更高。Cache-Control 中还有更高优先级的s-maxage：用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。（public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。） 协商缓存协商缓存依赖于服务端与浏览器之间的通信。在协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。在该服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304）。 实现：Last-Modified 到 Etag。Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回。随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值。服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。 但是可能会有一个bug：我们编辑文件，但没有修改，服务器可能会以为我们修改了；修改文件的时间过快，服务器可能会感知不到。即：服务器并没有正确感知文件的变化。这样就引出了Etag，Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。同样，优先级方面，Etag高于Last-Modefied。 HTTP缓存决策流程：当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。 组件库按需引入这一点其实好理解，例如当你使用elementUI或者echarts这些组件库时，通常并没有用到其提供的全部组件，因此在import的时候，不需要全部引入整体，只需要引入你所用到的部分即可。 适用于V8引擎的JS代码毫无疑问，就又是一个大坑了，关于对这个的理解我也是由他人的博客所看来的，不保证结论的正确性，只是记录下自己的了解。首先我们需要了解以下V8引擎底层的两个特征。 隐藏类在V8引擎中采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。每当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。乍一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息时，隐藏类可以被重用。即下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。 这样的话，相当于一个构造函数中的所有属性都由一个隐藏类的链将他串联在了一起，由该构造函数新建的对象就可以直接共享该隐藏类链。主要的优点有：1、属性访问时不再需要从动态字典中进行查找了；2、为V8使用经典的基于类的优化和内联缓存技术提供了条件。 内联缓存技术：在第一次执行到访问某个对象的属性的代码时，V8会找出该对象的隐藏类；同时，V8会假设在相同的代码片段中其他所有的对象的属性访问都通过这一隐藏类来实现。只有在预测失败时，V8才会修改内联代码并移除刚才加入的内联优化。当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，即：你基于一个构造函数，构建多个实例时，用隐藏类的方法可以加快属性访问速度。 由隐藏得来的V8代码编写教训：1、在构造函数里初始化所有对象的成员(所以这些实例之后不会改变其隐藏类)；2、总是以相同的次序初始化对象成员；//可以更好利用隐藏类 3、永远不要delete对象的某个属性；4、方法：重复执行相同方法的代码将比仅执行一次的多个不同方法（由于内联缓存）的代码运行得更快。5、数组：避免稀疏数组 两次编译V8有两个不同的运行时编译器：1、“完全”编译器（unoptimized）。一开始，所有的V8代码都运行在unoptimized状态。它的好处是编译速度非常快，它使代码初次执行速度非常快。2、“优化”编译器（optimized）。当V8发现某段代码执行非常热时，它会根据通常的执行路径进行代码优化，生成optimized代码。优化代码的执行速度非常快。 编译器有可能从“优化”状态退回到“完全”状态， 这就是deoptimized。这是很不幸的过程，优化后的代码没法正确执行，不得不退回到unoptimized版本。当然最不幸的是代码不停地被optimized，然后又被deoptimized， 这会带来很大的性能损耗，例如：for…in遍历对象的属性和try…catch中的代码会让编译器无法到达optimized状态。 使用教训：1、把for…in 内部的代码单独提出来作为函数，这样V8引擎就能对其进行优化；2、谨慎使用try..catch 闭包闭包会使程序逻辑变复杂，有时会看不清楚是否对象内存被释放，因此要注意释放闭包中的大对象， 否则会引起内存泄露。谨慎使用闭包，有时候不当的闭包使用会造成大量的内存占用。 存储层面的优化其实关于缓存方面上面的ajax请求里已经写了好多了，嗯，感觉布局有点问题，不过并不打算改了。这里就主要说说webpack打包方面的修改吧，毕竟算存储内容的优化？不过我是用vuecli构建的项目，其实该有的优化都已经默认配好了？就像tree-shaking？ 在你使用vue-cli构建项目时，webpack的配置会被隐藏在vuecli的框架下面，不过想要自己进行特别的webpack配置也比较容易，根据vuecli官方网站的说明：调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象：该对象将会被 webpack-merge 合并入最终的 webpack 配置。如果你需要基于环境有条件地配置行为，或者想要直接修改配置，那就换成一个函数 (该函数会在环境变量被设置之后懒执行)。该方法的第一个参数会收到已经解析好的配置。在函数内，你可以直接修改配置，或者返回一个将会被合并的对象。具体的配置方案因为我自己也不太懂，就不赘述了。 webpack-bundle-analyzer如果你是使用vue-cli3构建的项目，则直接vue-cli-service build –report就会生成一个report.html，打开这个html就能看到webpack打包之后的模块与依赖的加载状态。如果不是由vuecli构建的项目，也很简单，直接npm install 安装webpack-bundle-analyzer模块，版本号过高的话可能有意外的错误，推荐安装5.0.0。之后在vue配置中引入该包，并自定义运行命令即可，具体的可参照官网。之后你就可以看到自己项目的打包分析了，针对那些用的比较少的模块，把全局引入修改成针对性引入、使用更轻量级的组件库。总之根据该打包分析图，尽量减少项目的体积即可。 gzip压缩gzip压缩可以说是为了优化首屏加载速度最常用的方法之一了。Gzip 压缩背后的原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大。反之亦然。主要的实现方法有两个： 1、项目正常打包部署，直接在服务端对nginx配置进行修改。这样设置时，当你请求时,服务端就会先将对应的文件压缩成.gz格式再发送给你，客户端接收到了.gz文件的格式之后再解压并执行后续操作。相当于用压缩的时间，换取了文件传输的时间，通常都会是正优化，除非项目体积过小。 123456789101112131415161718192021222324252627282930313233343536373839http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; # 开启gzip gzip on; # 设置缓冲区大小 gzip_buffers 4 16k; #压缩级别官网建议是6 gzip_comp_level 6; #压缩的类型 gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php; server &#123; listen 8462; server_name localhost; location / &#123; root dist; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 2、项目打包时对webpack进行特殊设置，安装插件（compression-webpack-plugin）；打包同时生成成两份文件，第一份为正常的文件，另一个为gz压缩后的文件，部署时将其全部部署至服务端。下面是vuecli构建项目的webpack配置参考，不用vuecli构建的，直接修改webpack配置即可。 123456789101112131415const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;);module.exports= &#123; configureWebpack: &#123; plugins: [ new CompressionPlugin(&#123; algorithm: &#x27;gzip&#x27;, // 使用gzip压缩 test: /\\.js$|\\.html$|\\.css$/, // 匹配文件名 filename: &#x27;[path].gz[query]&#x27;, // 压缩后的文件名(保持原文件名，后缀加.gz) minRatio: 1, // 压缩率小于1才会压缩 threshold: 10240, // 对超过10k的数据压缩 deleteOriginalAssets: false, // 是否删除未压缩的源文件，谨慎设置，如果希望提供非gzip的资源，可不设置或者设置为false（比如删除打包后的gz后还可以加载到原始资源文件） &#125;) ], &#125;,&#125; 之后在nginx配置中使用：gzip_static on，该属性能够静态加载本地的gz文件，这样就完成了gzip。向较于上一种方案，这种方法虽然上传项目文件体积更大，但免去了服务端实时的压缩过程，速度会更快。 CDN缓存优化定义：CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。相较于其他的缓存是为了优化网页流畅程度，CDN缓存更多的是为了优化首屏加载速度。 CDN 的核心点有两个，一个是缓存，一个是回源。这两个概念都非常好理解。“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。 CDN 往往被用来存放静态资源。上文中我们举例所提到的“根服务器”本质上是业务服务器，它的核心任务在于生成动态页面或返回非纯静态页面，这两种过程都是需要计算的。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。 所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。什么是“非纯静态资源”呢？它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。 所以简单总结一下：静态资源走CDN便可以实现对静态资源加载的优化。同时静态资源往往并不需要 Cookie 携带什么认证信息，因此把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现。 理论的介绍大概就这么多了，在我自己的项目实践中，其实并没有把静态资源均部署在CDN上，毕竟技术力有限。只是将一些引入的公共框架代码，利用了BootCDN提供的免费资源进行取代。以本项目为例，我将vue、vuex、axios、echarts、elementUI均修改为CDN引入。主要的好处有两个：1、分离了公共库后，项目打包体积小了，打包速度提升了；2、使用CDN加载更加快速，且减轻了服务器压力。 具体实施步骤如下：1、在index.html中，添加CDN代码 12345678910111213...&lt;link href=&quot;https://cdn.bootcss.com/element-ui/2.7.2/theme-chalk/index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.cjs.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vuex/4.0.0-rc.1/vuex.cjs.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.4.8/vue-router.common.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue-echarts/5.0.0-beta.0/vue-echarts.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.在vue.config.js中加入webpack配置代码，关于webpack配置中的externals，请参考地址 渲染层面的优化服务端渲染技术提到渲染层面的优化就不得不说现在特别火的SSR技术了，其实它是一个相对的概念，其对立面是客户端渲染。客户端渲染就是常用的正常情况，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁。页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。 服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。关于服务端渲染的实践方式，已经有nust.js这样的框架可以使用了，不过由于我自己的技术原因，并没有去实践一下这个新潮的技术。这里我就只说一下SSR的优缺点了，很多地方也都会提到这个。 优点：1、主要是出于效益的原因，因为SSR之后，搜索引擎以及各种爬虫才能够爬取网站的内容，这样才便于网站的推广。 2、服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了。 缺点：服务端渲染本质上是本该浏览器做的事情，分担给服务器去做。这样当资源抵达浏览器时，它呈现的速度就快了。乍一看好像很合理，但其实这样会成倍地增加服务端的压力，造成大量的成本，很有可能得不偿失。 CSS选择器优化CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配，与我们正常人的书写习惯刚好相反，因此在使用选择器时如果没有意识到这一点，就写出一些高性能消耗的选择器。例如: #mylist li {}。如果像这样写的话，浏览器必须遍历页面上每个 li 元素，并且每次都要去确认这个 li 元素的父元素 id 是不是 myList，这样会消耗大量性能。可以修改为：.myList_li {}同样，CSS中的通配符#会匹配所有元素，这样你使用时会让浏览器去遍历每一个元素。 以下为CSS书写时的性能提升方案：1、避免使用通配符，只对需要使用到的元素进行选择；2、关注可以通过继承实现的属性，避免重复匹配、重复定义；3、少使用标签选择器，尽量多使用类选择器。4、不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。5、减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。 DOM优化减少回流与重绘重绘不一定导致回流，回流一定会导致重绘。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。定义如下： 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。 1、尽量多使用变量来进行缓存跟DOM相关的数据，避免引起DOM变化； 2、避免逐条改变样式，使用类名去合并样式； 3、将 DOM “离线”：当我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。拿掉一个元素，再将他放回去，虽然会触发一次回流，但在这期间对其做的任何操作，都不会太大影响性能。 减少获取DOM次数在你需要多次操作并修改某个DOM时，只执行一次获取DOM的操作并将其存在变量中，这样就能节省获取DOM的性能消耗。 减少修改DOM的次数对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程。由于JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。这其实就是DOM Fragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment) 的思路。 DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。 123456789101112let container = document.getElementById(&#x27;container&#x27;)// 创建一个DOM Fragment对象作为容器let content = document.createDocumentFragment()for(let count=0;count&lt;10000;count++)&#123; // span此时可以通过DOM API去创建 let oSpan = document.createElement(&quot;span&quot;) oSpan.innerHTML = &#x27;我是一个小测试&#x27; // 像操作真实DOM一样操作DOM Fragment对象 content.appendChild(oSpan)&#125;// 内容处理好了,最后再触发真实DOM的更改container.appendChild(content) DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后全身而退，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。使用微任务队列，实现异步更新来避免过度渲染，就是用JS给DOM分压。","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"屏幕适配解决方案","slug":"前端/屏幕适配解决方案","date":"2021-03-06T13:28:16.000Z","updated":"2021-03-12T14:51:11.981Z","comments":true,"path":"2021/03/06/前端/屏幕适配解决方案/","link":"","permalink":"http://yoursite.com/2021/03/06/%E5%89%8D%E7%AB%AF/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言项目是基于vue框架构建的，使用了elementUI组件库和echarts插件。开发过程中需要实现的一个需求是希望能够让首页实现大屏幕的适配效果。大概的完成思路借鉴了手机淘宝之前的flexible.js，就是获取不同屏幕的宽度，然后修改html根元素的字体大小；这样跟根元素字体大小绑定的rem就能够实时地监听屏幕的变化，实现不同屏幕的适配。 其实移动端的适配也是同理，不过好像有很多的坑，但本项目没有移动端适配的需求，因此就暂且采用了简单的rem适配的方法。由于首页中有echarts表单，需要也能够监听屏幕的变化，因此除了flexible.js以外，我们还需要自定义一个resize.js混入在首页的每个echarts上，让其也会实时跟踪监听屏幕变化，这样才能够实现首页所有元素的屏幕适配。 解决方案基础定义最简单最直接的方式就是直接用百分端来设置元素的尺寸；可以实现元素大小的自适应，但无法实现字体大小的自适应，而且尺寸转为百分比计算十分麻烦。其实我们需要的是一个和屏幕宽度正相关的单位，而且这个单位要和px很容易互相转化。这样我们就可以使用这种单位进行元素尺寸和字体大小的设置。 em单位为相对长度单位，是根据当前元素的父元素的字体大小来计算的；但父级元素改变时，则em会经常改变，因此后面推出了rem来代替em单位的功能。 rem单位也是一个相对长度单位，1rem等于html元素上字体设置的大小；我们只要设置html上font-size的大小就可以改变rem所代表的大小。 vw、vh都是viewport视窗的相对长度单位，100vw代表着viewport视窗的宽度，100vh代表着viewport视窗的高度。 设备像素比device pixel ratio简称dpr，即物理像素和设备独立像素的比值，设备像素比越大意味着你的手机屏幕越高清。 例如：电脑的dpr都为1，而iphone7的dpr为2，因此设计稿上的1px，要想让iphone7实现适配，CSS应该为0.5px。而有的浏览器在解析0.5px 的时候会把他解析成1px,所以呈现出来会变成2px。这就是经典的1px问题。 1px问题解决方案：既然1个css像素代表两个物理像素，设备又不认0.5px的写法，那就画1px，然后再想尽各种办法将线宽减少一半。 1、图片大法及背景渐变。这两种方案原理一样,都是设置元素一半有颜色,一半透明,比如做一个2px高度的图片,其中1px是我们想要的颜色,1px设置为透明。 2、缩放大法。这也是flexible.js的解决方案，根据对应的dpr调整对应的缩放比例,从而达到适配的目的,直接缩放页面。 3、使用伪元素缩放。transform: scale(1, 0.5);实现缩放的功能。 flex弹性盒子布局当我们采用flex布局时，flex会自己根据屏幕的宽度进行适配。关于flex适配的方案比较容易，通常跟rem一起来实现屏幕宽度不同时的界面适配。这里就只介绍一下flex的基础概念，具体的布局在理解定义后较为简单，就不列举实例了。 简要介绍下flex常用的属性：父容器：display:flex; flex-direction用于确定flex主轴布局的方向；接下来的 justify-content, align-items, align-content 用于确定 flex 项对于 flex 容器空间的空白如何处理。 flex容器中的子元素会成为flex项。flex属性是flex-grow, flex-shrink, flex-basis 三个属性的简写属性。grow、shrink分别代表着增长和收缩因子；basis代表着初始基准大小。默认值为：flex: 0 1 auto。flex-basis 指定固定的长度值时，其优先级高于width；flex-basis 指定百分比值时，其参考对象是 main size.所以其计算值 flex-basis: percent * mainSize px。 rem适配原理其实前面已经讲过了，就是识别不同的屏幕长宽来设置不同的html根元素的字体大小，从而用动态的rem来实现界面的配置。关键在于如何识别不同的屏幕宽度。 1、利用媒体查询：@media screen and (min-width:XXX)来判断设备的尺寸，进而设置html的fontSize，比较麻烦且需要考虑较多。 2、利用js获取并设置fontSize，简单实例如下。以下代码是以iphone6为设计稿，结果是1rem=100px的实际像素，因为iphone6的设备像素比是2所以1rem在浏览器的预览中是50px，也就是实现了1rem和设备宽度成7.5倍的关系，设备宽度改变1rem的实际大小也会改变， 但我自己则是用了手机淘宝开源的flexible.js，稍微修改后便实现了需求，代码比这个实例复杂许多，具体代码会贴在文章的最后。 12345function setRem () &#123; let htmlRem = document.documentElement.clientWidth document.documentElement.style.fontSize = htmlRem/7.5 + &#x27;px&#x27; &#125;setRem() 3、使用vm、vh：vw、vh是新的一种相对单位是把可视区域分的宽高为100份类似于百分比布局，这种方案它不用去写js，不过兼容性有点差。 123html&#123; font-size: 10vw&#125; px适配根据不同的屏幕宽度，计算处不同的px值,所以当我们改变苹果的大小时,网站就会刷新动态计算出对应的px值,从而达到适配的目的。具体的实施代码没有找到，但其实原理逻辑相差不大。 项目实践项目的适配大概有2部分吧：1、使用flexible.js来实现不同屏幕的适配；在基于vue框架的项目中，这里的flexible.js直接import进main.js即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector(&#x27;meta[name=&quot;viewport&quot;]&#x27;); var flexibleEl = doc.querySelector(&#x27;meta[name=&quot;flexible&quot;]&#x27;); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); /* 获取dom树：win.document.documentElement，后续向HTML插入dpr、font-size； 分别取meta标签中元素，判断用户是否曾经设置过；viewport的meta标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大 设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系 = 物理像素 / 设备独立像素 */ if (metaEl) &#123; console.warn(&quot;将根据已有的meta标签来设置缩放比例&quot;); var match = metaEl .getAttribute(&quot;content&quot;) // eslint-disable-next-line no-useless-escape .match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute(&quot;content&quot;); if (content) &#123; // eslint-disable-next-line no-useless-escape var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); // eslint-disable-next-line no-useless-escape var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; /* 这段代码是判断你的meta标签里面是不是设置了name=viewport属性，如果你设置了viewport 并且设置了initial-scale（初始屏幕的大小）我们将取到这个值作为dp */ if (!dpr &amp;&amp; !scale) &#123; // eslint-disable-next-line no-unused-vars var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute(&quot;data-dpr&quot;, dpr); /* 之后如果我们动态设置了scale或者设置了meta标签里面的name＝flexible的inital-scale， 那么我们就根据自己设置的dpr在判断iphone手机的retina屏幕的dpr比值判断不同型号的倍数，最后我们在html上设置了data-dpr自定义属性。 */ if (!metaEl) &#123; metaEl = doc.createElement(&quot;meta&quot;); metaEl.setAttribute(&quot;name&quot;, &quot;viewport&quot;); metaEl.setAttribute( &quot;content&quot;, &quot;initial-scale=&quot; + scale + &quot;, maximum-scale=&quot; + scale + &quot;, minimum-scale=&quot; + scale + &quot;, user-scalable=no&quot; ); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement(&quot;div&quot;); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; /* 之后当我们之前没有设置metaEl标签的话，那么需要我们手动的去创建meta标签，实现移动端的适配 */ function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; // 最小1366px，最大适配2560px if (width / dpr &lt; 1366) &#123; width = 1366 * dpr; &#125; else if (width / dpr &gt; 2560) &#123; width = 2560 * dpr; &#125; // 设置成24等份，设计稿时1920px的，这样1rem就是80px var rem = width / 24; docEl.style.fontSize = rem + &quot;px&quot;; flexible.rem = win.rem = rem; &#125; win.addEventListener( &quot;resize&quot;, function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false ); win.addEventListener( &quot;pageshow&quot;, function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false ); /* 这段代码的目的就是监听window里面的resize和pageshow方法来实现css样式的重绘。 函数里面就是实现取到当前设备的width之后根据width计算出rem的具体值，rem代表html的font-size， 这里的rem代表的是一个自定义的rem，而不是rem属性！ */ if (doc.readyState === &quot;complete&quot;) &#123; doc.body.style.fontSize = 12 * dpr + &quot;px&quot;; &#125; else &#123; doc.addEventListener( &quot;DOMContentLoaded&quot;, // eslint-disable-next-line no-unused-vars function(e) &#123; doc.body.style.fontSize = 12 * dpr + &quot;px&quot;; &#125;, false ); &#125; /* 之后我们判断document对象是否处于complete状态， 如果完成状态我们给body一个font-size＝12*dpr的值，否则我们判断dom加载方法来实现body中的font-size的设置。 这个设置是为了页面中字体的大小，而html中的font-size是为了设置页面的height，width等属性。 */ refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === &quot;string&quot; &amp;&amp; d.match(/rem$/)) &#123; val += &quot;px&quot;; &#125; return val; &#125;; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === &quot;string&quot; &amp;&amp; d.match(/px$/)) &#123; val += &quot;rem&quot;; &#125; return val; &#125;;&#125;)(window, window[&quot;lib&quot;] || (window[&quot;lib&quot;] = &#123;&#125;)); 2、由于首页中还有echarts组件的展示，需要自定义一个函数来监听屏幕的变化，当屏幕变化时则修改echarts组件中chart的大小；这个resize的效果需要用防抖的函数来控制resize的频率。这里我把防抖写在了一个公共库里，就能方便复用，对于resize.js，直接混入在有echarts插件的vue文件中即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859export function debounce(func, wait, immediate) &#123; let timeout, args, context, timestamp, result; const later = function() &#123; // 据上一次触发时间间隔 const last = +new Date() - timestamp; // 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait if (last &lt; wait &amp;&amp; last &gt; 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用 if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function(...args) &#123; context = this; timestamp = +new Date(); const callNow = immediate &amp;&amp; !timeout; // 如果延时不存在，重新设定延时 if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125;import &#123; debounce &#125; from &#x27;@/XXX/XXXX&#x27;;const resizeChartMethod = &#x27;$__resizeChartMethod&#x27;;export default &#123; data() &#123; // 在组件内部将图表init的引用映射到chart属性上 return &#123; chart: null, &#125;; &#125;, created() &#123; window.addEventListener(&#x27;resize&#x27;, this[resizeChartMethod], false); &#125;, beforeDestroy() &#123; window.removeEventListener(&#x27;reisze&#x27;, this[resizeChartMethod]); &#125;, methods: &#123; // 通过lodash的防抖函数来控制resize的频率 [resizeChartMethod]: debounce(function() &#123; if (this.chart) &#123; this.chart.resize(); &#125; &#125;, 100), &#125;,&#125;;","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JS力扣刷题记","slug":"前端/JS力扣刷题记（一）","date":"2021-02-24T12:02:33.000Z","updated":"2021-03-12T14:51:49.040Z","comments":true,"path":"2021/02/24/前端/JS力扣刷题记（一）/","link":"","permalink":"http://yoursite.com/2021/02/24/%E5%89%8D%E7%AB%AF/JS%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"前言如题，打算使用JS从头开始刷leetcode，大致地记录并讲解一下自己的解题思路吧，由于自己的水平原因，所以思路与解法都会比较偏新手向吧，同时不会只关注这一个题的思路，会有一些整体的思路与延伸吧。做这个记录的原因主要是想以新手的角度讲下自己解题遇到的弯路，同时也给自己加深印象吧。开始时可能注释会有些啰嗦，后续会减少不必要的代码解释。打算先写完并理解前150题吧，也并不打算分类的，因为前百题的思路都是经典解题思路，都需要慢慢体会吧。 1、两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。你可以按任意顺序返回答案。转载自两数之和 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */const twoSum = (nums, target) =&gt; &#123; let res = []; let map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; map.set(nums[i], i); //很简单的题目与逻辑，用map即哈希表的方法辅助查找即可，使用map的set方法构建。 &#125; for (let i = 0; i &lt; nums.length; i++) &#123; let newTarget = target - nums[i]; if (map.has(newTarget) &amp;&amp; (map.get(newTarget) !== i)) &#123; res.push(i, map.get(newTarget)); //使用has、get方法分别判断与获取索引 //这里要注意下，不能两个相同索引相加 return res; &#125; &#125;&#125; 2、两数相加给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。转载至两数之和 例：输入：l1 = [2,4,3], l2 = [5,6,4]；输出：[7,0,8]；解释：342 + 465 = 807。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */const addTwoNumbers = function(l1, l2) &#123; let carry = 0; //定义进位， let sum = new ListNode(0); //一般链表题目的输出，需要先新建一个空的头节点，之后以该空结点作链表处理，从而能够避免因链表长度不够导致的报错,后续返回head.next let head = sum; while (l1 || l2 || carry) &#123; let value1 = ((l1 === null) ? 0 : l1.val); //其实是在往前面补0，以确保两个加数位数一致 let value2 = ((l2 === null) ? 0 : l2.val); sum.next = new ListNode((value1 + value2 + carry) % 10); carry = ((value1 + value2 + carry) &gt;= 10 ? 1 : 0); sum = sum.next; if (l1) l1 = l1.next; if (l2) l2 = l2.next; &#125; return head.next;&#125; 一般情况下，除了用链表来存储大数以外，在JS中更常用的是用字符串来保存，因此下面我们写一个字符串类型的大数相加，基本的逻辑和链表是一样的，主要是处理的方式不同，这里我就不再赘述原理了。 12345678910111213141516171819202122232425262728293031323334353637const add = function add(a, b)&#123; let m = &quot;&quot;; let n = &quot;&quot;; let res = []; let sum = 0; if (a.length &gt; b.length)&#123; a = &#x27;0&#x27; + a; for (let i = b.length; i &lt; a.length; i++)&#123; b = &#x27;0&#x27; + b; &#125; m = a.split(&#x27;&#x27;); n = b.split(&#x27;&#x27;); &#125; else &#123; b = &#x27;0&#x27; + b; for (let i = a.length; i &lt; b.length; i++)&#123; a = &#x27;0&#x27; + a; &#125; a = a.split(&#x27;&#x27;); b = b.split(&#x27;&#x27;);&#125; for (let i = a.length - 1; i &gt;= 0; i--) &#123; let k = (parseInt(a[i]) + parseInt(b[i]) + sum) % 10; res.unshift(k); if ((parseInt(a[i]) + parseInt(b[i]) + sum) &gt;= 10) &#123; if ((m === n) &amp;&amp; (i = t)) &#123; res.unshift(&quot;1&quot;); &#125; sum = 1 &#125; else &#123; sum = 0; &#125; &#125; let ans = res.join(&quot;&quot;); return ans;&#125; 3、无重复字符的最长子串题目：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 例如：输入: s = “abcabcbb”。输出: 3 。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 思路：像这种子串的问题，最小覆盖子串、字符串的排列、找到字符串中所有字母异位词、无重复字符的最长子串。其实思路基本一致，子串的问题基本都能用滑动窗口的思想来解决。滑动窗口就是双指针的进阶版吧，即维护一个窗口，不断滑动并更新答案。 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。 2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。 3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。 4、重复第 2 和第 3 步，直到right到达字符串S的尽头 第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。下面画图理解一下，needs和window相当于计数器，分别记录T中字符出现次数和「窗口」中的相应字符的出现次数。v 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */const lengthOfLongestSubstring = function(s) &#123; let right = 0, left = 0; let length = 0; let arr = []; //本题的关键在于如何判断是否无重复子串，用indexOf判断新进项即可，或者直接用for循环判断 while (right &lt; s.length) &#123; let index = arr.indexOf(s[right]); if (index !== -1) &#123; arr.splice(0, index + 1); //将重复项之前全部删除,这里其实我们用字符串的操作来代替了滑动窗口的左移 &#125; arr.push(s[right]); length = Math.max(length, arr.length); right++; &#125; return length;&#125;; 4、寻找正序数组的两个中位数题目：给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？ 思路：暴力求解的话极其简单，直接for循环即可，第一时间会想到就是归并排序最后一步。按照 O(log (m+n)) 时间复杂度的话，面对有序数组的排序，首先想到二分查找，见下方，但是对于两个数组的二分查找该如何实现。 123456789101112131415function binary_search(arr,low, high, key) &#123; if (low &gt; high)&#123; return -1; &#125; var mid = parseInt((high + low) / 2); if(arr[mid] == key)&#123; return mid; &#125;else if (arr[mid] &gt; key)&#123; high = mid - 1; return binary_search(arr, low, high, key); &#125;else if (arr[mid] &lt; key)&#123; low = mid + 1; return binary_search(arr, low, high, key); &#125; &#125;; 该题的本质可扩展为寻找两个有序数组的第k小数，不一定是中位数，因此二分查找的本质是partition，每次都剔除k/2个数，且保证这些数都在第k小数左边，即都比第k小数小，然后k = k/2；递归处理后，得到第k小数。 二分查找，关键点在于要partition两个排好序的数组成左右两等份，partition需要满足len(Aleft)+len(Bleft)=(m+n+1)/2 - m是数组A的长度， n是数组B的长度并且partition后 A左边最大(maxLeftA), A右边最小（minRightA), B左边最大（maxLeftB), B右边最小（minRightB) 满足(maxLeftA &lt;= minRightB &amp;&amp; maxLeftB &lt;= minRightA)有了这两个条件，那么median就在这四个数中，根据奇数或者是偶数。 奇数：median = max(maxLeftA, maxLeftB)；偶数：median = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2。 1234567891011121314151617181920212223242526272829303132333435/** * 二分解法 * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123; // 确保nums1为更短的字符串 if (nums1.length &gt; nums2.length) &#123; return findMedianSortedArrays(nums2, nums1); &#125; const m = nums1.length const n = nums2.length let low = 0 let high = m while(low &lt;= high) &#123; const i = low + Math.floor((high - low) / 2) const j = Math.floor((m + n + 1) / 2) - i const maxLeftA = i === 0 ? -Infinity : nums1[i-1] const minRightA = i === m ? Infinity : nums1[i] const maxLeftB = j === 0 ? -Infinity : nums2[j-1] const minRightB = j === n ? Infinity : nums2[j] if (maxLeftA &lt;= minRightB &amp;&amp; minRightA &gt;= maxLeftB) &#123; return (m + n) % 2 === 1 ? Math.max(maxLeftA, maxLeftB) : (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2 &#125; else if (maxLeftA &gt; minRightB) &#123; high = i - 1 &#125; else &#123; low = low + 1 &#125; &#125;&#125;; 5、最长回文子串题目：给你一个字符串 s，找到 s中最长的回文子串。 思路：最长回文子串的关键，其实通过双指针法也可以来处理，根据上题所述的思路很好进行解决，关键在于如何判定是否是回文子串的函数。但回文子串以及后序的回文子序列等问题，由于前后文联系比较紧密，且多次判断是否符合时间复杂度较大，通常使用动态规划来进行求解。 动态转移方程：dp[i] [j] = dp[i+1] [j-1] &amp;&amp; (dp[i] === dp[j])；dp[i] [j]为true指的是：从i到j是回文串。 初始条件：即字符串长度仅为0、1时，必为回文子串，由于有这样的初始条件，初始项比较多，动态转移方程需要修改成:dp[i] [j] = (dp[i] === dp[j] &amp;&amp; (j - i &lt; 2 || dp[i+1] dp[j - 1]))。同样，由于初始条件必然有j &gt; i，像这种初始条件的dp，一般都会使用斜向遍历。 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;string&#125; */const longestPalindrome = function(s) &#123; let res = &quot;&quot;; let dp = Array.from(new Array(s.length), () =&gt; new Array(s.length).fill(0)); //利用Array.from构建二维数组，或者使用for循环也可 for (let i = s.length - 1; i &gt;= 0; i--) &#123; //这里由于动态转移方程中dp[i][..]依赖于dp[i + 1][..]，因此需要倒着遍历来简化操作 for (let j = i; j &lt; s.length; j++) &#123; //同样，由于初始条件原因，j从靠近i到远离i来遍历 dp[i][j] = ((s[i] === s[j]) &amp;&amp; (j - i &lt; 2 || dp[i+1][j-1])); if (dp[i][j] &amp;&amp; (j - i + 1 &gt; res.length)) &#123; res = s.substring(i, j+1); //substring截取字符串，包头不包尾 &#125; &#125; &#125; return res;&#125; 6、Z字形变换题目：将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。请你实现这个将字符串进行指定行数变换的函数：let convert(string s, int numRows)。 P A H N A P L S I I G Y I R 思路：关键在于找规律，中间列每列一个，且列数为numsRows-2；因此将一个第一列与后续的中间列作为一个循环，个数为numsRows + numsRows - 2。这样一个循环就能找出来了，再根据每个字符在循环中的位置，分别将其置入不同行。其中仅循环的第一位为第一行，V形排列。 12345678910111213const convert = function(s, numRows) &#123; if (numRows === 1) &#123; return s; &#125; let rows = new Array(numRows).fill(&quot;&quot;);//用数组依次存储每一行的字符 let circle = (2 * numRows - 2); for (let i = 0; i &lt; s.length; i++) &#123; let x = i % circle; rows[Math.min(x, circle - x)] += s[i]; &#125; let ans = rows.join(&quot;&quot;); return ans;&#125; 7、整数反转题目：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 思路：在先判断正负号之后，用转字符串再转数组后，使用reverse()方法可以简单实现，但可以思考下用数学方法要如何处理。 123456789101112131415161718192021222324//先试一下数组反转，可以轻松解决let reverse = function(x) &#123; let res = x.toString().split(&quot;&quot;); if (res[0] == &quot;-&quot;) &#123; res.push(&quot;-&quot;);//反转后，相当于在前面加-，后面的负号parseInt会忽略掉 &#125; let ans = parseInt(res.reverse().join(&quot;&quot;)); if (ans &gt;= Math.pow(2, 31) || ans &lt;= -Math.pow(2, 31)) &#123; ans = 0; &#125;ue return ans;&#125;//再试一下数学方法，关键在于一位位地取余数let reverse = function(x) &#123; let result = 0; while (x !== 0) &#123; result = x % 10 + result * 10; x = (x / 10) | 0; //通过位运算符保证取整(无论正负)，同时强制转换为32位有符号整数 &#125; return (result | 0) === result ? result : 0; //result | 0 超过32位的整数转换结果不等于自身，可用作溢出判断。&#125; 8、字符串转整数题目：请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。 注意：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数。 1234567891011//像这种字符串匹配的，先想到使用正则即可，先用trim来去掉前后的空格/** * @param &#123;string&#125; s * @return &#123;number&#125; */var myAtoi = function(s) &#123; const re = new RegExp(/^(-|\\+)?\\d+/); let str = s.trim().match(re); let res = str ? Number(str[0]) : 0; return res &gt;= 0 ? Math.min(res, 2**31 - 1) : Math.max(res, -(2**31))&#125;; 9、回文数题目：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 思路：跟前面的整数反转一样，简单的思路的话，直接变数组之后，使用reverse()方法之后判断即可；同样也有数学方法来解决这个问题。 1234567891011121314151617181920212223242526//直接用reverse()/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123; return x === Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;))&#125;;//利用数学方法来一步步求余var isPalindrome = function(x) &#123; if (x &lt; 0) &#123; return false; &#125; let result = 0; let value = x; while (x !== 0) &#123; result = result * 10 + x % 10; x = (x / 10) | 0; &#125; if (value = result) &#123; return true; &#125; else &#123; return false; &#125;&#125; 10、正则表达式匹配12345678910111213141516171819202122232425262728293031const isMatch = (s, p) =&gt; &#123; if (s == null || p == null) return false; const sLen = s.length, pLen = p.length; const dp = new Array(sLen + 1); for (let i = 0; i &lt; dp.length; i++) &#123; dp[i] = new Array(pLen + 1).fill(false); // 将项默认为false &#125; // base case dp[0][0] = true; for (let j = 1; j &lt; pLen + 1; j++) &#123; if (p[j - 1] == &quot;*&quot;) dp[0][j] = dp[0][j - 2]; &#125; // 迭代 for (let i = 1; i &lt; sLen + 1; i++) &#123; for (let j = 1; j &lt; pLen + 1; j++) &#123; if (s[i - 1] == p[j - 1] || p[j - 1] == &quot;.&quot;) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else if (p[j - 1] == &quot;*&quot;) &#123; if (s[i - 1] == p[j - 2] || p[j - 2] == &quot;.&quot;) &#123; dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 2] || dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i][j - 2]; &#125; &#125; &#125; &#125; return dp[sLen][pLen]; // 长sLen的s串 是否匹配 长pLen的p串&#125;; 11、盛水最多的容器题目：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。 示例：输入：[1,8,6,2,5,4,8,3,7]；输出：49 ；解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 思路：其实是一个滑动窗口(双指针)类型的题目，暴力法：即穷举所有可能，分别计算面积并保存最大值。 双指针法：从左右两侧开始，将较矮柱子的指针进行移动，而先不移动高柱子的指针，原因：矮柱子选取后如果移动高柱子的话面积是一定会减小的，因为长度距离在变小的时候，此时高度只能小于或等于矮的柱子。因此只能移动矮的柱子这边才有可能使得高度比矮柱子大。所以，每次都移动的是高柱子的指针。这种方法其可以看作是暴力法的剪枝，而不是传统的滑动窗口。 1234567891011121314151617181920/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */const maxArea = function(height) &#123; let left = 0; let right = height.length - 1; let ans = 0; while (left &lt; right) &#123; let height1 = Math.min(height[left], height[right]); let aquare = height1 * (right - left); ans = Math.max(ans, aquare); if (height[left] &lt; height[right]) &#123; left++; &#125; else &#123; right--; &#125; &#125; return ans;&#125; 12、整数转罗马数字思路：整数转罗马数字，比罗马数字转整数要简洁一些，同样关键在于求余的操作。 123456789101112/** * @param &#123;number&#125; num * @return &#123;string&#125; */var intToRoman = function(num) &#123; var Q = [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;]; var B = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;]; var S = [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;]; var G = [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;]; return Q[Math.floor(num/1000)] + B[Math.floor((num%1000)/100)] + S[Math.floor((num%100)/10)] + G[num%10];&#125;;//利用Math.floor来直接取整数部分，而不是四舍五入 13、罗马数字转整数思路：罗马数字转整数，首先将所有的组合可能性列出并添加到哈希表中 然后对字符串进行遍历，由于组合只有两种，一种是 1 个字符，一种是 2 个字符，其中 2 个字符优先于 1 个字符 先判断两个字符的组合在哈希表中是否存在，存在则将值取出加到结果 ans 中，并向后移2个字符。不存在则将判断当前 1 个字符是否存在，存在则将值取出加到结果 ans 中，并向后移 1 个字符，遍历结束返回结果 ans。 12345678910111213141516171819202122232425262728const romanToInt = function(s) &#123; const map = &#123; I : 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000 &#125;; let ans = 0; for(let i = 0;i &lt; s.length;) &#123; if(i + 1 &lt; s.length &amp;&amp; map[s.substring(i, i+2)]) &#123; ans += map[s.substring(i, i+2)]; i += 2; &#125; else &#123; ans += map[s.substring(i, i+1)]; i ++; &#125; &#125; return ans;&#125;; 14、最长公共前缀题目：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 思路：很简单的题目，一个个的依次找最长公共前缀，先比较前两个，再用得出的公共前缀来匹配下一个；因此需要两层for循环，第一层，用于获取各个字符串，第二层对比每个字符串的各个字符。 123456789101112131415161718192021222324252627/** * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var longestCommonPrefix = function(strs) &#123; if (strs.length == 0) &#123; return &quot;&quot;; &#125; let res = strs[0]; for (let i = 1; i &lt; strs.length; i++) &#123; let compare = res; res = &quot;&quot;; //前两个先比较,每次比较前修改compare,并重置res for (let j = 0; (j &lt; strs[i].length) &amp;&amp; (j &lt; compare.length); j++) &#123; if (strs[i][j] === compare[j]) &#123; res = res + compare[j]; &#125; else &#123; break; &#125; &#125; if (res == &quot;&quot;) &#123; return &quot;&quot;; //提前退出的条件，剪枝j &#125; &#125; return res;&#125; 15、三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 思路：关键在于如何保证不重复，用常规思路的话，先用三层for循环，之后再用哈希表去重；换一个思路，我们保持三重循环的大框架不变，只需要保证：第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。即这样就只有一种顺序被枚举了，可以先排序，然后再查找。 1234567891011121314151617181920212223242526272829303132333435const threeSum = function(nums) &#123; nums.sort((a, b) =&gt; &#123; return (a - b); &#125;); let res = []; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; break; &#125;//在算法范畴上，进行逻辑的剪枝，此时后续不可能成立 let target = -nums[i]; if ((target + nums[i - 1] == 0) &amp;&amp; i &gt; 0) &#123; continue; //从左往右遍历，此时遇到重复的则直接跳过，使用continue到for的下一个 &#125; //找到一个后，后续的使用双指针来遍历查找，同时去重 let left = i + 1; let right = nums.length - 1; while (left &lt; right) &#123; let n2 = nums[left]; let n3 = nums[right]; if (n2 + n3 === target) &#123; res.push([nums[i], n2, n3]); while (left &lt; right &amp;&amp; nums[left] === n2) left++; //去重复，后面有相同的则这里直接left++跳过去 while (left &lt; right &amp;&amp; nums[right] === n3) right++; //这里在去重时，不要忘记基本的left &lt; right &#125; else if(n2 + n3 &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return res;&#125; 16、最接近的三数之和题目：给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 思路：同样的思路，排序加双指针的做法能够很好地判断该如何去判断怎么去移动；同样，本题中不需要去考虑重复的问题了。 123456789101112131415161718192021222324const threeSumClosest = function(nums, target) &#123; nums.sort((a, b) =&gt; &#123; return (a - b); &#125;); let ans = 0; let compare = Infinity; for (let i = 0; i &lt; nums.length; i++) &#123; let left = i + 1; let right = nums.length - 1; while (left &lt; right) &#123; let compare2 = target - nums[left] - nums[right] - nums[i]; if (Math.abs(compare2) &lt; compare) &#123; ans = nums[i] + nums[right] + nums[left]; compare = Math.abs(compare2) &#125; if (compare2 &lt; 0) &#123; right--; &#125; else &#123; left++; &#125; &#125; &#125; return ans;&#125; 17、电话号码的组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 思路：看上去十分容易，本质是一个三叉树的遍历方法，可以用BFS或者DFS。由这个题，我们可以先引申一下深度遍历和广度遍历的思路逻辑与基本方法。 1、DFS回溯（回溯是一种算法思想，一般可以用递归来实现。通俗点讲回溯就是一种试探,类似于穷举,但回溯有“剪枝”功能,） 回溯本质是暴力搜索，在问题的解空间树中，用 DFS 的方式，从根节点出发搜索整个解空间。如果要找出所有的解，则要搜索整个子树，如果只用找出一个解，则搜到一个解就可以结束搜索。类似「找出所有可能的组合」的问题，适合回溯算法。 回溯类题目，有三个关键点： (1).选择:决定了你每个节点有哪些分支，可以帮助你构建出解的空间树。 (2).约束条件:用来剪枝，剪去不满足约束条件的子树，避免无效的搜索。 (3).目标:决定了何时捕获解，或者剪去得不到解的子树，提前回溯。 回溯法实质:它的求解过程实质上是先序遍历一棵“状态树”的过程。只不过，这棵树不是遍历前预先建立的，而是隐含在遍历过程中。如果认识到这点，很多问题的递归过程设计也就迎刃而解了。【回溯与递归的区别】回溯这个算法思想可以由递归这个算法结构来实现 我们构建一个递归来实现DFS，。递归的关键：递归关系与递归终止条件。（其他的扔给递归） 1、找整个递归的终止条件：递归应该在什么时候结束？2、找返回值：应该给下一级返回什么信息？3、本级递归应该做什么：在这一级递归中，应该完成什么任务？ 12345678910111213141516171819202122const letterCombinations = (digits) =&gt; &#123; if (digits.length === 0) &#123; return []; &#125; const res = []; const map = new Map([[&#x27;2&#x27;,&#x27;abc&#x27;], [&#x27;3&#x27;,&#x27;def&#x27;],[&#x27;4&#x27;,&#x27;ghi&#x27;],[&#x27;5&#x27;,&#x27;jkl&#x27;],[&#x27;6&#x27;,&#x27;mno&#x27;],[&#x27;7&#x27;,&#x27;pqrs&#x27;],[&#x27;8&#x27;,&#x27;tuv&#x27;],[&#x27;9&#x27;,&#x27;wxyz&#x27;]]); const dfs = (curStr, i) =&gt; &#123;//递归的传递参数包括，当前已经遍历树的结果、以及层数i if (i &gt; digits.length - 1) &#123; res.push(curStr); return;//一个树的递归分支结束 &#125; let letters = map.get(digits[i]); for (j of letters) &#123; //for in 用于遍历对象,for of用于遍历有Iterator接口的对象, dfs(curStr, i+1); &#125; &#125; dfs(&quot;&quot;, 0); return res;&#125; 2、BFS广度搜索的方法 BFS通常是维护一个队列，即一层层地进行遍历，每次将对应层数的叶子加到之前层上，这里可以使用队列先进先出来解决，先进先出，依次地每次更新对应的下一层的结果。 123456789101112131415161718192021222324/** * @param &#123;string&#125; digits * @return &#123;string[]&#125; */const letterCombinations = (digits) =&gt; &#123; if (digits.length == 0) &#123; return []; &#125; let res = []; let map = new Map([[&#x27;2&#x27;,&#x27;abc&#x27;], [&#x27;3&#x27;,&#x27;def&#x27;],[&#x27;4&#x27;,&#x27;ghi&#x27;],[&#x27;5&#x27;,&#x27;jkl&#x27;],[&#x27;6&#x27;,&#x27;mno&#x27;],[&#x27;7&#x27;,&#x27;pqrs&#x27;],[&#x27;8&#x27;,&#x27;tuv&#x27;],[&#x27;9&#x27;,&#x27;wxyz&#x27;]]); let queue = []; queue.push(&#x27;&#x27;); for (let i = 0; i &lt; digits.length; i++) &#123;//bfs二叉树的层数，就是digits的长度 let levelSize = queue.length;//获取当前层的节点数，从而能逐个让当前层节点出列，更新接上对应后续节点后再依次入列 for (let j = 0; j &lt; levelSize; j++) &#123; let curStr = queue.shift(); //模拟队列 let letters = map.get(digits[i]); for (let k of letters) &#123; queue.push(curStr + k); &#125; &#125; &#125; return queue;&#125; 18、四数之和题目：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组 思路：其实跟前面的三数之和思路一样，后面两个数可以用双指针法来进行枚举；而前面两个数只能通过两层的for循环来实现。同样，先对数组进行排序，且添加每个数时都要进行重复判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const fourSum = function(nums, target) &#123; const quadruplets = []; if (nums.length &lt; 4) &#123; return quadruplets; &#125; nums.sort((x, y) =&gt; x - y); const length = nums.length; for (let i = 0; i &lt; length - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) &#123; continue;//从左往右遍历，有跟上一条重复的则跳过 &#125; if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123; break; &#125; if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123; continue;//上面两种情况都是剪枝，以减少事件复杂度 &#125; for (let j = i + 1; j &lt; length - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) &#123; continue; &#125; if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123; break; &#125; if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123; continue; &#125; let left = j + 1, right = length - 1; while (left &lt; right) &#123; const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum === target) &#123; quadruplets.push([nums[i], nums[j], nums[left], nums[right]]); while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) &#123; left++; &#125; left++; while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) &#123; right--; &#125; right--; &#125; else if (sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; &#125; return quadruplets;&#125;; 19、删除链表的倒数第N个结点题目:给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？ 思路：不要求时间复杂度的话，先扫一遍来确定链表的长度，而后再根据长度找到倒数第N个结点；要使用一趟扫描实现的话，可以使用双指针来进行。第一个指针比第二个快n个，这样第二个指向尾节点时，则第一个指向要删除的结点。 12345678910111213141516const removeNthFromEnd = function(head, n) &#123; let start = new ListNode; //一般先定义一个空结点放到现有的头节点前面，之后以该空结点作链表处理，从而能够避免因链表长度不够导致的报错 start.next = head; let left = start; let right = start; for (let i = 0; i &lt; n; i++) &#123; right = right.next; &#125; while (right.next != null) &#123; left = left.next; right = right.next; &#125; left.next = left.next.next; return start.next;&#125;; 20、有效的括号题目：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 思路：类似于栈的操作，判断很简单，这里就不赘述了。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;string&#125; s * @return &#123;boolean&#125; *//** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; if (s.length == 0) &#123; return true; &#125; let compare = []; for (let i = 0; i &lt; s.length; i++) &#123; if (s[i] === &quot;(&quot; || s[i] === &quot;[&quot; || s[i] === &quot;&#123;&quot;) &#123; compare.push(s[i]); &#125; else if (s[i] === &quot;)&quot;) &#123; let a = compare.pop(); if (a !== &quot;(&quot;) &#123; return false; &#125; &#125; else if (s[i] === &quot;]&quot;) &#123; let a = compare.pop(); if (a !== &quot;[&quot;) &#123; return false; &#125; &#125; else if (s[i] === &quot;&#125;&quot;) &#123; let a = compare.pop(); if (a !== &quot;&#123;&quot;) &#123; return false; &#125; &#125; &#125; if (compare.length == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;;","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"正则面试题汇总","slug":"前端/正则面试题汇总","date":"2021-02-06T13:28:16.000Z","updated":"2021-03-12T14:51:31.041Z","comments":true,"path":"2021/02/06/前端/正则面试题汇总/","link":"","permalink":"http://yoursite.com/2021/02/06/%E5%89%8D%E7%AB%AF/%E6%AD%A3%E5%88%99%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"前言正则表达式是匹配模式，要么匹配字符，要么匹配位置。关于正则表达式的原理和写法，网上的文章已经特别之多了，本篇文章将不着重于原理与方法，将直接以各种题目的形式来进行正则表达式的介绍，同样，题目的难度也将由弱至强。首先附上经典的正则链接网站：regulex。 基本符号 字符组 用于纵向模糊匹配，[]组内代表一个字符元素 ^ 在第一位放脱字符，表示求反的概念 \\d [0-9]，digit，表示一位数字 \\D [^0-9]，表示除数字外的任意字符 \\w [0-9a-zA-Z]，word，表示数字、大小写字母和下划线等单词字母 \\W [^0-9a-zA-Z]，表示非单词字母 \\s [\\t\\v\\n\\r\\f]，space，表示空白格，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 \\S [^ \\t\\v\\n\\r\\f]，表示非空白符 . [^\\n\\r\\u2028\\u2029]，通配符，表示几乎任意字符，换行、回车、行分隔、段分隔符除外。 \\1 反向引用，代表第一个用括号区分的分组，括号嵌套的号由开括号（来判断 量词 用于横向匹配，匹配多个字符，默认为贪婪匹配，可后加?变为惰性匹配 {m,} 表示至少出现m次 ？ 等价于{0，1}，表示出现或不出现 + 等价于{1，}，表示出现至少一次 * 等价于{0，}，表示出现任意次或者不出现 位置特性 用于位置方式的匹配 ^、$ 脱字符、美元符号分别在多行匹配中，匹配行开头与行结尾 \\b 匹配单词边界，具体就是\\w与\\W之间的位置，也包括\\w与^、$之间的 \\B 同样，是\\b的反面的意思 (?=p) p为一个子模式，即匹配p前面的位置 (?!p) 其实就是(?=p)取反，除了p前面的位置以外的所有位置 方法 返回值与参数 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。regex.test(string) exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）regex.exec(string) match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。string.match(regex)；match返回的是一个数组，包括各个括号匹配的内容 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。string.replace(regex, “ ”) split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。 简单正则匹配字符匹配16进制颜色值要求匹配：#12f3a1，#ffBabd，#FFF；等颜色值字母不区分大小写，且可为3位或者六位 123let regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;let string = &quot;#12f3a1 #ffBabd #FFF #123 #586&quot;;console.log(string.match(regex)); 相当简单的正则，主要就是把基础知识运用下，只有两个分支匹配且逻辑清楚。 24小时时间要求匹配：23：59，04：09，8：9，19：47；这样的时间，前面的0可以省略也可带着 12345678let regex = /^(0?[0-9]|1[0-9]|2[0-3]):(0?[0-9]|[1-5][0-9])$/;let arr = [&quot;23:59&quot;, &quot;04:09&quot;, &quot;8,9&quot;, &quot;19:47&quot;];let res = [];for (let i = 0; i &lt; arr.length; i++) &#123; if (regex.test(arr[i])) &#123; res.push(arr[i]); &#125;&#125; 也是比较简单的正则，记得用括号将各段隔开，不然运算顺序可能不与你想的一致。 IP地址要求匹配：192.168.225.255，156.234.156.215，1.2.3.4;类似的IP地址 12345678let regex = /^(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d)\\.\\1\\.\\1\\.\\1$/;let arr = [&quot;192.168.225.255&quot;, &quot;156.234.156.215&quot;, &quot;1.2.3.4&quot;];let res = [];for (let i = 0; i &lt; arr.length; i++) &#123; if (regex.test(arr[i])) &#123; res.push(arr[i]); &#125;&#125; 这里的.字符需要转义，且利用括号分组来复用前面的正则。\\1代表第一个括号引用的分组，根据第一个开括号(来确认。 带格式日期要求匹配：2020-09-12，2043-12-30，2018/08/09，2016.06.21；分隔符有三种可用，且要求分隔符前后使用一样。 12345678let regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;let res = [];let arr = [&quot;2020-09-12&quot;，&quot;2043-12-30&quot;，&quot;2018/08/09&quot;，&quot;2016.06.21&quot;];for (let i = 0; i &lt; arr.length; i++) &#123; if (regex.test(arr[i])) &#123; res.push(arr[i]); &#125;&#125; 要求分隔符前后一致，因此我们就必须用上题提过的括号分组复用，才能够实现这样的功能。我这里没有对日期的期限进行要求，直接用的数字均可，有要求的话，根据之前IP例题的逻辑，也能够很容易写出，这里就不再赘述。 同样，分组复用可以实现简单的替换，例如：想把yyyy-mm-dd替换成mm/dd/yyyy，以下的代码可以实现 123456let regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;let string = &quot;2020-09-12&quot;;let res = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);//RegExp中的$1、$2、$3代表第1、2、3个分组 字符串去重实例：将”aaaaabbbbbccccc”去重返回成为”abc”。利用括号分组的同样匹配，来实现查询出重复字符的效果，由于重复字符可以出现多次，因此后面还要加上+,表示至少出现一次。 1234let regex = /(\\w)\\1+/g;//g代表全局匹配，会在一次匹配结束后继续匹配多次。而非仅匹配一次let str = &quot;aaaaabbbbbddddggggggggffff&quot;;let res = str.replace(regex, &quot;$1&quot;); HTML标签要求匹配HTML标签a内容，比如”“”“，即匹配出两个&lt;&gt;之间，且第一个字符为a 1let regex = /&lt;a[^&gt;]+&gt;/g 这里的^脱字符代表取反，即除了”&gt;”以外均匹配。 驼峰字符串要求将一个连续字符串如：get-element-by-id转化成驼峰形式 123function toHump(str) &#123; return str.replace(/-(\\w)/g, function($1))&#125; 将-后面是字符的-与首字符的位置均匹配到，然后将$1，即-后的字符变成大写后replace进去 邮箱格式1.不限制长度 2.不限制大小写 3.邮箱开头必须是数字或字符串 4.邮箱中可以使用字母、数字、点号、下划线、减号，但是不能连写点号、下划线、减号，如 &#x61;&#98;&#x63;&#95;&#x2d;&#100;&#x65;&#64;&#x71;&#x5f;&#46;&#113;&#x2e;&#99;&#111;&#x6d; 5.@符号前后不能为点号、下划线、减号 1234function isAvailableEmail(sEmail) &#123; let reg = /^([\\w+\\._-])+@\\w+[\\.\\w]+$/; return reg.test(sEmail);&#125; 识别十进制整数修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例。 eg：’12px’、’0x12’ 123456789function parse2Int(num) &#123; var regex=/^\\d+/; num=regex.exec(num)[0]; return parseInt(num);&#125;;//或者可以直接使用parseInt(num, 10)；这个API会自动识别非十进制的数，将其排除在外function parse2Int(num) &#123; return parseInt(num,10);&#125; 颜色字符串转换考的知识点两个： 正则表达式匹配； toString(16)转换进制；toString()可用于转换进制、判断引用类型。 做的过程中注意： 数值超界（0-255） 不足两位补零 123456789101112131415161718function rgb2hex(sRGB) &#123; let reg = /rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/; let res = sRGB.match(reg);//match返回一个数组或者在未匹配到时返回null if (!res) &#123; return sRGB; &#125; else &#123; let str = &#x27;#&#x27;; for (let i = 1; i &lt;= 3; i++) &#123; let num = parseInt(res[i]); if (num &lt;= 255 &amp;&amp; num &gt;= 0) &#123; str += (num &lt; 16 ? &#x27;0&#x27; + num.toString(16) : num.toString(16)); &#125; else &#123; return sRGB; &#125; &#125; return str; &#125;&#125; 变为驼峰replace() 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。 这个用法的本质就是：对str使用RegArg做match()匹配，如果匹配到多项结果（比如使用了全局匹配g，或者分组），那么每一个匹配结果都将执行一次FuncArg函数，并且用该函数的返回值替代源字符串中的匹配项。 第一个参数可以是字符串或正则表达式，如果提供的是字符串，只会替换第一个子字符串。如果想替换所有子字符串，需要提供一个指定了 g 的正则表达式。 第二个参数可以是字符串或函数。如果是字符串，可以使用一些特殊的 字符序列： 如果第二个参数也可以是函数，这个函数接收多个参数：function (match[，p1, p2, …, pn], offset, string) match：匹配的子串，等同于前面提到的 $&amp; p1-p2：为捕获组对应的匹配字符串（如果设置了捕获组）。 offset：模式匹配项位于输入字符串的位置 string：输入的原始字符串。 函数的返回值：返回值即为替换的文本。 css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能 1、以 - 为分隔符，将第二个起的非空单词首字母转为大写 2、-webkit-border-image 转换后的结果为 webkitBorderImage 123456789function cssStyle2DomStyle(sName) &#123; let reg = /-(\\w)/g; let res = sName.replace(reg, function(fullMatch, g1, index) &#123; if (index === 0) return g1; //当模式串匹配的为单词的首项时，证明-在最前面，此时返回小写字母，将-a替换成a。 return g1.toUpperCase(); &#125;); return res;&#125; 获取url中参数 指定参数名称，返回该参数的值 或者 空字符串 不指定参数名称，返回全部的参数对象 或者 {} 如果存在多个同名参数，则返回数组 例:输入：http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe key；输出：[1, 2, 3] 方法一：使用字符串拼接来匹配。 1234567891011121314151617/* 获取URl中的参数* @para url * @para key 参数名*/function getUrlParam(sUrl, sKey) &#123; var left= sUrl.indexOf(&quot;?&quot;) + 1 var right= sUrl.lastIndexOf(&quot;#&quot;) var parasString = sUrl.slice(left, right) var paras = parasString.split(&#x27;&amp;&#x27;); var parasjson = &#123;&#125; paras.forEach(function (value, index, arr) &#123; var a = value.split(&#x27;=&#x27;); parasjson[a[0]] !== undefined ? parasjson[a[0]] = [].concat(parasjson[a[0]], a[1]) : parasjson[a[0]] = a[1]; &#125;); let result = arguments[1] !== void 0 ? (parasjson[arguments[1]] || &#x27;&#x27;) : parasjson; return result&#125; 方法二：使用正则中的replace进行替换 123456789function getUrlParam2(sUrl, sKey) &#123; var result, Oparam = &#123;&#125;; sUrl.replace(/[\\?&amp;]?(\\w+)=(\\w+)/g, function ($0, $1, $2) console.log(&#x27;$0:&#x27; + $0 + &quot; $1:&quot; + $1 + &quot; $2:&quot; + $2); Oparam[$1] === void 0 ? Oparam[$1] = $2 : Oparam[$1] = [].concat(Oparam[$1], $2); &#125;); sKey === void 0 || sKey === &#x27;&#x27; ? result = Oparam : result = Oparam[sKey] || &#x27;&#x27;; return result;&#125; 方法三：使用正则中的exec方法 1234567891011function getUrlParam3(sUrl, sKey) &#123; var resObj = &#123;&#125;; var reg = /(\\w+)=(\\w+)/g; while (reg.exec(sUrl)) &#123; resObj[RegExp.$1] ? resObj[RegExp.$1] = [].concat(resObj[RegExp.$1], RegExp.$2) : resObj[RegExp.$1] = RegExp.$2; &#125; if (sKey) &#123; return (resObj[sKey] ? resObj[sKey] : &#x27;&#x27;); &#125; return resObj;&#125; 域名解析函数parseUrl实现将一段url字段解析为Object，例如url为：”http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title&quot;;parseUrl(url)返回的结果为object如下： 1234567891011121314151617181920212223242526272829303132333435363738let object = &#123; protocol:&quot;http&quot;, host:&quot;www.xiyanghui.com&quot;, path:&quot;product/list&quot;, query: &#123; id:&quot;123456&quot;, sort:&quot;discount&quot; &#125;, hash:&quot;title&quot;&#125;function parseUrl(str) &#123; // 判断是否传入参数 if (str) &#123; var obj = &#123;&#125;; var queryArr = []; // 正则表达式规则 var re = /^(http[s]?):\\/\\/([0-9a-zA-Z\\.]+)\\/([a-zA-Z0-9\\/]+)\\?([a-zA-Z0-9\\=\\&amp;]+)#([0-9a-zA-Z\\.]+)$/; // 利用正则表达式将字符串分组 var reArr = re.exec(str); if (reArr) &#123; obj.peotocol = reArr[1]; obj.host = reArr[2]; obj.path = reArr[3]; queryArr = reArr[4].split(/[\\&amp;\\=]+/); obj.query = &#123;&#125;; for (var i = 0; i &lt; queryArr.length; i += 2) &#123; obj.query[queryArr[i]] = queryArr[i + 1]; &#125; obj.hash = reArr[5] return obj; &#125; else &#123; return null; &#125; &#125; else &#123; return null; &#125;&#125; 位置匹配千位分隔符千位分隔符的关键在于两点：1、使用量词+多次匹配d{3}；2、要求匹配的位置不能是开头，因此用(?!^) 1234let regex = /(?!^)(?=(\\d&#123;3&#125;)+$)/g;let regex = /(?!^)(?=(\\d&#123;3&#125;)+$)/g;//先要求匹配的位置不能是开头,$代表从单词末尾开始匹配，/g代表let string = &quot;123456789&quot;;let res = string.replace(regex, &#x27;,&#x27;); 如果还要求支持”12345783 23498237489 3219482”这样多个数字间用空格来区分的输入的话，只需要将^、$进行修改，改成\\b，从而匹配多个连续字符的开头、结尾，而不是匹配整个字符串的开头、结尾。 123let regex = /(?!\\b)(?=(\\d&#123;3&#125;)+\\b)/g;let string = &quot;12345783 23498237489 3219482&quot;;let res = string.replace(regex, &#x27;,&#x27;); 密码判断多种条件的密码判断往往写成多个小的正则进行判断，下面基本使用三个小的条件进行密码判断。总的要求是：密码长度6-12位，由数字、小写字符、大写字符组成，但必须至少包括2种字符，且必须包含数字 12345678910111213//1、要求密码长度6-12位let regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;//2、要求必须包含数字let regex2 = /?=.*[0-9]/;//即任意数量任意字符的后面前一个位置，后面会接一个数字=&gt;包含一个数字//3、要求同时包含两种let regex3 = /(?=.*[0-9])(?=.*[a-z])/;let arr = [&quot;192.168.225.255&quot;, &quot;156.234.156.215&quot;, &quot;1.2.3.4&quot;];let res = [];for (let i = 0; i &lt; arr.length; i++) &#123; if (regex1.test(arr[i]) &amp;&amp; regex2.test(arr[i]) &amp;&amp; regex3.test(arr[i])) &#123; res.push(arr[i]); &#125;&#125; 替代正则并不是所有的问题均适合使用正则解决：1、有些看似简单的问题，但正则做不到；2、有些能用字符串简单API就能解决的问题，使用正则会提高时间负杂度。 提取年月日123456789101112let string = &quot;2020-09-01&quot;;let regex = /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;console.log(string.match(regex));//输出为[&quot;2020-09-01&quot;, &quot;2020&quot;, &quot;09&quot;, &quot;01&quot;, index: 0, input: &quot;2020-09-01&quot;]//其实，用字符串的split方法来做即可：let string = &quot;2020-09-01&quot;;let res = string.split(&quot;-&quot;);console.log(res);//输出为[&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;]/*split()方法用于把一个字符串分割成字符串数组。separator 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。howmany 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。*/ 模糊查询需要实现的功能是类似百度搜索框的模糊查询，这里先只考虑JS代码，构建的函数传入参数有2个，分别是list存储所有关键词信息的数组、keyword模糊查询的关键词、res查询得出的结果。 indexOf方法stringObject.indexOf(searchValue)该方法从头到尾检索字符串stringObject，看它是否含有子串searchValue，开始检索得位置在字符串的开头，找到searchValue时，则返回其第一次出现的位置，没有找到则返回-1。 123456789function fuzzyQuery (list, keyWord) &#123; let res = []; for (let i = 0; i &lt; list.length; i++) &#123; if (list[i].indexOf(keyWord) &gt;= 0) &#123; res.push(list[i]); &#125; &#125; return res;&#125; split方法stringObject.split(separator)。该方法通过在separator指定的边界处将字符串stringObject分割成子串并返回子串数组。返回的数组中的字串不包括separator自身。如果stringObject中不存在separator，将返回一个只包含stringObject的数组。故可以根据返回数组的长度来判断是否存在子字符串separator 123456789function fuzzyQuery(list, keyWord) &#123; let res = []; for (let i = 0; i &lt; list.length; i++) &#123; if (list[i].split(keyWord).length &gt; 1) &#123; res.push(list[i]); &#125; &#125; return res;&#125; match方法该方法在字符串内检索指定的值，或找到一个或多个正则表达式的匹配；如果没有找到任何匹配的文本，将返回null。否则，将返回一个数组。 123456789function fuzzyQuery(list, keyWord) &#123; let res = []; for (let i = 0; i &lt; list.length; i++) &#123; if (list[i].match(keyWord) != null) &#123; res.push(list[i]); &#125; &#125; return res;&#125; test方法12345678910function fuzzyQuery(list, keyWord) &#123; let reg = new RegExp(keyWord); let res = []; for (let i = 0; i &lt; list.length; i++) &#123; if (reg.test(list[i])) &#123; res.push(list[i]); &#125; &#125; return res;&#125; 搜索框模糊查询实现简单html实现主要关注html实现，就不用上述定义的函数了，而是用更简单的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;onload = function () &#123; //onload事件，页面在加载完成时马上执行的一组代码 function handle() &#123; var keyWords = &#123; &quot;a&quot;: [&quot;abada&quot;, &quot;asdkasdfda&quot;, &quot;askfdlf&quot;], &quot;b&quot;: [&quot;bfsdifdpa&quot;, &quot;杨振宇&quot;, &quot;杨过&quot;], &quot;c&quot;: [&quot;cdfdfgd&quot;, &quot;cgfhjf&quot;, &quot;cuyjk&quot;], &quot;d&quot;:[&quot;dfdgd&quot;,&quot;dyjhfh&quot;,&quot;dhyjgh&quot;] &#125;; if (keyWords[this.value]) &#123; //判断body中是否有这个层,如果有就删掉了 if (document.getElementById(&#x27;dv&#x27;)) &#123; document.body.removeChild(document.getElementById(&#x27;dv&#x27;)); &#125; //开始创建层 var dvObj = document.createElement(&#x27;div&#x27;); dvObj.id = &#x27;dv&#x27;; dvObj.style.width = &#x27;300px&#x27;; //dvObj.style.height = &#x27;200px&#x27;; //将来可以不要 dvObj.style.border = &#x27;1px solid red&#x27;; document.body.appendChild(dvObj); //脱离文档流 dvObj.style.position = &#x27;absolute&#x27;; dvObj.style.left = this.offsetLeft + &#x27;px&#x27;; dvObj.style.top = this.offsetHeight + this.offsetTop + &#x27;px&#x27;; //循环创建 for (var i = 0; i &lt; keyWords[this.value].length; i++) &#123; //创建一个可以存文本的标签 var pObj = document.createElement(&#x27;p&#x27;); pObj.innerText = keyWords[this.value][i]; //p标签要有小手，还有高亮显示 pObj.style.cursor = &#x27;pointer&#x27;; pObj.style.margin = &#x27;5px&#x27;; pObj.onmouseover = function () &#123; this.style.backgroundColor = &#x27;red&#x27;; &#125;; pObj.onmouseout = function () &#123; this.style.backgroundColor = &#x27;&#x27;; &#125; dvObj.appendChild(pObj); //操作节点，把p标签加到层中 //同样可以用insertBefore()来添加 &#125; //创建可以显示文件的标签 &#125; &#125; //firefox下检测状态改变只能用oninput,且需要用addEventListener来注册事件。 if (/msie/i.test(navigator.userAgent)) //ie浏览器 &#123; document.getElementById(&#x27;txt&#x27;).onpropertychange = handle &#125; else &#123;//非ie浏览器，比如Firefox document.getElementById(&#x27;txt&#x27;).addEventListener(&quot;input&quot;, handle, false); //绑定事件对象.addEventListener(事件类型，回调函数，bool值) //如果不传入bool值，或者为false；事件就会走冒泡阶段；反之，事件会走捕获阶段。 &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;span id=&quot;msg&quot;&gt;&lt;/span&gt;请输入搜索关键字&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot; style=&quot;width:300px;height:30px;font-size:25px; border:1px solid green&quot; id=&quot;txt&quot;/&gt;百度一下&lt;/body&gt;&lt;/html&gt; 利用JSONP调用百度接口JSONP(JSONwith Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。 该代码实现搬运自CSDN 实现原理：向输入框动态输入时关键词，将当前关键词作为问号参数后面的值，因为要跨域使用百度的接口，所以通过 JSONP 跨域创建 Ajax 请求。回调函数处理返回值。 1.使用 flex 布局实现搜索框的水平垂直居中。 2.先获取常用的 DOM 节点，避免后续频繁查询操作 DOM。 3.为了避免在输入过程中频繁发送请求(如果打字速度快),对请求函数做了函数节流，调了一下间隔 130ms 差不多正好，时间再长就会有卡顿的感觉。使用了 ES6 中的箭头函数避免了setTimeout 中 this 指向的问题。 4.在回调函数中： 每一次执行时首先要清除建议框里的内容，不然上一次的结果还会存在建议框里！截取了结果中的前五个(如果把所有结果都展示出来感觉有点丑…百度官方是展示前四个搜索建议) 结果处理完毕后，执行自执行匿名函数，删除创建的 script 标签; 5.由于 li 是动态创建的，点击 li 标签或者点击”搜索一下”跳转百度进行搜索时，利用事件冒泡原理，进行事件委托。这里没有考虑兼容性问题： 6.除了点击事件，键盘事件–回车键以及上下键都是进行事件委托进行注册的。最终能够实现键盘上下键鼠标选择，点击“搜索一下”或回车键实现跳转搜索。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 兼容性视图 --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;meta content=&quot;更方便快捷搜索，从而达到事半功倍的效果&quot; name=&quot;description&quot;&gt; &lt;title&gt;search you want&lt;/title&gt; &lt;style&gt; html &#123; height: 100%; &#125; body &#123; background: #f0f3ef; height: 100%; &#125; .container &#123; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; &#125; .bgDiv &#123; box-sizing: border-box; width: 595px; height: 55px; position: relative; /* position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); */ &#125; .search-input-text &#123; border: 1px solid #b6b6b6; width: 495px; background: #fff; height: 33px; line-height: 33px; font-size: 18px; padding: 3px 0 0 7px; &#125; .search-input-button &#123; width: 90px; height: 38px; color: #fff; font-size: 16px; letter-spacing: 3px; background: #3385ff; border: .5px solid #2d78f4; margin-left: -5px; vertical-align: top; opacity: .9; &#125; .search-input-button:hover &#123; opacity: 1; box-shadow: 0 1px 1px #333; cursor: pointer; &#125; .suggest &#123; width: 502px; position: absolute; top: 38px; border: 1px solid #999; background: #fff; display: none; &#125; .suggest ul &#123; list-style: none; margin: 0; padding: 0; &#125; .suggest ul li &#123; padding: 3px; font-size: 17px; line-height: 25px; cursor: pointer; &#125; .suggest ul li:hover &#123; background-color: #e5e5e5 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;bgDiv&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;search-input-text&quot; value=&quot;&quot; autofocus placeholder=&quot;关键词&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索一下&quot; class=&quot;search-input-button&quot; id=&quot;btn&quot;&gt; &lt;div class=&quot;suggest&quot;&gt; &lt;ul id=&quot;search-result&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var suggestContainer = document.getElementsByClassName(&quot;suggest&quot;)[0]; var searchInput = document.getElementsByClassName(&quot;search-input-text&quot;)[0]; var bgDiv = document.getElementsByClassName(&quot;bgDiv&quot;)[0]; var searchResult = document.getElementById(&quot;search-result&quot;); // 清除建议框内容 function clearContent() &#123; var size = searchResult.childNodes.length; //childNodes方法返回数组，根据数组长度判断建议框的长度 for (var i = size - 1; i &gt;= 0; i--) &#123; searchResult.removeChild(searchResult.childNodes[i]); &#125; &#125;; // 回调函数处理返回值 function handleSuggestion(res) &#123; // 清空之前的数据！！ clearContent(); var result = res.s; // 截取前五个搜索建议项 if (result.length &gt; 4) &#123; result = result.slice(0, 5) &#125; for (let i = 0; i &lt; result.length; i++) &#123; // 动态创建li标签 var liObj = document.createElement(&quot;li&quot;); liObj.innerHTML = result[i]; searchResult.appendChild(liObj); &#125; // 自执行匿名函数--删除用于跨域的script标签 (function () &#123; var s = document.querySelectorAll(&#x27;script&#x27;); for (var i = 1, len = s.length; i &lt; len; i++) &#123; document.body.removeChild(s[i]); &#125; &#125;)() &#125;; function jumpPage() &#123; window.open(`https://www.baidu.com/s?word=$&#123;encodeURI(searchInput.value)&#125;`); &#125; var timer = null; // 注册输入框键盘抬起事件 searchInput.onkeyup = function (e) &#123; suggestContainer.style.display = &quot;block&quot;; // 如果输入框内容为空 清除内容且无需跨域请求 if (this.value.length === 0) &#123; clearContent(); return; &#125; if (this.timer) &#123; clearTimeout(this.timer); &#125; if (e.keyCode !== 40 &amp;&amp; e.keyCode !== 38) &#123; // 函数节流优化 this.timer = setTimeout(() =&gt; &#123; // 创建script标签JSONP跨域 var script = document.createElement(&quot;script&quot;); script.src = &quot;https://www.baidu.com/su?&amp;wd=&quot; + encodeURI(this.value.trim()) + &quot;&amp;p=3&amp;cb=handleSuggestion&quot;; document.body.appendChild(script); &#125;, 130) &#125; &#125;; // 事件委托 点击li标签或者点击搜索按钮跳转到百度搜索页面 bgDiv.addEventListener(&quot;click&quot;, function (e) &#123; if (e.target.nodeName.toLowerCase() === &#x27;li&#x27;) &#123; var keywords = e.target.innerText; searchInput.value = keywords; jumpPage(); &#125; else if (e.target.id === &#x27;btn&#x27;) &#123; jumpPage(); &#125; &#125;, false); var i = 0; var flag = 1; // 事件委托 监听键盘事件 bgDiv.addEventListener(&quot;keydown&quot;, function (e) &#123; var size = searchResult.childNodes.length; if (e.keyCode === 13) &#123; jumpPage(); &#125;; // 键盘向下事件 if (e.keyCode === 40) &#123; if (flag === 0) &#123; i = i + 2; &#125; flag = 1; e.preventDefault(); if (i &gt;= size) &#123; i = 0; &#125; if (i &lt; size) &#123; searchInput.value = searchResult.childNodes[i++].innerText; &#125; &#125;; // 键盘向上事件 if (e.keyCode === 38) &#123; if (flag === 1) &#123; i = i - 2; &#125; flag = 0; e.preventDefault(); if (i &lt; 0) &#123; i = size - 1; &#125; if (i &gt; -1) &#123; searchInput.value = searchResult.childNodes[i--].innerText; &#125; &#125;; &#125;, false); // 点击页面任何其他地方 搜索结果框消失 document.onclick = () =&gt; clearContent() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"DOM问题汇总","slug":"前端/DOM问题汇总","date":"2021-01-09T12:02:33.000Z","updated":"2021-03-12T14:51:37.496Z","comments":true,"path":"2021/01/09/前端/DOM问题汇总/","link":"","permalink":"http://yoursite.com/2021/01/09/%E5%89%8D%E7%AB%AF/DOM%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"前言直接操作DOM已经很少在业务场景中用到了，但DOM始终作为前端的基础之一，在面试中往往总能够遇到。本文希望能够汇总以下简单的DOM知识点，让自己在沉迷框架构建时，不至于忽略或者忘记最基础的知识。主要分为两部分：1、常用的DOM方法的汇总；2、DOM的事件机制，主要是事件冒泡与事件捕获。 DOM方法选取元素名称选择名称选择比较简单，主要是根据ID、name属性、标签名称、类名；来选择对应的DOM节点。 12345678//ID选择器：基于id=&quot;&quot;let id = document.getElementById(&quot;id&quot;);//名称选择器:基于name属性let name = document.getElementsByName(&quot;name&quot;);//标签选择器：利用HTML元素的标签名称选取指定类型的元素var h1 = document.getElementsByTagName(&quot;h1&quot;);//类选择器：利用HTML的class属性值选择元素let title = document.getElementsByClassName(title); CSS选择通过CSS样式表选择器的强大语法，也可以来选择元素，返回第一个匹配的元素，或者返回元素数组。 123var title = document.querySelector(&quot;#title&quot;); // CSS ID选择var h1 = document.querySelector(&quot;h1&quot;); //选取第一个h1元素var h1s = document.querySelectorAll(&quot;h1&quot;); //返回所有h1标签元素 相近节点选取节点：页面中所有的内容都是节点（标签，属性，文本：文字，空格，换行）文档：document—-页面中的顶级对象元素：页面中所有的标签，标签–元素–对象（通过DOM的方式来获取这个标签，得到了这个对象，此时这个对象叫DOM对象）。 关于节点的选取有如下的方法： 123456789h1.parentNode;//父节点h1.childNodes;//以数组形式返回子节点h1.firstChild; h1.lastChild;h1.nextSibling;//下一个兄弟节点h1.previousSibling;//前一个兄弟节点h1.nodeType;//返回节点类型的数字表示：1-element节点；3-text节点；8-comment节点；9-document节点；11-documentFragment节点h1.nodeValue;//返回Text 节点 或 Comment 节点的值h1.nodeName;//返回元素的标签名，以大写形式表示 元素相关的选取同样有如下的方法： 1234h2.children;//以数组的形式返回所有的子元素h2.firstElementChild; h2.lastElementChild;//返回首子元素与尾子元素h2.nextElementSibling; h2.previousElementSibling;//返回上一兄弟元素与下一兄弟元素h2.childElementCount;//返回子元素数量 属性相关表示HTML文档元素的HTMLElement对象定义了读/写属性，它们对应于元素的HTML属性。 HTMLElement定义的通用HTML属性，包括id、lang、dir、事件处理程序onclick及表单相关属性等。 1234567891011121314h3.getAttribute(&quot;width&quot;);//返回非标准的HTML属性的值h3.setAttribute(&quot;width&quot;, &quot;150px&quot;);//设置非标准的HTML属性的值h3.hasAttribute(&quot;height&quot;);//判断属性是否存在h3.removeAttribute(&quot;width&quot;);//删除某一属性//在HTML5文档中，任意以 data- 为前缀的小写的属性名字都是合法的。这些 “数据集属性” 定义了一种标准的、附加额外数据的方法//以data-x = &quot;&quot;为例h3.dataset.x;//Node节点定义了 attributes 属性，针对 Element 对象，attributes 是元素所有属性的类数组对象//索引 attributes 对象得到的值是 Attr 对象。Attr 的 name 和 value 返回该属性的名字和值let a = h3.attributes.src.value;h4.innerHTML;//以字符串形式返回这个元素的内容。 也可以用来替换元素当前内容h4.outerHTML;//以字符串形式返回这个元素及内容。 也可以用来替换元素当前内容h4.textContent;//查询或替换纯文本元素内容的标准方法是用Node的textContent属性来实现。 创建节点123456document.createElement(&quot;h1&quot;);//使用document 对象的createElement () 方法创建新的Element节点document.createTextNode(&quot;文本节点&quot;);//创建纯文本节点document.createDocumentFragment();//创建文档片段，往往有更好性能//因为文档片段存在于内存中，并不在Dom树中，所以将子元素插入到文档片段时不会引起页面回流 （对元素位置和几何上计算）document.createCmoment(&quot;....&quot;);//创建注释节点h4.cloneNode(true);//通过复制已存在的节点来创建新的文档节点。传参数true表示深克隆，false表示浅复制 插入、修改节点12345678h5.appendChild(&quot;h1&quot;);//在指定元素上插入子节点，并使其成为该节点的最后一个子节点//一般先新建子节点，再插入子节点h5.insertBefore(&quot;h1&quot;, &quot;h2&quot;);//1. 在父节点上调用本方法2. 第一参数表示待插入的节点//3. 第二参数是父节点中已经存在的子节点，新节点插入到该节点的前面h5.removeChild(&quot;h2&quot;);//在父节点中调用，参数是待删除的节点h5.replaceChild(&quot;h2,&quot;, &quot;h2&quot;);//1. 在父节点上调用;2. 第一参数是新节点;3. 第二个参数是需要替换的节点 DOM事件机制1、事件是在编程时系统内发生的动作或者发生的事情 2、事件是要绑定在元素上的。比如给一个div元素绑定一个鼠标悬浮事件，给一个ol元素绑定鼠标单击事件。 3、可以使用事件监听函数（也叫事件处理程序、侦听器）来监听事件，以便事件发生时执行相应的代码 事件发生时元素节点之间按照特定的顺序传播，这个过程即DOM事件流，描述的是从页面接收事件的顺序。 冒泡与捕获首先开始事件捕获阶段：从DOM树最根部的节点window开始，沿着DOM树向下遍历每个元素，直到触发元素目标元素target。如果这些元素也注册了click事件（且为捕获阶段），就会执行他们相应的事件监听函数。即从上到下触发父元素对应的事件。在事件捕获这一阶段，为截获事件提供了机会。 当前目标阶段：实际的目标接收到，并执行对应得事件监听函数。 事件冒泡阶段：从触发元素目标元素target开始，向上逆着遍历DOM树，直到最根部window元素。如果这些元素也注册了click事件（且为冒泡阶段），就会执行他们相应的事件监听函数 我们在使用 addEventListener 监听事件时，addEventListener(‘click’, fn, bool)如果第三个参数 bool 不传，或者传 false, 那么我们会在冒泡阶段调用 fn如果第三个参数 Bool 传值为 true, 那么我们会在捕获阶段调用 fn。因此，默认是在冒泡阶段来监听事件的。 捕获不可以取消，但是冒泡可以取消，e.propagation()就可但是有一些事件不可以取消冒泡，比如 scroll 事件。 123456&lt;div&gt; &lt;span&gt;文字&lt;/span&gt;&lt;/div&gt;e.target 用户正在操作的元素e.currentTarget 程序员在监听的元素假设我们监听的是 div, 但用户实际点击的是文字，那么e.target 就是 span 标签,e.currentTarget 就是 div 标签。 事件委托冒泡阶段，浏览器从用户点击的内容从下往上遍历至 window，逐个触发事件处理函数，因此可以监听一个祖先节点(例如爸爸节点、爷爷节点)来同时处理多个子节点的事件。 主要的作用有：1、省掉监听数，节省内存；要监听多个兄弟元素时，不如只监听父元素，并在事件处理函数中，利用e.target来判断到底是哪一个子元素触发了事件，再进行对应的处理即可。 2、监听不存在的元素，即动态元素。","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"vue分析","slug":"前端/vue分析","date":"2020-12-06T13:28:16.000Z","updated":"2021-03-12T14:51:58.349Z","comments":true,"path":"2020/12/06/前端/vue分析/","link":"","permalink":"http://yoursite.com/2020/12/06/%E5%89%8D%E7%AB%AF/vue%E5%88%86%E6%9E%90/","excerpt":"","text":"源码思维健壮性代码在发生预期之外的错误时，其应对错误的能力：即就算出错也能够轻松定位到错误，且减少错误的影响范围。 1234567891011//1、不要轻易去相信传入参数，需要判断参数类型function add(a, b) &#123; if (typeof a == &#x27;number&#x27; &amp;&amp; typeof b == &#x27;number&#x27;) &#123; return a + b; &#125; else &#123; throw new Error(&#x27;a&#x27;); &#125;&#125;//2、易错代码用try catch包裹起来a[0] &amp;&amp; a[0].data[0];//取属性之前，先判断其是否存在 defineProperty主要用于vue的数据绑定， 使用defineProperty中的get来进行设置属性时，这个属性不能被改值，因为只写了get，只能够取到值而不能改值；要能够改值则需要写上set。其实这是一种变量权限的问题，如果该变量是某个属性的话，则可以使用defineProperty来控制其各类权限。 123456this.$router = this._root._router;Object.defineProperty(this, &#x27;$router&#x27;, &#123; get() &#123; return this._root._router; &#125;&#125;); 模块支持检测：先判断当前的环境符合的哪种模块规范；cmd、amd、umd，或者CommonJS规范、import规范。 架构模式工厂模式通俗而讲：我去构建一个工厂方法，让使用者调用这个工厂方法去拿到他要的对象，而不是自己去构建，即不需要去new。 典型例子：jquery。使用jquery时是DOM时代，频繁获取并操作DOM。工厂模式直接用$()就可以拿到对象。 1234567891011121314151617181920212223242526//jQuery(function(window) &#123; function jquery() &#123; return new jquery.fn.init(); &#125; jquery.fn.init.prototype = jquery.fn; jquery.fn = jquery.prototype = &#123; init:function() &#123; &#125; &#125; jquery.extend(&#123; //回调。给一个对象，将其添加到jquery上 &#125;) //这样去包装是为了jquery中的方法可以有多种调用方式， //但对象为引用类型，var b = &#123;&#125;, a = b, c = b,修改b时a、c均会修改，实现改一个均影响到。 window.$ = window.jquery = jquery;&#125;)(window);//定义一个匿名自执行函数，不污染外部全局变量，//同时后面直接传参(window),减少作用链长度//vue(function (global, factory) &#123; &#125;(this, function () &#123; &#125;));//this在浏览器环境为window，在node环境为global，不会去写死 建造者模式在构建一个庞大的框架时，先把整个框架分开成几个模块，=》预制=》然后将各个模块融合在一起。 典型例子：vue-2，构建一个庞大的框架。 12345678910111213141516function Vue(options) &#123; if (!(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor&#x27;); &#125; this._init(options);&#125;initMixin(Vue);stateMixin(Vue);eventsMixin(Vue);lifecycleMixin(Vue);renderMixin(Vue);/*为什么非要分开开发，而不是全部放到原型链上即可。1、由于是团队开发，全放在prototype，可能会收到相互之间的影响*/ 函数式整体的功能就是一大堆的函数，通过函数之间的相互调用来实现整体的功能。对于javaScript，函数才是一等公民：1、tree-shaking：基于文档流的原理，判断某个函数是否被调用，因此能够webpack时自动删除未被调用的函数。2、组合大于继承。因此函数式编程适用于工具库。 典型例子：Vue3， 设计模式vue-router、vuex这样的只能有一个，即典型的一个类只有一个实例化对象，即单例模式。实现很容易，就是先判断是否已经被实例化过，如果已经实例化过，就不再实例化；需要通过一个变量判断是否已经实例化过。 1234567var _vue;function install(vue) &#123; if (install.installed &amp;&amp; _vue == vue) return; //执行安装 install.installed = true; _vue = vue;&#125; 代码简洁技巧：jquery中的extend({})方法，传入两个对象时，会将两个对象合并再传入。享元模式：减少重复的代码块的数量，将不同点提取出来作为参数。 1234567891011function () &#123; let target = this; let source = arguments[0]; if (arguments.length == 2) &#123; target = this; source = arguments[1]; &#125; for (let item in source) &#123; target[item] = source[item]; &#125;&#125; 优雅利用原生方法：vue使用defineProperty来实现双向绑定，但只能应用于对象的属性；那么数组怎么来触发更新？将数组原生的push、pop、shift方法加上了能够触发双向绑定的功能。 1234567891011121314let arr = [&quot;push&quot;, &quot;pop&quot;];var arrayProto = Array.prototype;let arrayMethods = Object.create(arraryProto);//执行以下拷贝，来避免污染原生的原型链arr.forEach((methos) =&gt; &#123; arrMethods[method] = function() &#123; let original = arrayProto[method]; let result = original.apply(this, args); //先找到需要修改的方法，并先将原生方法的功能附加上去； dep.noyify();//触发数组更新 return result;//保持返回值与原方法一致 //最后只替换数组中的原型链即可 &#125;&#125;) 应用进阶缓存架构-API优化方案：快、小、省。 缓存：是所有优化方案里最常用、最有效、可以节省http请求，可以从内存中最快读取数据。 1、选择更快的API、算法，减少时间复杂度； 2、看到网站主要消耗的时间，更多地并不在于代码的执行速度，而在于资源加载的速度，因此文件体积小更重要。一、用webpack压缩treeshaking；二、减少代码重复； vue3方面的改进：1、快：更快的API，用proxy来代替defineProperty；代理proxy不会去改变原对象；diff算法方面改进：对比新老的DOM，先分析动态DOM，只比对动态的DOM；2、小：函数式API：拥抱tree-shaking，可以很方便地将没有用到的方法取出来，并不附加在工程文件中。 3、省：节省http请求 读取数据的快慢：最慢：网络请求；其次：从硬盘中拿数据；最快：从内存中拿数据。因此请求缓存思路就是：有缓存的话，不去发送请求而是直接从缓存中拿去数据。 缓存架构的技巧： 1、缓存架构需要使用单例模式，即所有的缓存都放在一个里面。 2、权限问题，存缓的区域不能直接拿出去给别人操作。因此，需要隐藏起来，使用匿名自执行函数来进行；但同样，需要外界能够进行读取缓存操作，因此需要返回一个对象，在该对象内有一系列操作缓存的方法。这其实是函数闭包的应用。 3、缓存都会存在副作用： 一、更新问题：使用localstorage、session、cookies缓存时，缓存至本地，需要考虑更新问题。(1)、与后端进行websocket连接，但过于麻烦，没必要；(2)、通过定期轮询，定时器，每隔一段时间向后端发起ajax请求；经常变动的API不要用这种缓存； 使用内存缓存时，是不用考虑更新问题；但内存缓存同样有自己的问题，需要考虑占用内存问题，每往里面加东西，都会占用内存。javascript的内存限制较严重，因此需要做一个限制。 12345678910111213141516171819202122232425262728293031323334if (!window.mycache) &#123; window.mycache = (function() &#123; var cache = &#123;&#125;; var cacheArr = []; return &#123; get: function (api) &#123; return new Promise(() =&gt; &#123; //promise实现异步以及链式调用 if (cache[api])&#123; resolve(cache[api]) &#125; else &#123; this.set(api).then(()=&gt; &#123; if (cacheArr.length &gt; 10) &#123; let _api = cacheArr.shift(); this.remove(_api); &#125; cache[api] = res; cacheArr.push(api); //需要确保内存限制，不要占用太多内存 resolve(res); &#125;) &#125; &#125;) &#125;, set: function () &#123; return axios.get(api); &#125;, remove: function () &#123; &#125; &#125; &#125;)(); //放在匿名自执行函数里面&#125; vue插件关键的两个API：Vue.use；Vue.mixin。 Vue.use();原理：将一个方法执行一次，如果该方法中有install属性，就执行其install属性，来代替执行该方法； Vue.mixin()；原理：相当于一个全局混合；(局部混合相当于在组件的export后写mixin)，可以混合方法methods、数据data、混合生命周期(生命周期的混入才是核心功能)。即，混入的生命周期操作，所有的组件在对应的生命周期均执行该操作函数。 打包项目=》打包体积过大，可以使用异步加载来减少体积 =》 vuex内容太大；=》vuex异步加载，根据组件来异步加载vuex，放在beforeCreated阶段，在DOM还没有加载好之前，将其之间的依赖关系读取好。 插件的用途：1、提供逻辑复用；2、注入自定义操作； 常用APIVue.util.defineReative：其实就是Vue自身去做响应式的方法，；一般来说只有data的数据能触发响应。这里，我们可以调用这个API，使外部数据也能触发响应。 用法：1、将localstorage中的数据触发响应，不需要将其取出来；2、监听window的事件，常用的是resize，实现尺寸的自适应；3、监听浏览器版本、内存； 本质是让外部数据也能触发响应。 Vue.extend：传入一个对象时，其会返回一个构造函数，直接new便可以创建实例。用于import，在使用import时，导入的是vue的选项。 vue单元测试=》测某个组件的方法和节点渲染结果 render渲染：提供函数，用JS来表达你的整个template，当页面的逻辑较为复杂时。 API层Axios源码分析Axios如何实现请求拦截、响应拦截1、初始化Axios，其实是调用request方法； 请求拦截器设置的处理——发送请求——响应拦截器设置的处理：这些一大堆方法由数组来存储； 123456789101112131415161718192021axios.interceptors.request.use(()=&gt; &#123; &#125;)axios.interceptors.response.use(()=&gt; &#123; &#125;)function axios() &#123; this.interceptors = &#123; request: new interceptorsManner(), response: new interceptorsManner() &#125;&#125;function interceptorsManner()&#123; this.handlers = [];&#125;interceptorsManner.prototype.use((fullfilled, rejected) =&gt; &#123; this.handler.push(&#123; fullfilled: fullfilled; rejected: rejectes; &#125;)&#125;)","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue组件化","slug":"前端/vue组件化","date":"2020-11-06T13:28:16.000Z","updated":"2021-03-12T14:52:02.518Z","comments":true,"path":"2020/11/06/前端/vue组件化/","link":"","permalink":"http://yoursite.com/2020/11/06/%E5%89%8D%E7%AB%AF/vue%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"表单组件简单地自己造一下轮子，实现一下vue的自定组件，这里主要先从form组件开始实践。 form组件需求分析：1、指定数据、校验规则；高内聚、低耦合； 2、这里为了实现form组件的输入功能，我们自定义一个input组件来实现；为保证低耦合性，仅使用并实现双向绑定基本功能。 3、校验的实现跟input分开，再自定义一个KFormItem组件来实现校验的功能。执行校验的组件为KFormItem组件，但通知父组件执行校验的是其子组件KINput，由于事件是谁派发谁监听，不能用this.$emit，需要用this.parent.$emit。之后，在KFormItrm组件上监听校验事件，执行具体校验。 Input实现功能：维护数据； 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;!-- 自定义组件双向绑定：:value @input --&gt; &lt;!-- v-bind=&quot;$attrs&quot;展开$attrs $attrs/$listeners包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。--&gt; &lt;input :type=&quot;type&quot; :value=&quot;value&quot; @input=&quot;onInput&quot; v-bind=&quot;$attrs&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; inheritAttrs: false, // 设置为false避免设置到根元素上， props: &#123; value: &#123; type: String, default: &#x27;&#x27; &#125;, type: &#123; type: String, default: &#x27;text&#x27; &#125; &#125;, methods: &#123; onInput(e) &#123; // 派发一个input事件即可，相当于在原生input上面再封装一个实现了双向绑定的input this.$emit(&#x27;input&#x27;, e.target.value) // 通知父级执行校验 this.$parent.$emit(&#x27;validate&#x27;) &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; KFormItemKformItem组件包裹Input组件，同时在前面添加label标签； 实现功能：1、执行校验2、显示错误信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;!-- label --&gt; &lt;label v-if=&quot;label&quot;&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 校验信息显示 --&gt; &lt;p v-if=&quot;error&quot;&gt;&#123;&#123;error&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// Asyc-validatorimport Schema from &quot;async-validator&quot;;export default &#123; inject: [&quot;form&quot;], data() &#123; return &#123; error: &quot;&quot; // error是空说明校验通过 &#125;; &#125;, props: &#123; label: &#123; type: String, default: &quot;&quot; &#125;, prop: &#123; type: String &#125; &#125;, mounted() &#123; this.$on(&quot;validate&quot;, () =&gt; &#123; this.validate(); &#125;); &#125;, methods: &#123; validate() &#123; // 规则 const rules = this.form.rules[this.prop]; // 当前值 const value = this.form.model[this.prop]; // 校验描述对象 const desc = &#123; [this.prop]: rules &#125;; // 创建Schema实例 const schema = new Schema(desc); return schema.validate(&#123; [this.prop]: value &#125;, errors =&gt; &#123; if (errors) &#123; this.error = errors[0].message; &#125; else &#123; // 校验通过 this.error = &quot;&quot;; &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; KForm一层层地往上面的层级进行靠近，在KForm的层级，除了实现slot将下面的层级包裹，同样也要接受数据并处理。 最终目的是在KForm上除了接受数据模型model以外，还要声明校验规则rules，因此声明数据model、rules。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; provide() &#123; return &#123; form: this &#125;;//直接将组件自己传递出去，这样就能够在下面子组件拿到model、rules &#125;, props: &#123; model: &#123; type: Object, required: true &#125;, rules: &#123; type: Object &#125; &#125;, methods: &#123; validate(cb) &#123; // 获取所有孩子KFormItem // [resultPromise] const tasks = this.$children .filter(item =&gt; item.prop) // 过滤掉没有prop属性的Item .map(item =&gt; item.validate()); // 统一处理所有Promise结果 Promise.all(tasks) .then(() =&gt; cb(true)) .catch(() =&gt; cb(false)); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Index这样，在index层级里面，我们将所有的自定义组件封装起来， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div&gt; &lt;!-- &lt;ElementTest&gt;&lt;/ElementTest&gt; --&gt; &lt;!-- KForm --&gt; &lt;KForm :model=&quot;userInfo&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt; &lt;!-- 用户名 --&gt; &lt;KFormItem label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;KInput v-model=&quot;userInfo.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/KInput&gt; &lt;/KFormItem&gt; &lt;!-- 密码 --&gt; &lt;KFormItem label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;KInput type=&quot;password&quot; v-model=&quot;userInfo.password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/KInput&gt; &lt;/KFormItem&gt; &lt;!-- 提交按钮 --&gt; &lt;KFormItem&gt; &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/KFormItem&gt; &lt;/KForm&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElementTest from &quot;@/components/form/ElementTest.vue&quot;;import KInput from &quot;@/components/form/KInput.vue&quot;;import KFormItem from &quot;@/components/form/KFormItem.vue&quot;;import KForm from &quot;@/components/form/KForm.vue&quot;;import Notice from &quot;@/components/Notice.vue&quot;;export default &#123; data() &#123; return &#123; userInfo: &#123; username: &quot;tom&quot;, password: &quot;&quot; &#125;, rules: &#123; username: [&#123; required: true, message: &quot;请输入用户名称&quot; &#125;], password: [&#123; required: true, message: &quot;请输入密码&quot; &#125;] &#125; &#125;; &#125;, components: &#123; ElementTest, KInput, KFormItem, KForm &#125;, methods: &#123; login() &#123; this.$refs[&quot;loginForm&quot;].validate(valid =&gt; &#123; const notice = this.$create(Notice, &#123; title: &quot;&quot;, message: valid ? &quot;请求登录!&quot; : &quot;校验失败!&quot;, duration: 2000 &#125;); notice.show(); // if (valid) &#123; // alert(&quot;submit&quot;); // &#125; else &#123; // console.log(&quot;error submit!&quot;); // return false; // &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; VueRouter需求分析1、作为一个插件存在：实现VueRouter类和install方法 2、实现两个全局组件：router-view用于显示匹配组件内容，router-link用于跳转 3、监控url变化：监听hashchange或popstate事件 4、响应最新url：创建一个响应式的属性current，当它改变时获取对应组件并显示 实现VueRouter插件在toyRouter.js里面，我们需要实现一个插件，先创建VueRouter类，并且实现其install方法，该方法会在当前的Vue原型链上挂载$router。使用vue.mixin来混入生命周期中，保证每个vue均能实现。 123456789101112131415161718192021222324class KVueRouter &#123; constructor(options) &#123; this.$options = options console.log(this.$options); KVueRouter.install = function (_Vue) &#123; // 保存构造函数，在KVueRouter里面使用 Vue = _Vue; // 挂载$router // 怎么获取根实例中的router选项,混入生命周期钩子即可，该生命周期钩子会在所有组件都执行一遍 //为什么要用混入方式写？主要原因是Vue.use(VueRouter)代码在前，Router实例创建在后，而install逻辑又需要用到该实例 Vue.mixin(&#123; beforeCreate() &#123; // 确保根实例的时候才执行，只有根实例有router选项 if (this.$options.router) &#123; Vue.prototype.$router = this.$options.router &#125; &#125; &#125;)&#125;export default KVueRouter router-link为实现功能，将其写成独立的组件，并在vueRouter的install方法中再将其引入。 router-link实现的功能是：解析用户输入的路由值，并重新渲染一个输入路由值对应的a标签。且在纯运行时的环境，不能使用template而需要用render函数来渲染页面，这里我们需要渲染一个a标签。 12345678910111213141516export default &#123; props: &#123; to: &#123; type: String, required: true &#125;, &#125;, render(h) &#123; // &lt;a href=&quot;#/about&quot;&gt;abc&lt;/a&gt; // &lt;router-link to=&quot;/about&quot;&gt;xxx&lt;/router-link&gt;，值是用户通过props传进来的，因此直接用this.to，前面拼上#为了使用方便 // h(tag, data, children) console.log(this.$slots); return h(&#x27;a&#x27;, &#123; attrs: &#123; href: &#x27;#&#x27; + this.to &#125; &#125;, this.$slots.default) // return &lt;a href=&#123;&#x27;#&#x27; + this.to&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt; &#125;&#125; router-viewrouter-view实现的功能基本上是：根据当前的路由值，获取对应的component并渲染在当前位置。 1、需要监控路由的变化，且为了实现路由改变时，便实时刷新页面，因此需要设置当前路由值为响应式数据。 2、为了确保查找的快速，在新建VueRouter时就应该以用户输入路由配置，初始化一个hash表，这样每次获取当前路由值的component时，只用O(1)时间即可。 1234567891011121314151617181920212223242526272829303132333435//上述两点应该在VueRouter类中实现，因此VueRouter更新为：class KVueRouter &#123; constructor(options) &#123; this.$options = options console.log(this.$options); // 需要创建响应式的current属性，当当前路由路径发生变化时，则页面就会重新渲染，这就是响应式 // 利用Vue提供的defineReactive做响应化 // 这样将来current变化的时候，依赖的组件会重新render Vue.util.defineReactive(this, &#x27;current&#x27;, &#x27;/&#x27;) // this.app = new Vue(&#123; // data() &#123; // return &#123; // current: &#x27;/&#x27; // &#125; // &#125; // &#125;) // 监控url变化，利用bind锁定this，避免你使用的onHashChange函数的this变成后面的window window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) window.addEventListener(&#x27;load&#x27;, this.onHashChange.bind(this))//除了路由修改以外，用户刷新页面也要有重新渲染 // 创建一个路由映射表 this.routeMap = &#123;&#125; options.routes.forEach(route =&gt; &#123; this.routeMap[route.path] = route &#125;) &#125; onHashChange() &#123; console.log(window.location.hash); this.current = window.location.hash.slice(1);//由于前面还有#号，因此需要slice切割一下 &#125;&#125; 而在router-view页面要实现的功能就要简单些了，主要是从路由映射hsahMap中获取对应组件，这里同样要用render函数来渲染。 12345678910export default &#123; render(h) &#123; //获取path对应的component const &#123;routeMap, current&#125; = this.$router;//从路由映射中找到对应的路由，用hash表来查找，快速找到结果 console.log(routeMap,current); const component = routeMap[current].component || null; return h(component) &#125;&#125; Vuex目的：集中管理数据、可预测的改变数据；类似于整个项目数据的大管家，确保整个程序的状态、数据能够保持同步的状态，维持稳定。 需求分析1、实现一个插件：声明Store类，挂载$store 2、：创建响应式的state，保存mutations、actions和getters 3、实现commit根据用户传入type执行对应mutation 4、实现dispatch根据用户传入type执行对应action，同时传递上下文 5、实现getters，按照getters定义对state做派生 实现store插件声明Store、install方法，并创建一个响应式的state。同时利用存取器，避免用户直接去取state 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 保存构造函数引用，避免importlet Vue;class Store &#123; constructor(options) &#123; // this.$options = options; this._mutations = options.mutations; this._actions = options.actions; // 响应化处理state // this.state = new Vue(&#123; // data: options.state // &#125;) this._vm = new Vue(&#123; data: &#123; // 加两个$，Vue不做代理，因此对外部是隐藏的，不能直接去访问。 $$state: options.state &#125; &#125;) // 绑定commit、dispatch的上下文问store实例 this.commit = this.commit.bind(this) this.dispatch = this.dispatch.bind(this) &#125; // 存取器， 用户通过store.state的方式来访问，这样避免用户直接修改state。 //官方的实现是：使用一个watch去监听任何修改，一旦用户尝试修改，则直接报错。 get state() &#123; console.log(this._vm); return this._vm._data.$$state &#125; set state(v) &#123; console.error(&#x27;无法修改！&#x27;); &#125;function install(_Vue) &#123; Vue = _Vue; Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$store = this.$options.store &#125; &#125; &#125;)&#125;// Vuexexport default &#123; Store, install&#125; 实现commit、dispatch方法在写方法之前需要将this.commit、this.dispatch绑定为该store实例，在构造函数上加上：this.commit = this.commit.bind(this)；this.dispatch = this.dispatch.bind(this)。 123456789101112131415161718192021222324class Store &#123; /* 在写方法之前需要将this.commit、this.dispatch绑定为该store实例，在构造函数上加上： this.commit = this.commit.bind(this); this.dispatch = this.dispatch.bind(this); */ // store.commit(&#x27;add&#x27;, 1) // type: mutation的类型 // payload：载荷，是参数 commit(type, payload) &#123; const entry = this._mutations[type] if (entry) &#123; entry(this.state, payload) &#125; &#125; dispatch(type, payload) &#123; const entry = this._actions[type] if (entry) &#123; entry(this, payload) &#125; &#125;&#125; 实现getters","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"数据结构算法","slug":"算法/数据结构算法","date":"2020-10-08T11:42:38.000Z","updated":"2020-10-09T07:06:55.340Z","comments":true,"path":"2020/10/08/算法/数据结构算法/","link":"","permalink":"http://yoursite.com/2020/10/08/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/","excerpt":"","text":"二叉搜索树的操作集锦总路线⼆叉树算法的设计的总路线：明确⼀个节点要做的事情，然后剩下的事抛给 框架。 123456void traverse(TreeNode root) &#123; // root 需要做什么？在这做。 // 其他的不⽤ root 操⼼，抛给框架 traverse(root.left); traverse(root.right); &#125; 如何把⼆叉树所有的节点中的值加⼀？123456void plusOne(TreeNode root) &#123; if (root == null) return; root.val += 1; plusOne(root.left); plusOne(root.right); &#125; 如何判断两棵⼆叉树是否完全相同？1234567891011boolean isSameTree(TreeNode root1, TreeNode root2) &#123; // 都为空的话，显然相同 if (root1 == null &amp;&amp; root2 == null) return true; // ⼀个为空，⼀个⾮空，显然不同 if (root1 == null || root2 == null) return false; // 两个都⾮空，但 val 不⼀样也不⾏ if (root1.val != root2.val) return false; // root1 和 root2 该⽐的都⽐完了 return isSameTree(root1.left, root2.left) &amp;&amp; isSameTree(root1.right, root2.right); &#125; 借助框架可以理解上述两个例子，那么就能解决所有二叉树算法。 二叉搜索树BST是一种很常用的二叉树，定义为：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树所有节点的值。 基础操作有：判断合法性、增、删、查。 判断BST的合法性这⾥是有坑的哦，我们按照刚才的思路，每个节点⾃⼰要做的事不就是⽐较 ⾃⼰和左右孩⼦吗？看起来应该这样写代码： 1234567boolean isValidBST(TreeNode root) &#123; if (root == null) return true; if (root.left != null &amp;&amp; root.val &lt;= root.left.val) return false; if (root.right != null &amp;&amp; root.val &gt;= root.right.val) return false; return isValidBST(root.left) &amp;&amp; isValidBST(root.right); &#125; 但是这个算法出现了错误，BST 的每个节点应该要⼩于右边⼦树的所有节 点，下⾯这个⼆叉树显然不是 BST，但是我们的算法会把它判定为 BST。出现错误，不要慌张，框架没有错，⼀定是某个细节问题没注意到。我们重 新看⼀下 BST 的定义，root 需要做的不只是和左右⼦节点⽐较，⽽是要整 个左⼦树和右⼦树所有节点⽐较。怎么办，鞭⻓莫及啊！ 这种情况，我们可以使⽤辅助函数，增加函数参数列表，在参数中携带额外 信息，请看正确的代码： 123456789boolean isValidBST(TreeNode root) &#123; return isValidBST(root, null, null); &#125;boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123; if (root == null) return true; if (min != null &amp;&amp; root.val &lt;= min.val) return false; if (max != null &amp;&amp; root.val &gt;= max.val) return false; return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max); &#125; 在BST中查找一个数是否存在根据我们的指导思想，可以这样写代码： 1234567boolean isInBST(TreeNode root, int target) &#123; if (root == null) return false; if (root.val == target) return true; return isInBST(root.left, target) || isInBST(root.right, target); &#125; 这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑⼀ 点细节问题了：如何充分利⽤信息，把 BST 这个“左⼩右⼤”的特性⽤上？ 很简单，其实不需要递归地搜索两边，类似⼆分查找思想，根据 target 和 root.val 的⼤⼩⽐较，就能排除⼀边。我们把上⾯的思路稍稍改动： 12345678910boolean isInBST(TreeNode root, int target) &#123; if (root == null) return false; if (root.val == target) return true; if (root.val &lt; target) return isInBST(root.right, target); if (root.val &gt; target) return isInBST(root.left, target); // root 该做的事做完了，顺带把框架也完成了，妙 &#125; 于是，我们对原始框架进⾏改造，抽象出⼀套针对 BST 的遍历框架： 12345678void BST(TreeNode root, int target) &#123; if (root.val == target) // 找到⽬标，做点什么 if (root.val &lt; target) BST(root.right, target); if (root.val &gt; target) BST(root.left, target); &#125; 在 BST 中插⼊⼀个数对数据结构的操作⽆⾮遍历 + 访问，遍历就是“找”，访问就是“改”。具体到 这个问题，插⼊⼀个数，就是先找到插⼊位置，然后进⾏插⼊操作。 上⼀个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框 架，加上“改”的操作即可。⼀旦涉及“改”，函数就要返回 TreeNode 类型， 并且对递归调⽤的返回值进⾏接收。 123456789101112TreeNode insertIntoBST(TreeNode root, int val) &#123; // 找到空位置插⼊新节点 if (root == null) return new TreeNode(val); // if (root.val == val) // BST 中⼀般不会插⼊已存在元素 if (root.val &lt; val) root.right = insertIntoBST(root.right, val); if (root.val &gt; val) root.left = insertIntoBST(root.left, val); return root; &#125; 在 BST 中删除⼀个数这个问题稍微复杂，不过你有框架指导，难不住你。跟插⼊操作类似， 先“找”再“改”，先把框架写出来再说： 1234567891011TreeNode deleteNode(TreeNode root, int key) &#123; if (root.val == key) &#123; // 找到啦，进⾏删除 &#125; else if (root.val &gt; key) &#123; root.left = deleteNode(root.left, key); &#125; else if (root.val &lt; key) &#123; root.right = deleteNode(root.right, key); &#125; return root; &#125; 找到⽬标节点了，⽐⽅说是节点 A，如何删除这个节点，这是难点。因为删 除节点的同时不能破坏 BST 的性质。有三种情况，⽤图⽚来说明。 情况 1：A 恰好是末端节点，两个⼦节点都为空，那么它可以当场去世了。 情况 2：A 只有⼀个⾮空⼦节点，那么它要让这个孩⼦接替⾃⼰的位置。 情况 3：A 有两个⼦节点，⿇烦了，为了不破坏 BST 的性质，A 必须找到 左⼦树中最⼤的那个节点，或者右⼦树中最⼩的那个节点来接替⾃⼰。我们 以第⼆种⽅式讲解。 三种情况分析完毕，填⼊框架，简化⼀下代码： 1234567891011121314151617181920212223TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return null; if (root.val == key) &#123; // 这两个 if 把情况 1 和 2 都正确处理了 if (root.left == null) return root.right; if (root.right == null) return root.left; // 处理情况 3 TreeNode minNode = getMin(root.right); root.val = minNode.val; root.right = deleteNode(root.right, minNode.val); &#125; else if (root.val &gt; key) &#123; root.left = deleteNode(root.left, key); &#125; else if (root.val &lt; key) &#123; root.right = deleteNode(root.right, key); &#125; return root; &#125;TreeNode getMin(TreeNode node) &#123; // BST 最左边的就是最⼩的 while (node.left != null) node = node.left; return node; &#125; 删除操作就完成了。注意⼀下，这个删除操作并不完美，因为我们⼀般不会 通过 root.val = minNode.val 修改节点内部的值来交换节点，⽽是通过⼀系列 略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应⽤中，val 域可能会很⼤，修改起来很耗时，⽽链表操作⽆⾮改⼀改指针，⽽不会去碰 内部数据。 但这⾥忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层 细化问题的思维⽅式。 总结通过这篇⽂章，你学会了如下⼏个技巧： 1、⼆叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归 框架，不⽤当前节点操⼼。 2、如果当前节点会对下⾯的⼦节点有整体影响，可以通过辅助函数增⻓参 数列表，借助参数传递信息。 3、在⼆叉树框架之上，扩展出⼀套 BST 遍历框架： 12345678void BST(TreeNode root, int target) &#123; if (root.val == target) ; // 找到⽬标，做点什么 if (root.val &lt; target) BST(root.right, target); if (root.val &gt; target) BST(root.left, target); &#125; 4、掌握了 BST 的基本操作。 快速计算完全⼆叉树的节点如果让你数⼀下⼀棵普通⼆叉树有多少个节点，这很简单，只要在⼆叉树的 遍历框架上加⼀点代码就⾏了。 但是，如果给你⼀棵完全⼆叉树，让你计算它的节点个数，你会不会？算法 的时间复杂度是多少？这个算法的时间复杂度应该是 O(logN*logN)，如果 你⼼中的算法没有达到⾼效，那么本⽂就是给你写的。 ⾸先要明确⼀下两个关于⼆叉树的名词「完全⼆叉树」和「满⼆叉树」。 我们说的完全⼆叉树如下图，每⼀层都是紧凑靠左排列的： 我们说的满⼆叉树如下图，是⼀种特殊的完全⼆叉树，每层都是是满的，像 ⼀个稳定的三⾓形： 具体方法如果是一个普通二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)： 1234public int countNodes(TreeNode root) &#123; if (root == null) return 0; return 1 + countNodes(root.left) + countNodes(root.right);&#125; 那如果是一棵满二叉树，节点总数就和树的高度呈指数关系，时间复杂度 O(logN)： 12345678910public int countNodes(TreeNode root) &#123; int h = 0; // 计算树的高度 while (root != null) &#123; root = root.left; h++; &#125; // 节点总数就是 2^h - 1 return (int)Math.pow(2, h) - 1;&#125; 完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码： 12345678910111213141516171819public int countNodes(TreeNode root) &#123; TreeNode l = root, r = root; // 记录左、右子树的高度 int hl = 0, hr = 0; while (l != null) &#123; l = l.left; hl++; &#125; while (r != null) &#123; r = r.right; hr++; &#125; // 如果左右子树的高度相同，则是一棵满二叉树 if (hl == hr) &#123; return (int)Math.pow(2, hl) - 1; &#125; // 如果左右高度不同，则按照普通二叉树的逻辑计算 return 1 + countNodes(root.left) + countNodes(root.right);&#125; 结合刚才针对满二叉树和普通二叉树的算法，上面这段代码应该不难理解，就是一个结合版，但是其中降低时间复杂度的技巧是非常微妙的。 复杂度分析开头说了，这个算法的时间复杂度是 O(logNlogN)，这是怎么算出来的呢？直觉感觉好像最坏情况下是 O(NlogN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归： 1return 1 + countNodes(root.left) + countNodes(root.right); 关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发hl == hr而立即返回，不会递归下去。 为什么呢？原因如下： 一棵完全二叉树的两棵子树，至少有一棵是满二叉树： 看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发hl == hr，只消耗 O(logN) 的复杂度而不会继续递归。 综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。 如何使用单调栈解题单调栈实际上就是栈，只是利⽤了⼀些巧妙的逻辑，使得每次新元素⼊栈 后，栈内的元素都保持有序（单调递增或单调递减）。听起来有点像堆（heap）？不是的，单调栈⽤途不太⼴泛，只处理⼀种典型 的问题，叫做 Next Greater Element。本⽂⽤讲解单调队列的算法模版解决 这类问题，并且探讨处理「循环数组」的策略。 题目⾸先，讲解 Next Greater Number 的原始问题：给你⼀个数组，返回⼀个等 ⻓的数组，对应索引存储着下⼀个更⼤元素，如果没有更⼤的元素，就存 -1。不好⽤语⾔解释清楚，直接上⼀个例⼦： 给你⼀个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。 解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯ ⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4 ⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。这道题的暴⼒解法很好想到，就是对每个元素后⾯都进⾏扫描，找到第⼀个 更⼤的元素就⾏了。但是暴⼒解法的时间复杂度是 O(n^2)。 解法这个问题可以这样抽象思考：把数组的元素想象成并列站⽴的⼈，元素⼤⼩ 想象成⼈的⾝⾼。这些⼈⾯对你站成⼀列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后⾯可⻅的第⼀个 ⼈就是「2」的 Next Greater Number，因为⽐「2」⼩的元素⾝⾼不够，都被「2」挡住了，第⼀个露出来的就是答案。 这个情景很好理解吧？带着这个抽象的情景，先来看下代码 12345678910111213141516vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ans(nums.size()); // 存放答案的数组 stack&lt;int&gt; s; for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; // 倒着往栈⾥放 while (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; // 判定个⼦⾼矮 s.pop(); // 矮个起开，反正也被挡着了。。。 &#125; ans[i] = s.empty() ? -1 : s.top(); // 这个元素⾝后的第⼀个⾼个 s.push(nums[i]); // 进队，接受之后的⾝⾼判定吧！ &#125; return ans; &#125; 这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们 借助的是栈的结构，倒着⼊栈，其实是正着出栈。while 循环是把两个“⾼ 个”元素之间的元素排除，因为他们的存在没有意义，前⾯挡着个“更⾼”的 元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。 这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循 环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂 度只有 O(n) 时间复杂度分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push ⼊栈了⼀次，⽽最多会被 pop ⼀次，没有任何冗余操作。所以总的计 算规模是和元素规模 n 成正⽐的，也就是 O(n) 的复杂度。 给你⼀个数组 T = [73, 74, 75, 71, 69, 72, 76, 73]，这个数组存放的是近⼏天 的天⽓⽓温（这⽓温是铁板烧？不是的，这⾥⽤的华⽒度）。你返回⼀个数 组，计算：对于每⼀天，你还要⾄少等多少天才能等到⼀个更暖和的⽓温； 如果等不到那⼀天，填 0 。 举例：给你 T = [73, 74, 75, 71, 69, 72, 76, 73]，你返回 [1, 1, 4, 2, 1, 1, 0, 0]。 解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天， 只要等⼀天就能等到⼀个更暖和的⽓温。后⾯的同理。 你已经对 Next Greater Number 类型问题有些敏感了，这个问题本质上也是 找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多 少，⽽是问你当前距离 Next Greater Number 的距离⽽已。 相同类型的问题，相同的思路，直接调⽤单调栈的算法模板，稍作改动就可 以啦，直接上代码把 1234567891011121314vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; vector&lt;int&gt; ans(T.size()); stack&lt;int&gt; s; // 这⾥放元素索引，⽽不是元素 for (int i = T.size() - 1; i &gt;= 0; i--) &#123; while (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123; s.pop(); &#125; ans[i] = s.empty() ? 0 : (s.top() - i); // 得到索引间距 s.push(i); // 加⼊索引，⽽不是元素 &#125; return ans; &#125; 扩展问题：循环数组单调栈讲解完毕。下⾯开始另⼀个重点：如何处理「循环数组」。 同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？ 给你⼀个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后 ⼀个元素 3 绕了⼀圈后找到了⽐⾃⼰⼤的元素 4 。 ⾸先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可 以模拟出环形数组的效果，⼀般是通过 % 运算符求模（余数），获得环形特效 123456int[] arr = &#123;1,2,3,4,5&#125;; int n = arr.length, index = 0; while (true) &#123; print(arr[index % n]); index++; &#125; 回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于： 这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左 边（如上例）。 明确问题，问题就已经解决了⼀半了。我们可以考虑这样的思路：将原始数 组“翻倍”，就是在后⾯再接⼀个原始数组，这样的话，按照之前“⽐⾝⾼”的 流程，每个元素不仅可以⽐较⾃⼰右边的元素，⽽且也可以和左边的元素⽐ 较了 怎么实现呢？你当然可以把这个双倍⻓度的数组构造出来，然后套⽤算法模 板。但是，我们可以不⽤构造新数组，⽽是利⽤循环数组的技巧来模拟。直 接看代码吧： 1234567891011121314vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; res(n); // 存放结果 stack&lt;int&gt; s; // 假装这个数组⻓度翻倍了 for (int i = 2 * n - 1; i &gt;= 0; i--) &#123; while (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) s.pop(); res[i % n] = s.empty() ? -1 : s.top(); s.push(nums[i % n]); &#125; return res; &#125; 利用单调队列解题前⽂讲了⼀种特殊的数据结构「单调栈」monotonic stack，解决了⼀类问题 「Next Greater Number」，本⽂写⼀个类似的数据结构「单调队列」。 也许这种数据结构的名字你没听过，其实没啥难的，就是⼀个「队列」，只 是使⽤了⼀点巧妙的⽅法，使得队列中的元素单调递增（或递减）。这个数 据结构有什么⽤？可以解决滑动窗⼝的⼀系列问题 题目给定一个数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧；你只可以看到在滑动窗口k内的数字，滑动窗口每次只向右移动一位，返回滑动窗口最大值。 二叉堆详解⼆叉堆（Binary Heap）没什么神秘，性质⽐⼆叉搜索树 BST 还简单。其主 要操作就两个， sink （下沉）和 swim （上浮），⽤以维护⼆叉堆的性 质。其主要应⽤有两个，⾸先是⼀种排序⽅法「堆排序」，第⼆是⼀种很有 ⽤的数据结构「优先级队列」。 本⽂就以实现优先级队列（Priority Queue）为例，通过图⽚和⼈类的语⾔来 描述⼀下⼆叉堆怎么运作的 概述⼆叉堆其实就是⼀种特殊的⼆叉树（完全⼆叉树），只不过存储在数 组⾥。⼀般的链表⼆叉树，我们操作节点的指针，⽽在数组⾥，我们把数组 索引作为指针： 123456789101112// ⽗节点的索引 int parent(int root) &#123; return root / 2; &#125;// 左孩⼦的索引 int left(int root) &#123; return root * 2; &#125;// 右孩⼦的索引 int right(int root) &#123; return root * 2 + 1; &#125; 画个图你⽴即就能理解了，注意数组的第⼀个索引 0 空着不⽤， PS：因为数组索引是数组，为了⽅便区分，将字符作为数组元素。 你看到了，把 arr[1] 作为整棵树的根的话，每个节点的⽗节点和左右孩⼦的 索引都可以通过简单的运算得到，这就是⼆叉堆设计的⼀个巧妙之处。为了 ⽅便讲解，下⾯都会画的图都是⼆叉树结构，相信你能把树和数组对应起 来 ⼆叉堆还分为最⼤堆和最⼩堆。最⼤堆的性质是：每个节点都⼤于等于它的 两个⼦节点。类似的，最⼩堆的性质是：每个节点都⼩于等于它的⼦节点。 两种堆核⼼思路都是⼀样的，本⽂以最⼤堆为例讲解。 对于⼀个最⼤堆，根据其性质，显然堆顶，也就是 arr[1] ⼀定是所有元素中 最⼤的元素。 优先级队列优先级队列这种数据结构有⼀个很有⽤的功能，你插⼊或者删除元素的时 候，元素会⾃动排序，这底层的原理就是⼆叉堆的操作。 数据结构的功能⽆⾮增删查该，优先级队列有两个主要 API，分别是 insert 插⼊⼀个元素和 delMax 删除最⼤元素（如果底层⽤最⼩堆，那么 就是 delMin ）。 下⾯我们实现⼀个简化的优先级队列，先看下代码框架： PS：为了清晰起⻅，这⾥⽤到 Java 的泛型， Key 可以是任何⼀种可⽐较⼤ ⼩的数据类型，你可以认为它是 int、char 等。 123456789101112131415161718192021222324252627282930313233343536373839public class MaxPQ &lt;Key extends Comparable&lt;Key&gt;&gt; &#123; // 存储元素的数组 private Key[] pq; // 当前 Priority Queue 中的元素个数 private int N = 0; public MaxPQ(int cap) &#123; // 索引 0 不⽤，所以多分配⼀个空间 pq = (Key[]) new Comparable[cap + 1]; &#125; /* 返回当前队列中最⼤元素 */ public Key max() &#123; return pq[1]; &#125; /* 插⼊元素 e */ public void insert(Key e) &#123;...&#125; /* 删除并返回当前队列中最⼤元素 */ public Key delMax() &#123;...&#125; /* 上浮第 k 个元素，以维护最⼤堆性质 */ private void swim(int k) &#123;...&#125; /* 下沉第 k 个元素，以维护最⼤堆性质 */ private void sink(int k) &#123;...&#125; /* 交换数组的两个元素 */ private void exch(int i, int j) &#123; Key temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; &#125; /* pq[i] 是否⽐ pq[j] ⼩？ */ private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; /* 还有 left, right, parent 三个⽅法 */ &#125; 空出来的四个⽅法是⼆叉堆和优先级队列的奥妙所在，下⾯⽤图⽂来逐个理解 swim和sink为什么要有上浮 swim 和下沉 sink 的操作呢？为了维护堆结构。 我们要讲的是最⼤堆，每个节点都⽐它的两个⼦节点⼤，但是在插⼊元素和 删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。 对于最⼤堆，会破坏堆性质的有有两种情况： 1、 如果某个节点 A ⽐它的⼦节点（中的⼀个）⼩，那么 A 就不配做⽗节点，应该下去，下⾯那个更⼤的节点上来做⽗节点，这就是对 A 进⾏ 下沉。 2、 如果某个节点 A ⽐它的⽗节点⼤，那么 A 不应该做⼦节点，应该把⽗ 节点换下来，⾃⼰去做⽗节点，这就是对 A 的上浮。 当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位 置，恢复堆的性质。所以代码中肯定有⼀个 while 循环。 细⼼的读者也许会问，这两个操作不是互逆吗，所以上浮的操作⼀定能⽤下 沉来完成，为什么我还要费劲写两个⽅法？ 是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进⾏（等 会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要 下沉 上浮的代码实现： 123456789private void swim(int k) &#123; // 如果浮到堆顶，就不能再上浮了 while (k &gt; 1 &amp;&amp; less(parent(k), k)) &#123; // 如果第 k 个元素⽐上层⼤ // 将 k 换上去 exch(parent(k), k); k = parent(k); &#125; &#125; 下沉的代码实现： 123456789101112131415private void sink(int k) &#123; // 如果沉到堆底，就沉不下去了 while (left(k) &lt;= N) &#123; // 先假设左边节点较⼤ int older = left(k); // 如果右边节点存在，⽐⼀下⼤⼩ if (right(k) &lt;= N &amp;&amp; less(older, right(k))) older = right(k); // 结点 k ⽐俩孩⼦都⼤，就不必下沉了 if (less(older, k)) break; // 否则，不符合最⼤堆的结构，下沉 k 结点 exch(k, older); k = older; &#125; &#125; ⾄此，⼆叉堆的主要操作就讲完了，⼀点都不难吧，代码加起来也就⼗⾏。 明⽩了 sink 和 swim 的⾏为，下⾯就可以实现优先级队列了 实现 delMax 和 insert这两个⽅法就是建⽴在 swim 和 sink 上的。 insert ⽅法先把要插⼊的元素添加到堆底的最后，然后让其上浮到正确位 置。 1234567public void insert(Key e) &#123; N++; // 先把新元素加到最后 pq[N] = e; // 然后让它上浮到正确的位置 swim(N); &#125; delMax ⽅法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A**，最** 后让 B 下沉到正确位置。 1234567891011public Key delMax() &#123; // 最⼤堆的堆顶就是最⼤元素 Key max = pq[1]; // 把这个最⼤元素换到最后，删除之 exch(1, N); pq[N] = null; N--; // 让 pq[1] 下沉到正确位置 sink(1); return max; &#125; ⾄此，⼀个优先级队列就实现了，插⼊和删除元素的时间复杂度为 O(logK) ， K 为当前⼆叉堆（优先级队列）中的元素总数。因为我们时间 复杂度主要花费在 sink 或者 swim 上，⽽不管上浮还是下沉，最多也就 树（堆）的⾼度，也就是 log 级别 总结⼆叉堆就是⼀种完全⼆叉树，所以适合存储在数组中，⽽且⼆叉堆拥有⼀些 特殊性质。 ⼆叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序）， 核⼼代码也就⼗⾏。 优先级队列是基于⼆叉堆实现的，主要操作是插⼊和删除。插⼊是先插到最 后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位 置。核⼼代码也就⼗⾏。 也许这就是数据结构的威⼒，简单的操作就能实现巧妙的功能，真⼼佩服发明⼆叉堆算法的⼈！","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"双指针查找与常用算法框架","slug":"算法/双指针查找","date":"2020-09-29T09:30:23.000Z","updated":"2021-01-14T16:22:36.188Z","comments":true,"path":"2020/09/29/算法/双指针查找/","link":"","permalink":"http://yoursite.com/2020/09/29/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E6%9F%A5%E6%89%BE/","excerpt":"","text":"双指针技巧详解主要分为两类：1、快慢指针；2、左右指针；前者主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或字符串）中的问题，比如：二分查找。 链表、子串、数组的题目，一般都需要用到双指针技巧。 链表指针数组题，用双指针别犹豫。 双指针家三兄弟，各个都是万人迷。 快慢指针最神奇，链表操作无压力。 归并排序找中点，链表成环搞判定。 左右指针最常见，左右两端相向行。 反转数组要靠它，二分搜索是弟弟。 滑动窗口老猛男，子串问题全靠它。 左右指针滑窗口，一前一后齐头进。 快慢指针的用法快慢指针一般都初始化指向链表的头节点head，前进时快指针fast在前，慢指针slow在后，从而巧妙解决链表中问题。 判定链表中是否有环单链表的特点是每个节点只知道下⼀个节点，所以⼀个指针的话⽆法判断链 表中是否含有环的。 如果链表中不含环，那么这个指针最终会遇到空指针 null 表⽰链表到头 了，这还好说，可以判断该链表不含环。但是如果链表中含有环，那么这个指针就会陷⼊死循环，因为环形数组中没 有 null 指针作为尾部节点。 经典解法就是⽤两个指针，⼀个跑得快，⼀个跑得慢。如果不含有环，跑得 快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终 会超慢指针⼀圈，和慢指针相遇，说明链表含有环。 12345678910boolean hasCycle(ListNode head) &#123; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) return true; &#125; return false; &#125; 已知链表中有环，返回其起始位置可以看到，当快慢指针相遇时，让其中任⼀个指针指向头节点，然后让它俩 以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。 第⼀次相遇时，假设慢指针 slow ⾛了 k 步，那么快指针 fast ⼀定⾛了 2k 步，也就是说⽐ slow 多⾛了 k 步（也就是环的⻓度）。设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。 巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。 所以，只要我们把快慢指针中的任⼀个重新指向 head，然后两个指针同速 前进，k - m 步后就会相遇，相遇之处就是环的起点了 12345678910111213141516ListNode detectCycle(ListNode head) &#123; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) break; &#125;// 上⾯的代码类似 hasCycle 函数 slow = head; while (slow != fast) &#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125; 寻找链表的中点类似上⾯的思路，我们还可以让快指针⼀次前进两步，慢指针⼀次前进⼀ 步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的⻓度是奇数时，slow 恰巧停在中点位置；如果⻓度是偶数，slow 最终的位置是中间偏右。 寻找链表中点的⼀个重要作⽤是对链表进⾏归并排序。 回想数组的归并排序：求中点索引递归地把数组⼆分，最后合并两个有序数 组。对于链表，合并两个有序链表是很简单的，难点就在于⼆分。 但是现在你学会了找到链表的中点，就能实现链表的⼆分了。 12345while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125;// slow 就在中间位置 return slow; 寻找链表的倒数第k个元素我们的思路还是使⽤快慢指针，让快指针先⾛ k 步，然后快慢指针开始同速 前进。这样当快指针⾛到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点。 12345678ListNode slow, fast; slow = fast = head; while (k-- &gt; 0) fast = fast.next; while (fast != null) &#123; slow = slow.next; fast = fast.next; &#125;return slow; 左右指针的常见用法左右指针在数组中实际是指两个索引值，⼀般初始化为 left = 0, right = nums.length - 1 。 二分查找1234567891011121314int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1; &#125; 二数之和给定一个已经按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回两个下标值index1和index2。 只要数组有序就应该想到双指针用法，解法类似于二分查找，通过调节left和right来调整sum的大小。 1234567891011121314151617int[] twoSum(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; // 题⽬要求的索引是从 1 开始的 return new int[]&#123;left + 1, right + 1&#125;; &#125; else if (sum &lt; target) &#123; left++; // 让 sum ⼤⼀点 &#125; else if (sum &gt; target) &#123; right--; // 让 sum ⼩⼀点 &#125; &#125; return new int[]&#123;-1, -1&#125;; &#125; 反转数组123456789101112void reverse(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; // swap(nums[left], nums[right]) int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125; &#125; 滑动窗口算法滑动窗口是双指针技巧的最高境界，可以解决一大类子字符串匹配的问题，比如：最小覆盖子串、字符串的排列、找到字符串中所有字母异位词、无重复字符的最长子串。其实算法的技巧思路特别简单，即维护一个窗口，不断滑动并更新答案。 123456789101112int left = 0, right = 0;while (right &lt; s.size()) &#123; // 增⼤窗⼝ window.add(s[right]); right++; while (window needs shrink) &#123; // 缩⼩窗⼝ window.remove(s[left]); left++; &#125; &#125; 这个算法技巧的时间复杂度是 O(N)，⽐字符串暴⼒算法要⾼效得多。 其实困扰⼤家的，不是算法的思路，⽽是各种细节问题。⽐如说如何向窗⼝ 中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果。即便你明 ⽩了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让⼈⼼烦 的。 所以今天我就写⼀套滑动窗⼝算法的代码框架，我连再哪⾥做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地 ⽅就⾏，还不会出 bug： 123456789101112131415161718192021222324252627282930/* 滑动窗口算法框架 */void slidingWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right &lt; s.size()) &#123; // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(&quot;window: [%d, %d)\\n&quot;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) &#123; // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 ... &#125; &#125;&#125; 而且，这两个...处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解： unordered_map就是哈希表（字典），它的一个方法count(key)相当于 Java 的containsKey(key)可以判断键 key 是否存在。可以使用方括号访问键对应的值map[key]。需要注意的是，如果该key不存在，C++ 会自动创建这个 key，并把map[key]赋值为 0。所以代码中多次出现的map[key]++相当于 Java 的map.put(key, map.getOrDefault(key, 0) + 1)。 最小覆盖子串题目：给你一个字符串S、字符串T，请在字符串S中找出：包含T所有字母的最小子串。 就是说要在S(source) 中找到包含T(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。 如果我们使用暴力解法，代码大概是这样的： 1234for (int i = 0; i &lt; s.size(); i++) for (int j = i + 1; j &lt; s.size(); j++) if s[i:j] 包含 t 的所有字母: 更新答案 而滑动窗口的思路是这样的： 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。 2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。 3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。 4、重复第 2 和第 3 步，直到right到达字符串S的尽头 这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。下面画图理解一下，needs和window相当于计数器，分别记录T中字符出现次数和「窗口」中的相应字符的出现次数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//首先，初始化window和need两个哈希表，记录窗口中的字符和需要凑齐的字符：unordered_map&lt;char, int&gt; need, window;for (char c : t) need[c]++;//为每个键值赋值//然后，使用left和right变量初始化窗口的两端，不要忘了，区间[left, right)是左闭右开的，所以初始情况下窗口没有包含任何元素：int left = 0, right = 0;int valid = 0; while (right &lt; s.size()) &#123; // 开始滑动&#125;//其中valid变量表示窗口中满足need条件的字符个数，如果valid和need.size的大小相同，则说明窗口已满足条件，已经完全覆盖了串T。//现在开始套模板，只需要思考以下四个问题：//1、当移动right扩大窗口，即加入字符时，应该更新哪些数据？//2、什么条件下，窗口应该暂停扩大，开始移动left缩小窗口？//3、当移动left缩小窗口，即移出字符时，应该更新哪些数据？//4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？//如果一个字符进入窗口，应该增加window计数器；如果一个字符将移出窗口的时候，应该减少window计数器；当valid满足need时应该收缩窗口；应该在收缩窗口的时候更新最终结果。string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引及长度 int start = 0, len = INT_MAX; while (right &lt; s.size()) &#123; // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; // 判断左侧窗口是否要收缩 while (valid == need.size()) &#123; // 在这里更新最小覆盖子串 if (right - left &lt; len) &#123; start = left; len = right - left; &#125; // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; // 返回最小覆盖子串 return len == INT_MAX ? &quot;&quot; : s.substr(start, len);&#125; 需要注意的是，当我们发现某个字符在window的数量满足了need的需要，就要更新valid，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。 当valid == need.size()时，说明T中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。移动left收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。 至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿。 字符串排列题目：给定两个字符串S1、S2，写一个函数来判断S2是否包含S1的序列；即第一个字符串的排列之一是第二个字符串的子串 这种题目，是明显的滑动窗口算法，相当给你一个S和一个T，请问你S中是否存在一个子串，包含T中所有字符且不包含其他字符？首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案： 1234567891011121314151617181920212223242526272829303132333435// 判断 s 中是否存在 t 的排列bool checkInclusion(string t, string s) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right &lt; s.size()) &#123; char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; // 判断左侧窗口是否要收缩 while (right - left &gt;= t.size()) &#123; // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; // 未找到符合条件的子串 return false;&#125; 对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方： 1、本题移动left缩小窗口的时机是窗口大小大于t.size()时，因为排列嘛，显然长度应该是一样的。 2、当发现valid == need.size()时，就说明窗口中就是一个合法的排列，所以立即返回true。 至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。 找所有字母异位词给定一个字符串s和非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。（字母异位词指字母相同，但排列不同的字符串；不考虑答案输出的顺序） 呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？相当于，输入一个串S，一个串T，找到S中所有T的排列，返回它们的起始索引。直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题： 123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; findAnagrams(string s, string t) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector&lt;int&gt; res; // 记录结果 while (right &lt; s.size()) &#123; char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; // 判断左侧窗口是否要收缩 while (right - left &gt;= t.size()) &#123; // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; return res;&#125; 跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入res即可 最长无重复子串题目：给定一个字符串，找出其中不含有重复重复字符的的最长子串的长度。 这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了： 12345678910111213141516171819202122int lengthOfLongestSubstring(string s) &#123; unordered_map&lt;char, int&gt; window; int left = 0, right = 0; int res = 0; // 记录结果 while (right &lt; s.size()) &#123; char c = s[right]; right++; // 进行窗口内数据的一系列更新 window[c]++; // 判断左侧窗口是否要收缩 while (window[c] &gt; 1) &#123; char d = s[left]; left++; // 进行窗口内数据的一系列更新 window[d]--; &#125; // 在这里更新答案 res = max(res, right - left); &#125; return res;&#125; 这就是变简单了，连need和valid都不需要，而且更新窗口内数据也只需要简单的更新计数器window即可。 当window[c]值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动left缩小窗口了嘛。唯一需要注意的是，在哪里更新结果res呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？ 这里和之前不一样，**要在收缩窗口完成后更新res**，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。 twoSum问题的核心思想第一题这个问题的最基本形式是这样：给你⼀个数组和⼀个整数 target ，可以保 证数组中存在两个数的和为 target ，请你返回这两个数的索引。这个问题如何解决呢？⾸先最简单粗暴的办法当然是穷举了： 12345678int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) for (int j = i + 1; j &lt; nums.length; j++) if (nums[j] == target - nums[i]) return new int[] &#123; i, j &#125;; // 不存在这么两个数 return new int[] &#123;-1, -1&#125;; &#125; 这个解法⾮常直接，时间复杂度 O(N^2)，空间复杂度 O(1)。 可以通过⼀个哈希表减少时间复杂度： 123456789101112131415int[] twoSum(int[] nums, int target) &#123; int n = nums.length; index&lt;Integer, Integer&gt; index = new HashMap&lt;&gt;(); // 构造⼀个哈希表：元素映射到相应的索引 for (int i = 0; i &lt; n; i++) index.put(nums[i], i); for (int i = 0; i &lt; n; i++) &#123; int other = target - nums[i]; // 如果 other 存在且不是 nums[i] 本⾝ if (index.containsKey(other) &amp;&amp; index.get(other) != i) return new int[] &#123;i, index.get(other)&#125;; &#125; return new int[] &#123;-1, -1&#125;;&#125; 这样，由于哈希表的查询时间为 O(1)，算法的时间复杂度降低到 O(N)，但 是需要 O(N) 的空间复杂度来存储哈希表。不过综合来看，是要⽐暴⼒解法 ⾼效的。 我觉得 Two Sum 系列问题就是想教我们如何使⽤哈希表处理问题。我们接 着往后看。 第二题这⾥我们稍微修改⼀下上⾯的问题。我们设计⼀个类，拥有两个 API： 123456class TwoSum &#123; // 向数据结构中添加⼀个数 number public void add(int number); // 寻找当前数据结构中是否存在两个数的和为 value public boolean find(int value); &#125; 如何实现这两个 API 呢，我们可以仿照上⼀道题⽬，使⽤⼀个哈希表辅助 find ⽅法： 1234567891011121314151617181920class TwoSum &#123; Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;(); public void add(int number) &#123; // 记录 number 出现的次数 freq.put(number, freq.getOrDefault(number, 0) + 1); &#125; public boolean find(int value) &#123; for (Integer key : freq.keySet()) &#123; int other = value - key; // 情况⼀ if (other == key &amp;&amp; freq.get(key) &gt; 1) return true; // 情况⼆ if (other != key &amp;&amp; freq.containsKey(other)) return true; &#125; return false; &#125; &#125; 进⾏ find 的时候有两种情况，举个例⼦： 情况⼀： add 了 [3,3,2,5] 之后，执⾏ find(6) ，由于 3 出现了两次，3 + 3 = 6，所以返回 true。 情况⼆： add 了 [3,3,2,5] 之后，执⾏ find(7) ，那么 key 为 2， other 为 5 时算法可以返回 true。 除了上述两种情况外， find 只能返回 false 了。 对于这个解法的时间复杂度呢， add ⽅法是 O(1)， find ⽅法是 O(N)，空 间复杂度为 O(N)，和上⼀道题⽬⽐较类似。但是对于 API 的设计，是需要考虑现实情况的。⽐如说，我们设计的这个 类，使⽤ find ⽅法⾮常频繁，那么每次都要 O(N) 的时间，岂不是很浪费 费时间吗？对于这种情况，我们是否可以做些优化呢？ 是的，对于频繁使⽤ find ⽅法的场景，我们可以进⾏优化。我们可以参 考上⼀道题⽬的暴⼒解法，借助哈希集合来针对性优化 find ⽅法： 1234567891011121314class TwoSum &#123; Set&lt;Integer&gt; sum = new HashSet&lt;&gt;(); List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); public void add(int number) &#123; // 记录所有可能组成的和 for (int n : nums) sum.add(n + number); nums.add(number); &#125; public boolean find(int value) &#123; return sum.contains(value); &#125; &#125; 这样 sum 中就储存了所有加⼊数字可能组成的和，每次 find 只要花费 O(1) 的时间在集合中判断⼀下是否存在就⾏了，显然⾮常适合频繁使⽤ find 的场景。 对于 TwoSum 问题，⼀个难点就是给的数组⽆序。对于⼀个⽆序的数组， 我们似乎什么技巧也没有，只能暴⼒穷举所有可能。 ⼀般情况下，我们会⾸先把数组排序再考虑双指针技巧。TwoSum 启发我 们，HashMap 或者 HashSet 也可以帮助我们处理⽆序数组相关的简单问题。 另外，设计的核⼼在于权衡，利⽤不同的数据结构，可以得到⼀些针对性的 加强。 最后，如果 TwoSum I 中给的数组是有序的，应该如何编写算法呢？答案很 简单，前⽂「双指针技巧汇总」写过： 123456789101112131415int[] twoSum(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; return new int[]&#123;left, right&#125;; &#125; else if (sum &lt; target) &#123; left++; // 让 sum ⼤⼀点 &#125; else if (sum &gt; target) &#123; right--; // 让 sum ⼩⼀点 &#125; &#125; // 不存在这样两个数 return new int[]&#123;-1, -1&#125;; &#125; 二分查找详解⼆分查找并不简单，Knuth ⼤佬（发明 KMP 算法的那位）都说⼆分查找： 思路很简单，细节是魔⿁。很多⼈喜欢拿整型溢出的 bug 说事⼉，但是⼆分 查找真正的坑根本就不是那个细节问题，⽽是在于到底要给 mid 加⼀还是 减⼀，while ⾥到底⽤ &lt;= 还是 &lt; 。 二分搜索诗管他左侧还右侧，搜索区间定乾坤。 搜索一个元素时，搜索区间两端闭。 while条件带等号，否则需要打补丁。 if相等就返回，其他的事甭操心。 mid必须加减一，因为区间两端闭。 while结束就凉凉，凄凄惨惨返-1。 搜索左右边界时，搜索区间要阐明。 左闭右开最常见，其余逻辑便自明。 while要用小于号，这样才能不漏掉。 if相等别返回，利用mid锁边界。 mid加一或减一？要看区间区间开或闭。 while结束不算完，因为你还没返回。 索引可能出边界，if检查保平安。 二分查找框架1234567891011121314int binarySearch(int[] nums, int target) &#123; int left = 0, right = ...; while(...) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; ... &#125; else if (nums[mid] &lt; target) &#123; left = ... &#125; else if (nums[mid] &gt; target) &#123; right = ... &#125; &#125; return ...; &#125; 分析⼆分查找的⼀个技巧是：不要出现 else**，⽽是把所有情况⽤** else if 写清 楚，这样可以清楚地展现所有细节。本⽂都会使⽤ else if，旨在讲清楚。 其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分 查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样 的变化。 另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防⽌了 left 和right 太⼤直接相加导致溢出 寻找一个数：基本二分查找这个场景是最简单的，肯能也是⼤家最熟悉的，即搜索⼀个数，如果存在， 返回其索引，否则返回 -1。 1234567891011121314int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; // 注意 while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意 else if (nums[mid] &gt; target) right = mid - 1; // 注意 &#125; return -1; &#125; 1**、为什么** while 循环的条件中是 &lt;=**，⽽不是** **&lt;**？ 答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索 引，⽽不是 nums.length 。 这⼆者可能出现在不同功能的⼆分查找中，区别是：前者相当于两端都闭区 间 [left, right] ，后者相当于左闭右开区间 [left, right) ，因为索引⼤⼩为 nums.length 是越界的。 我们这个算法中使⽤的是前者 [left, right] 两端都闭的区间。这个区间 其实就是每次进⾏搜索的区间。 2、什么时候应该停⽌搜索呢？ 当然，找到了⽬标值的时候可以终⽌： if(nums[mid] == target) return mid; 但如果没找到，就需要 while 循环终⽌，然后返回 -1。那 while 循环什么时 候应该终⽌？搜索区间为空的时候应该终⽌，意味着你没得找了，就等于没 找到嘛。 while(left &lt;= right) 的终⽌条件是 left == right + 1 ，写成区间的形式 就是 [right + 1, right] ，或者带个具体的数字进去 [3, 2] ，可⻅这时候 区间为空， while(left &lt; right) 的终⽌条件是 left == right ，写成区间的形式就是 [left, right] ，或者带个具体的数字进去 [2, 2] ，这时候区间⾮空，还 有⼀个数 2，但此时 while 循环终⽌了。也就是说这区间 [2, 2] 被漏掉 了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。 3**、为什么** left = mid + 1 ， right = mid - 1 ？我看有的代码是 right = mid 或者 left = mid ，没有这些加加减减，到底怎么回事，怎么判断？ 答：这也是⼆分查找的⼀个难点，不过只要你能理解前⾯的内容，就能够很 容易判断。 刚才明确了「搜索区间」这个概念，⽽且本算法的搜索区间是两端都闭的， 即 [left, right] 。那么当我们发现索引 mid 不是要找的 target 时，下 ⼀步应该去搜索哪⾥呢？ 当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已 经搜索过，应该从搜索区间中去除。 4**、此算法有什么缺陷**？ 答：⾄此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但 是，这个算法存在局限性。 ⽐如说给你有序数组 nums = [1,2,2,2,3] ， target 为 2，此算法返回的索 引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我 想得到 target 的右侧边界，即索引 3，这样的话此算法是⽆法处理的。 寻找左侧边界的⼆分搜索12345678910111213141516int left_bound(int[] nums, int target) &#123; if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left &lt; right) &#123; // 注意 int mid = (left + right) / 2; if (nums[mid] == target) &#123; right = mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid; // 注意 &#125; &#125; return left; &#125; 1**、为什么** while 中是 &lt; ⽽不是 &lt;= ? 答：⽤相同的⽅法分析，因为 right = nums.length ⽽不是 nums.length - 1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。 while(left &lt; right) 终⽌的条件是 left == right ，此时搜索区间 [left, left) 为空，所以可以正确终⽌。 寻找右侧边界的⼆分查找123456789101112131415int right_bound(int[] nums, int target) &#123; if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; left = mid + 1; // 注意 &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid; &#125; &#125;return left - 1; // 注意 &#125; 字符串乘法对于⽐较⼩的数字，做运算可以直接使⽤编程语⾔提供的运算符，但是如果 相乘的两个因数⾮常⼤，语⾔提供的数据类型可能就会溢出。⼀种替代⽅案 就是，运算数以字符串的形式输⼊，然后模仿我们⼩学学习的乘法算术过程 计算出结果，并且也⽤字符串表⽰。 题目给定两个以字符串形式表示的非负整数num1、num2，返回num1和num2的乘积，它们的乘积也表示为字符串的形式。 需要注意的是， num1 和 num2 可以⾮常⻓，所以不可以把他们直接转成 整型然后运算，唯⼀的思路就是模仿我们⼿算乘法。 思路计算 123 × 5 ，再计算 123 × 4 ，最后错⼀位相加。这个流程恐怕⼩学⽣ 都可以熟练完成，但是你是否能把这个运算过程进⼀步机械化，写成⼀套算 法指令让没有任何智商的计算机来执⾏呢？ 你看这个简单过程，其中涉及乘法进位，涉及错位相加，还涉及加法进位； ⽽且还有⼀些不易察觉的问题，⽐如说两位数乘以两位数，结果可能是四位 数，也可能是三位数，你怎么想出⼀个标准化的处理⽅式？这就是算法的魅 ⼒，如果没有计算机思维，简单的问题可能都没办法⾃动化处理。 ⾸先，我们这种⼿算⽅式还是太「⾼级」了，我们要再「低级」⼀点， 123 × 5 和 123 × 4 的过程还可以进⼀步分解，最后再相加： 现在 123 并不⼤，如果是个很⼤的数字的话，是⽆法直接计算乘积的。我 们可以⽤⼀个数组在底下接收相加结果： 整个计算过程⼤概是这样，有两个指针 *i**，j 在 num1 和 num2 上游⾛， 计算乘积，同时将乘积叠加到 res 的正确位置： 现在还有⼀个关键问题，如何将乘积叠加到 res 的正确位置，或者说，如 何通过 i，j 计算 res 的对应索引呢？ 其实，细⼼观察之后就发现， num1[i] 和 num2[j] 的乘积对应的就是 res[i+j] 和 res[i+j+1] 这两个位置。 明⽩了这⼀点，就可以⽤代码模仿出这个计算过程了： 12345678910111213141516171819202122232425string multiply(string num1, string num2) &#123; int m = num1.size(), n = num2.size(); // 结果最多为 m + n 位数 vector&lt;int&gt; res(m + n, 0); // 从个位数开始逐位相乘 for (int i = m - 1; i &gt;= 0; i--) for (int j = n - 1; j &gt;= 0; j--) &#123; int mul = (num1[i]-&#x27;0&#x27;) * (num2[j]-&#x27;0&#x27;); // 乘积在 res 对应的索引位置 int p1 = i + j, p2 = i + j + 1; // 叠加到 res 上 int sum = mul + res[p2]; res[p2] = sum % 10; res[p1] += sum / 10; &#125; // 结果前缀可能存的 0（未使⽤的位） int i = 0; while (i &lt; res.size() &amp;&amp; res[i] == 0) i++; // 将计算结果转化成字符串 string str; for (; i &lt; res.size(); i++) str.push_back(&#x27;0&#x27; + res[i]); return str.size() == 0 ? &quot;0&quot; : str; &#125; 总结⼀下，我们习以为常的⼀些思维⽅式，在计算机看来是⾮常难以做到 的。⽐如说我们习惯的算术流程并不复杂，但是如果让你再进⼀步，翻译成 代码逻辑，并不简单。算法需要将计算流程再简化，通过边算边叠加的⽅式 来得到结果。 俗话教育我们，不要陷⼊思维定式，不要程序化，要发散思维，要创新。但 我觉得程序化并不是坏事，可以⼤幅提⾼效率，减⼩失误率。算法不就是⼀ 套程序化的思维吗，只有程序化才能让计算机帮助我们解决复杂问题呀！ 前缀和技巧题目：算出⼀共有⼏个和为 k 的⼦数组。给定一个整数数组和一个整数k，你需要找到该数组中和为k的连续的子数组的个数。 输入：nums = [1,1,1], k = 2；输出：2，[1,1]与[1,1]为两种不同的情况。 解法思路：那我把所有⼦数组都穷举出来，算它们的和，看看谁的和等于 k 不就⾏了。 关键是，如何快速得到某个⼦数组的和呢，⽐如说给你⼀个数组 nums ，让 你实现⼀个接⼝ sum(i, j) ，这个接⼝要返回 nums[i..j] 的和，⽽且会被 多次调⽤，你怎么实现这个接⼝呢？ 因为接⼝要被多次调⽤，显然不能每次都去遍历 nums[i..j] ，有没有⼀种 快速的⽅法在 O(1) 时间内算出 nums[i..j] 呢？这就需要前缀和技巧了。 什么是前缀和前缀和的思路是这样的，对于⼀个给定的数组 nums ，我们额外开辟⼀个前 缀和数组进⾏预处理： 12345int n = nums.length; // 前缀和数组int[] preSum = new int[n + 1]; preSum[0] = 0; for (int i = 0; i &lt; n; i++) preSum[i + 1] = preSum[i] + nums[i]; 这个前缀和数组 preSum 的含义也很好理解， preSum[i] 就是 nums[0..i- 1] 的和。那么如果我们想求 nums[i..j] 的和，只需要⼀步操作 preSum[j+1]-preSum[i] 即可，⽽不需要重新去遍历数组了。 回到这个⼦数组问题，我们想求有多少个⼦数组的和为 k，借助前缀和技巧 很容易写出⼀个解法： 123456789101112131415int subarraySum(int[] nums, int k) &#123; int n = nums.length; // 构造前缀和 int[] sum = new int[n + 1]; sum[0] = 0; for (int i = 0; i &lt; n; i++) sum[i + 1] = sum[i] + nums[i]; int ans = 0; // 穷举所有⼦数组 for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; i; j++) // sum of nums[j..i-1] if (sum[i] - sum[j] == k) ans++; return ans; &#125; 这个解法的时间复杂度 O(N^2) 空间复杂度 O(N) ，并不是最优的解法。不 过通过这个解法理解了前缀和数组的⼯作原理之后，可以使⽤⼀些巧妙的办 法把时间复杂度进⼀步降低 优化解法123456789101112131415161718192021222324252627282930//前⾯的解法有嵌套的 for 循环：for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; i; j++) if (sum[i] - sum[j] == k) ans++;//第⼆层 for 循环在⼲嘛呢？翻译⼀下就是，在计算，有⼏个 j 能够使得 sum[i] 和 sum[j] 的差为 k。毎找到⼀个这样的 j ，就把结果加⼀。 我们可以把 if 语句⾥的条件判断移项，这样写：if (sum[j] == sum[i] - k) ans++;//优化的思路是：我直接记录下有⼏个 sum[j] 和 sum[i] - k 相等，直接更 新结果，就避免了内层的 for 循环。//我们可以⽤哈希表，在记录前缀和的同 时记录该前缀和出现的次数。int subarraySum(int[] nums, int k) &#123; int n = nums.length; // map：前缀和 -&gt; 该前缀和出现的次数 HashMap&lt;Integer, Integer&gt;; preSum = new HashMap&lt;&gt;(); // base case preSum.put(0, 1); int ans = 0, sum0_i = 0; for (int i = 0; i &lt; n; i++) &#123; sum0_i += nums[i]; // 这是我们想找的前缀和 nums[0..j] int sum0_j = sum0_i - k; // 如果前⾯有这个前缀和，则直接更新答案 if (preSum.containsKey(sum0_j)) ans += preSum.get(sum0_j); // 把前缀和 nums[0..i] 加⼊并记录出现次数 preSum.put(sum0_i, preSum.getOrDefault(sum0_i, 0) + 1); &#125; return ans; &#125; 这样，就把时间复杂度降到了 O(N) ，是最优解法了。 总结前缀和不难，却很有⽤，主要⽤于处理数组区间的问题。 ⽐如说，让你统计班上同学考试成绩在不同分数段的百分⽐，也可以利⽤前 缀和技巧 12345678int[] scores; // 存储着所有同学的分数 // 试卷满分 150 分 int[] count = new int[150 + 1] // 记录每个分数有⼏个同学 for (int score : scores) count[score]++;// 构造前缀和 for (int i = 1; i &lt; count.length; i++) count[i] = count[i] + count[i-1]; 这样，给你任何⼀个分数段，你都能通过前缀和相减快速计算出这个分数段 \\的⼈数，百分⽐也就很容易计算了。 但是，稍微复杂⼀些的算法问题，不⽌考察简单的前缀和技巧。⽐如本⽂探 讨的这道题⽬，就需要借助前缀和的思路做进⼀步的优化，借助哈希表去除 不必要的嵌套循环。可⻅对题⽬的理解和细节的分析能⼒对于算法的优化是 ⾄关重要的。","categories":[],"tags":[]},{"title":"jQuery教程","slug":"前端/jQuery教程","date":"2020-09-23T14:53:01.000Z","updated":"2020-09-24T06:48:37.921Z","comments":true,"path":"2020/09/23/前端/jQuery教程/","link":"","permalink":"http://yoursite.com/2020/09/23/%E5%89%8D%E7%AB%AF/jQuery%E6%95%99%E7%A8%8B/","excerpt":"","text":"jQuery基础jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 提示： 除此之外，Jquery还提供了大量的插件。 jQuery语法jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(*selector*).*action*() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 元素 $(“p.test”).hide() - 隐藏所有 class=”test” 的 元素 $(“#test”).hide() - 隐藏 id=”test” 的元素 123456789101112//在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;);/*这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：试图隐藏一个不存在的元素获得未完全加载的图像的大小*/ jQuery选择器jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 123456789101112131415161718192021222324252627//jQuery 元素选择器基于元素名选取元素,在页面中选取所有 &lt;p&gt; 元素。//用户点击按钮后，所有 &lt;p&gt; 元素都隐藏。$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;p&quot;).hide(); &#125;);&#125;);//jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。//页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;#test&quot;).hide(); &#125;);&#125;);//jQuery 类选择器可以通过指定的 class 查找元素。$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;.test&quot;).hide(); &#125;);&#125;);//如果您的网站包含许多页面，并且您希望您的 jQuery 函数易于维护，那么请把您的 jQuery 函数放到独立的 .js 文件中。//当我们在教程中演示 jQuery 时，会将函数直接添加到 &lt;head&gt; 部分中。不过，把它们放到一个单独的文件中会更好，就像这样（通过 src 属性来引用文件）：&lt;head&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;my_jquery_functions.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; jQuery事件在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。页面中指定一个点击事件：下一步是定义什么时间触发事件，可以通过一个事件函数来实现； 常用的 jQuery 事件方法$(document).ready()$(document).ready() 方法允许我们在文档完全加载完后执行函数。该事件方法在 jQuery 语法 章节中已经提到过。 click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。 dblclick()当双击元素时，会发生 dblclick 事件。 dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数： mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseenter() 方法触发 mouseenter 事件，或规定当发生 mouseenter 事件时运行的函数： mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。 mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数： mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数 mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。 mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数： hover()hover()方法用于模拟光标悬停事件。 当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus()当元素获得焦点时，发生 focus 事件。 当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。 focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数 blur()当元素失去焦点时，发生 blur 事件。 blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数： jQuery效果隐藏与显示通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： 123456789101112$(selector).hide(speed,callback);$(selector).show(speed,callback);//可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。//可选的 callback 参数是隐藏或显示完成后所执行的函数名称。//通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。//显示被隐藏的元素，并隐藏已显示的元素：$(&quot;button&quot;).click(function()&#123; $(&quot;p&quot;).toggle();&#125;);$(selector).toggle(speed,callback);//可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 淡入淡出通过 jQuery，您可以实现元素的淡入淡出效果。jQuery 拥有下面四种 fade 方法： fadeIn() fadeOut() fadeToggle() fadeTo() 123456789101112131415161718192021222324252627282930//jQuery fadeIn() 用于淡入已隐藏的元素;$(selector).fadeIn(speed,callback);$(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeIn(); $(&quot;#div2&quot;).fadeIn(&quot;slow&quot;); $(&quot;#div3&quot;).fadeIn(3000);&#125;);//jQuery fadeOut() 方法用于淡出可见元素$(selector).fadeOut(speed,callback);$(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeOut(); $(&quot;#div2&quot;).fadeOut(&quot;slow&quot;); $(&quot;#div3&quot;).fadeOut(3000);&#125;);//jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。//如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。$(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeToggle(); $(&quot;#div2&quot;).fadeToggle(&quot;slow&quot;); $(&quot;#div3&quot;).fadeToggle(3000);&#125;);//jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。$(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeTo(&quot;slow&quot;,0.15); $(&quot;#div2&quot;).fadeTo(&quot;slow&quot;,0.4); $(&quot;#div3&quot;).fadeTo(&quot;slow&quot;,0.7);&#125;); 滑动效果通过 jQuery，您可以在元素上创建滑动效果。jQuery 拥有以下滑动方法： slideDown() slideUp() slideToggle() 1234//jQuery slideDown() 方法用于向下滑动元素。//jQuery slideUp() 方法用于向上滑动元素。//jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。//如果元素向下滑动，则 slideToggle() 可向上滑动它们。如果元素向上滑动，则 slideToggle() 可向下滑动它们。 jQuery动画jQuery animate() 方法用于创建自定义动画。 1234567891011121314151617181920212223242526272829303132333435$(selector).animate(&#123;params&#125;,speed,callback);/*必需的 params 参数定义形成动画的 CSS 属性。可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。可选的 callback 参数是动画完成后所执行的函数名称。下面的例子演示 animate() 方法的简单应用。它把 &lt;div&gt; 元素往右边移动了 250 像素：*/$(&quot;button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123;left:&#x27;250px&#x27;&#125;);&#125;);//默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!//同样生成动画的过程中可以同时使用多个属性$(&quot;button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; left:&#x27;250px&#x27;, opacity:&#x27;0.5&#x27;, height:&#x27;150px&#x27;, width:&#x27;150px&#x27; &#125;);&#125;);//：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。//也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=：//默认地，jQuery 提供针对动画的队列功能。//这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的&quot;内部&quot;队列。然后逐一运行这些 animate 调用。$(&quot;button&quot;).click(function()&#123; var div=$(&quot;div&quot;); div.animate(&#123;left:&#x27;100px&#x27;&#125;,&quot;slow&quot;); div.animate(&#123;fontSize:&#x27;3em&#x27;&#125;,&quot;slow&quot;);&#125;);// jQuery stop() 方法用于在动画或效果完成前对它们进行停止。stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画 $(selector).stop(stopAll,goToEnd)。 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。因此，默认地，stop() 会清除在被选元素上指定的当前动画。 Callback 函数在当前动画 100% 完成之后执行。 jQuery链通过 jQuery，可以把动作/方法链接在一起。Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上） 直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。 不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。提示： 这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，您只需简单地把该动作追加到之前的动作上。下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，再然后向下滑动： 1234567$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000);//如果需要，我们也可以添加多个方法调用。//提示：当进行链接时，代码行会变得很长。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。如下书写也可以很好地运行：$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;) .slideUp(2000) .slideDown(2000);//jQuery 会抛掉多余的空格，并当成一行长代码来执行上面的代码行。 什么是链式调用链式调用完方法后，return this返回当前调用方法的对象。普通的定义类方法，在多次调用一个对象的不同方法时有一个弊端，就是会多次重复使用一个对象变量，进行了多次查找，可以在原本的实现类中增添一行return this 从而能简单地实现链式调用。 12345678910111213141516171819202122232425//创建一个bird类 function Bird(name) &#123; this.name=name; this.run=function () &#123; document.write(name+&quot; &quot;+&quot;start run;&quot;); return this;// return this返回当前调用方法的对象。 &#125; this.stopRun=function () &#123; document.write(name+&quot; &quot;+&quot;start run;&quot;); return this; &#125; this.sing=function () &#123; document.write(name+&quot; &quot;+&quot;start sing;&quot;); return this; &#125; this.stopSing=function () &#123; document.write(name+&quot; &quot;+&quot;start stopSing;&quot;); return this; &#125; &#125;var bird=new Bird(&quot;测试&quot;); bird.run().sing().stopSing().stopRun();//结果为;测试 start run;测试 start sing;测试 start stopSing;测试 start run; jq的链式调用jq的链式调用其实就是比如我们在选择dom的时候， 123456789101112$(&#x27;input[type=&quot;button&quot;]&#x27;) .eq(0).click(function() &#123; alert(&#x27;点击我!&#x27;);&#125;).end().eq(1).click(function() &#123; $(&#x27;input[type=&quot;button&quot;]:eq(0)&#x27;).trigger(&#x27;click&#x27;);&#125;).end().eq(2).toggle(function() &#123; $(&#x27;.aa&#x27;).hide(&#x27;slow&#x27;);&#125;, function() &#123; $(&#x27;.aa&#x27;).show(&#x27;slow&#x27;);&#125;); 比如如上代码，先选择type类型为button的所有DOM，然后再选择第一个… 我们自然想到每次其实就是返回选择后的结果，在js里面有什么东西可以指代这个吗？如果你想到this就对了。 q的方法都是挂在原型的，那么如果我们每次在内部方法返回this，也就是返回实例对象，那么我们就可以继续调用原型上的方法了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。 但是也会出现一个问题：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。 模仿jQuery的链式调用1、定义一个含参数的空对象； 1234(function()&#123; //下划线：表示私有变量的写法 function _$(els) &#123; &#125;;//有参数的空函数对象&#125;)()//程序启动的时候 里面的代码直接执行了 2、准备方法：在_$上定义一个onrReady方法； 123456789101112131415(function()&#123; //第一步，下划线：表示私有变量的写法 function _$(els) &#123; &#125;;//有参数的空对象 //第二步，准备方法 在_$上定义一个onrReady方法 _$.onrReady=function (fn) &#123; //按要求把对象（_$）注册到window对象上 //对外开放的接口 window.$=function () &#123; return new _$(arguments); //传递相应的方法调用参数 返回一可以使用function类原型上的方法的对象（$(&quot;&quot;)=_$(参数)） &#125; fn(); &#125; &#125;&#125;)() 3、为了类能扩展函数，我们定义一个它的静态函数 1234Function.prototype.method=function (name,fn) &#123;//（函数名称，函数本身） this.prototype[name]=fn; return this;//链式调用关键&#125;;//这个函数的意思：为function对象增加函数，会用链式调用，链式调用有两个参数name,和fn 4、扩展类的相应方法，链式的对象增加jquery库提供的操作函数 1234567891011121314151617181920(function()&#123; //下划线：表示私有变量的写法 function _$(els) &#123; &#125;;//有参数的空对象 //第二步，准备方法 在_$上定义一个onrReady方法 _$.onrReady=function (fn) &#123; //按要求把对象（_$）注册到window对象上 //对外开放的接口 window.$=function () &#123; return new _$(arguments);//传递相应的方法调用参数 返回一可以使用function类原型上的方法的对象（$(&quot;&quot;)=_$(参数)） &#125; fn(); &#125; //第四步 //扩展类的相应方法 链式的对象增加jquery库提供的操作函数 _$.method(&quot;AddEvent&quot;,function (type,fn) &#123;//_$本身是一个function要继承原型链上的东西。 fn();&#125;).method(&quot;getEvent&quot;,function (fn,e) &#123; fn();&#125;)&#125;)() 5、使用，需要调用_$.onReady方法才可以返回对象使用从function类继承而来的原型上的方法 1234567891011121314151617181920212223242526(function () &#123; // （1）下划线：表示私有变量的写法 function _$(els) &#123; &#125;;//有参数的空对象 //（2）准备方法 在_$上定义一个onrReady方法 // window.$=_$; _$.onrReady=function (fn) &#123; //按要求把对象（_$）注册到window对象上 在任何地方都可以使用 //对外开放的接口 window.$=function () &#123;//window 上先注册一个全局变量 与外界产生关系 return new _$(arguments);//传递相应的方法调用参数 返回一可以使用function类原型上的方法的对象（$(&quot;&quot;)=_$(参数)） &#125; fn(); &#125; //（4）扩展类的相应方法 链式的对象增加jquery库提供的操作函数_$.method(&quot;AddEvent&quot;,function (type,fn) &#123;//_$本身是一个function要继承原型链上的东西。 fn();&#125;).method(&quot;getEvent&quot;,function (fn,e) &#123; fn();&#125;); //第五步，开始使用 ，需要调用_$.onready方法才可以返回对象使用从function类继承而来的原型上的方法 _$.onrReady(function () &#123;//$是绑定在Windows上的 $(&quot;&quot;).AddEvent(&quot;click&quot;,function () &#123; alert(&quot;click&quot;) &#125;) &#125;)&#125;)() 简单的加减法链式调用 12345678910111213141516(function()&#123; function test(Number)&#123; return isNaN(Number)?Number:0 &#125; function Add(num)&#123; test(num) return this + num &#125; function jian(num)&#123; test(num) return this - num &#125; Function.prototype.Add = Add Function.prototype.jian = jian&#125;)()","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"AJAX与Json","slug":"前端/AJAX请求","date":"2020-09-23T11:36:18.000Z","updated":"2020-09-23T14:51:40.107Z","comments":true,"path":"2020/09/23/前端/AJAX请求/","link":"","permalink":"http://yoursite.com/2020/09/23/%E5%89%8D%E7%AB%AF/AJAX%E8%AF%B7%E6%B1%82/","excerpt":"","text":"AJAX简介与实例AJAX：即异步的JavaScript和XML，不是一种新的编程语言，而是一种使用现有标准的新方法。 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。最大的优点在于不重新加载页面的情况下，可以与服务器交换数据并更新部分网页内容。 XMLHttpRequest 是 AJAX 的基础；有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 variable=new XMLHttpRequest(); 请求与响应XMLHttpRequest 对象用于和服务器交换数据。如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);xmlhttp.send(); open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string)将请求发送到服务器。 string：仅用于 POST 请求 如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 responseText：获得字符串形式的响应数据。 responseXML：获得 XML 形式的响应数据。 如果来自服务器的响应并非 XML，请使用 responseText 属性。responseText 属性返回字符串形式的响应，因此您可以这样使用： 1document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; 如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; AJAX事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。下面是 XMLHttpRequest 对象的三个重要的属性： onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 回调函数回调函数是一种以参数形式传递给另一个函数的函数。如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）： 12345678910function myFunction()&#123; loadXMLDoc(&quot;/try/ajax/ajax_info.txt&quot;,function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125;);&#125; AJAX 用于创造动态性更强的应用程序 12345678910111213141516171819202122232425262728function showHint(str)&#123; var xmlhttp; if (str.length==0) &#123; document.getElementById(&quot;txtHint&quot;).innerHTML=&quot;&quot;; return; &#125; if (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;txtHint&quot;).innerHTML=xmlhttp.responseText; &#125; &#125; xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/gethint.php?q=&quot;+str,true); xmlhttp.send();&#125; 源代码解析： 如果输入框为空 str.length==0，则该函数清空 txtHint 占位符的内容，并退出函数。 如果输入框不为空，showHint() 函数执行以下任务： 创建 XMLHttpRequest 对象 当服务器响应就绪时执行函数 把请求发送到服务器上的文件 请注意我们向 URL 添加了一个参数 q （带有输入框的内容） 由上面的 JavaScript 调用的服务器页面是 ASP 文件，名为 “gethint.asp”。 下面，我们创建了两个版本的服务器文件，一个用 ASP 编写，另一个用 PHP 编写。 JSON语法与简介JSON: JavaScript Object Notation(JavaScript 对象表示法)；JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析 JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON 具有自我描述性，更易理解 JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。 由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。 与XML对比与 XML 相同之处： JSON 是纯文本 JSON 具有”自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输 与 XML 不同之处： 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 为什么使用 JSON？ 对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML： 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON： 读取 JSON 字符串 用 eval() 处理 JSON 字符串 JSON语法JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号 {} 保存对象 中括号 [] 保存数组，数组可以包含多个对象 JSON 数据的书写格式是：key : value。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值。 “name” : “菜鸟教程”。等价于这条 JavaScript 语句：name = “菜鸟教程”。 JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在中括号中） 对象（在大括号中） null JSON 数组在中括号 [] 中书写：数组可包含多个对象：对象 sites 是包含三个对象的数组。每个对象代表一条关于某个网站（name、url）的记录。 1234567&#123; &quot;sites&quot;: [ &#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;, &#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;, &#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125; 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： 12345var sites = [ &#123; &quot;name&quot;:&quot;runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;, &#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;, &#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125;]; sites[0].name可以访问 JavaScript 对象数组中的第一项 JSON 文件的文件类型是 .json JSON 文本的 MIME 类型是 application/json 与XML相比JSON 和 XML 都用于接收 web 服务端的数据。JSON 和 XML在写法上有所不同，如下所示： 1234567&#123; &quot;sites&quot;: [ &#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;, &#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;, &#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125; 1234567891011&lt;sites&gt; &lt;site&gt; &lt;name&gt;菜鸟教程&lt;/name&gt; &lt;url&gt;www.runoob.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;google&lt;/name&gt; &lt;url&gt;www.google.com&lt;/url&gt; &lt;/site&gt; &lt;site&gt; &lt;name&gt;微博&lt;/name&gt; &lt;url&gt;www.weibo.com&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; JSON 与 XML 的相同之处： JSON 和 XML 数据都是 “自我描述” ，都易于理解。 JSON 和 XML 数据都是有层次的结构 JSON 和 XML 数据可以被大多数编程语言使用 JSON 与 XML 的不同之处： JSON 不需要结束标签 JSON 更加简短 JSON 读写速度更快 JSON 可以使用数组 最大的不同是：XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。 JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。 JSON.stringify(): 于将 JavaScript 值转换为 JSON 字符串。 为什么 JSON 比 XML 更好？XML 比 JSON 更难解析。 JSON 可以直接使用现有的 JavaScript 对象解析。 针对 AJAX 应用，JSON 比 XML 数据加载更快，而且更简单： 使用 XML 获取 XML 文档 使用 XML DOM 迭代循环文档 接数据解析出来复制给变量 使用 JSON 获取 JSON 字符串 JSON.Parse 解析 JSON 字符串 JSON对象与数组JSON 对象使用在大括号({})中书写。 对象可以包含多个 key/value（键/值）对。key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。key 和 value 中使用冒号(:)分割。每个 key/value 对使用逗号(,)分割。 你可以使用点号（.）来访问对象的值。你也可以使用中括号（[]）来访问对象的值： 循环对象你可以使用 for-in 来循环对象的属性：在 for-in 循环对象的属性时，使用中括号（[]）来访问属性的值： 1234var myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;for (x in myObj) &#123; document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125; 嵌套 JSON 对象JSON 对象中可以包含另外一个 JSON 对象：你可以使用点号(.)或者中括号([])来访问嵌套的 JSON 对象。x = myObj.sites.site1; // 或者 x = myObj.sites[“site1”]; 123456789myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;sites&quot;: &#123; &quot;site1&quot;:&quot;www.runoob.com&quot;, &quot;site2&quot;:&quot;m.runoob.com&quot;, &quot;site3&quot;:&quot;c.runoob.com&quot; &#125;&#125; 你可以使用点号(.)来修改 JSON 对象的值：你可以使用中括号([])来修改 JSON 对象的值： 我们可以使用 delete 关键字来删除 JSON 对象的属性：你可以使用中括号([])或者点号.来删除 JSON 对象的属性： 数组作为 JSON 对象JSON 数组在中括号中书写。JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。 JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。 对象属性的值可以是一个数组： 1234567891011121314151617181920212223242526272829303132&#123;&quot;name&quot;:&quot;网站&quot;,&quot;num&quot;:3,&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]&#125;x = myObj.sites[0];//可以使用for-in来访问数组for (i in myObj.sites) &#123; x += myObj.sites[i] + &quot;&lt;br&gt;&quot;;&#125;//也可以for循环for (i = 0; i &lt; myObj.sites.length; i++) &#123; x += myObj.sites[i] + &quot;&lt;br&gt;&quot;;&#125;//嵌套JSON对象中的数组,JSON对象中的数组可以包含另外一个数组，或者另外一个JSON对象；myObj = &#123; &quot;name&quot;:&quot;网站&quot;, &quot;num&quot;:3, &quot;sites&quot;: [ &#123; &quot;name&quot;:&quot;Google&quot;, &quot;info&quot;:[ &quot;Android&quot;, &quot;Google 搜索&quot;, &quot;Google 翻译&quot; ] &#125;, &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;info&quot;:[ &quot;菜鸟教程&quot;, &quot;菜鸟工具&quot;, &quot;菜鸟微信&quot; ] &#125;, &#123; &quot;name&quot;:&quot;Taobao&quot;, &quot;info&quot;:[ &quot;淘宝&quot;, &quot;网购&quot; ] &#125; ]&#125;//可以使用for-in来循环访问每个数组:for (i in myObj.sites) &#123; x += &quot;&lt;h1&gt;&quot; + myObj.sites[i].name + &quot;&lt;/h1&gt;&quot;; for (j in myObj.sites[i].info) &#123; x += myObj.sites[i].info[j] + &quot;&lt;br&gt;&quot;; &#125;&#125; JSON的方法与使用JSON.parse()JSON 通常用于与服务端交换数据。在接收服务器数据时一般是字符串。我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。 JSON.parse(text[ , reviver]) **text:**必需， 一个有效的 JSON 字符串。 reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。 1234567891011121314151617181920212223242526272829303132//如果从服务器接收了以下的数据：&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;//我们使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象var obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);//解析前要确保你的数据是标准的 JSON 格式，否则会解析出错解析完成后，我们就可以在网页上使用 JSON 数据了&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;：&quot; + obj.site;&lt;/script&gt;//我们可以使用AJAX从服务器请求JSON数据，并解析为JS对象var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myObj = JSON.parse(this.responseText); document.getElementById(&quot;demo&quot;).innerHTML = myObj.name; &#125;&#125;;xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/json_demo.txt&quot;, true);xmlhttp.send();//如果服务端接受的是数组的JSON数据，则JSON.parse会将其转换为JS数组var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myArr = JSON.parse(this.responseText); document.getElementById(&quot;demo&quot;).innerHTML = myArr[1]; &#125;&#125;;xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/json_demo_array.txt&quot;, true);xmlhttp.send(); 异常：解析数据，JSON不能存储Date对象，若需要存储Date对象，则需要先将其转换成字符串，之后再将字符串转换成Date对象。 1234567891011121314151617181920212223var text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期: &quot; + obj.initDate;//我们可以启用JSON.parse的第二个参数reviver，一个转换结果的函数，对象的每个成员调用此函数var text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text, function (key, value) &#123; if (key == &quot;initDate&quot;) &#123; return new Date(value); &#125; else &#123; return value;&#125;&#125;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期：&quot; + obj.initDate;//解析函数：JSON不允许包含函数，但可以将函数作为字符串存储，之后再将字符串转换为函数var text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:&quot;function () &#123;return 10000;&#125;&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.alexa = eval(&quot;(&quot; + obj.alexa + &quot;)&quot;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot; Alexa 排名：&quot; + obj.alexa(); JSON.stringify()JSON 通常用于与服务端交换数据。在向服务器发送数据时一般是字符串。我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。 JSON.stringify(value[, replacer[, space]]) value: 必需， 要转换的 JavaScript 值（通常为对象或数组）。 replacer: 可选。用于转换结果的函数或数组。 如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。 如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 space: 可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 12345678910111213141516171819202122232425262728var obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;//使用JSON.stringify()方法处理以上数据，并将其转换为字符串var myJSON = JSON.stringify(obj);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;//同样也可以把JS数组转换成JSON字符串var arr = [ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Facebook&quot; ];var myJSON = JSON.stringify(arr);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;//JSON.stringify() 会将所有日期转换为字符串。之后你可以再将字符串转换为 Date 对象var obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:new Date(), &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;//JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 valuevar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;//我们可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生：var obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;//因此不建议在JSON中使用函数 JSON使用与教程JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。为了更简单地为您讲解，我们使用字符串作为输入进行演示（而不是文件）。 1234567891011121314151617181920212223//创建包含 JSON 语法的 JavaScript 字符串：var txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;;//由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误。var obj = eval (&quot;(&quot; + txt + &quot;)&quot;);//在网页中使用 JavaScript 对象var txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;; var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); document.getElementById(&quot;name&quot;).innerHTML=obj.sites[0].name document.getElementById(&quot;url&quot;).innerHTML=obj.sites[0].url//JSON解析器 eval() 函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本，而不会编译脚本。在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。 JSONPJsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。为什么我们从不同的域（网站）访问数据需要一个特殊的技术( JSONP )呢？这是因为同源策略。同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"","slug":"算法/算法框架","date":"2020-09-16T15:04:18.000Z","updated":"2021-02-01T09:57:15.204Z","comments":true,"path":"2020/09/16/算法/算法框架/","link":"","permalink":"http://yoursite.com/2020/09/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/","excerpt":"","text":"动态规划框架动态规划问题的一般形式是求最值；求解动态规划的核心问题是穷举，肯定要把所有可行的答案穷举出来然后在其中找最值；且一般具有重叠子问题，需要备忘录或者DP table来优化。 关键：状态转移方程，明确[状态]-&gt;定义DP数组、函数的含义-&gt;明确[选择]-&gt;明确basecase。 带备忘录的递归，有时候耗时的原因是重复计算，那么可以造备忘录，每次算出某子问题后不急着返回，先记到备忘录中；每次遇到一个子问题时，先去备忘录查一查，如果发现已经解决过，就直接拿出来用。 一般使用一个数组充当备忘录，当然也可以使用hash表，思想是一样的。 斐波那契数列问题： 12345678const fit = (N) =&gt; &#123; if (N &lt; 1) return 0; var memo = new Array(N + 1); memo[1] = memo[2] = 1; for (let i = 3; i &lt;= N; i++) memo[i] = memo[i-1] + memo[i - 2]; return memo[N];&#125; 带备忘录的递归解法和迭代的动态规划解法其实一样，递归自顶向下，迭代递归自底向上； 动态规划的另一个重要特性：最优子结构；凑零钱问题：给你k种面值的硬币，面值分别为C1、C2、…Ck；再给一个总金额amount，问最少需要多少硬币凑出，如果不能凑出则返回-1。 要符合最优子结构，子问题之间必须相互独立，状态转移方程的步骤 1、确定状态，也就是原问题和子问题变化的变量，唯一状态为目标金额amount； 2、确定dp函数的定义：当前目标金额为n，则至少需要dp(n)个硬币； 3、确定选择并择优：对于每个状态，可以做出选择改变当前状态；具体至当前，无论目标金额多少，选择就是从面额列表coins种选择一个硬币，然后目标金额就会减少。 4、最后明确base case，显然目标金额为0时，所需硬币数量为0；当目标金额小于0时，无解，返回-1。 一般这种题需要使用备忘录来消除子问题，减少其冗余从而节省时间。 123456789101112131415161718192021const coinChange = (coins, amount)&#123; let memo = []; const dp = (n) =&gt; &#123; if (memo[n] != null) return memo[n]; //先查备忘录，避免重复计算 if (n == 0) return 0; if (n &lt; 0) return -1; res = MAX_VALUE; for (let i = 0; i &lt; coins.length; i++)&#123; let subproblem == dp(n - coins[i]); if (subproblem == -1) continue; res = min(res, 1 + subproblem); &#125; if (res != MAX_VALUE)&#123; memo[n] = res; &#125; else memo[n] = -1; return memo[n]; &#125; return dp(amount);&#125; 除了这种自顶向下的带备忘录递归，自底向上的dp数组迭代也一样可以消除子问题：dp[i] = x，表示当目标金额为i时，至少需要x枚硬币。 1234567891011121314151617const coinChange = (coins, amount) =&gt;&#123; let dp = new Array(amount + 1); for (let i = 0; i &lt; amount + 1; i++)&#123; dp[i] = amount + 1; &#125; //先初始化dp数组，长度与初始值 for (i = 0; i &lt; dp.length; i++)&#123; //内层for在求所有子问题+1的最小值 for (let j = 0; j &lt; coins.length; j++)&#123; //子问题无解则跳过 if (i - coins[j] &lt; 0) continue; dp[i] = min(dp[i], 1 + dp[i - coin]); &#125; &#125; if (dp[amount] == amount + 1) return -1; else return dp[amount];&#125; 动态规划之背包问题给你一个则装载重量为W的背包和N个物品，每个物品有重量和价值两个属性，其中第i个物品重量为wt[i]，价值为val[i]，求使用该背包装物品的最大价值。 典型动态规划：物品不可分割，要么装进包里，要么不装，不可能切分。解决这种问题没有排序的巧妙方法，只能穷举所有可能，根据动态规划套路走流程： 1、明确状态与选择；状态：背包容量与可选择的物品；选择：装进背包或不装进背包。 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for .... dp[状态1][状态2][...] = 择优(选择1， 选择2， ...) 2、明确DP数组：描述当前问题局面，需要使用DP数组把状态表示出来，而状态有2个，因此为二维数组dp[i] [w] :对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值为dp[i] [w]。且base case 就是dp[0] [..] = dp[..] [0] = 0。 3、根据选择，思考状态转移的逻辑：即把物品i装不装进背包的代码逻辑怎么体现。如果不装：dp[i] [w] = dp[i-1] [w]，即继承以前的结果；如果装：dp[i] [w] = dp[i-1] [w - wt[i-1]] + val[i-1]，在装第i个的前提下该如何最大价值，应寻求剩余重量w - wt[i-1]限制下的最大重量，再加上确定的第i个物品价值。 12345678910111213141516171819202122const knapsack = (W, N, wt, val) =&gt;&#123; let dp = new Array(); for (let i = 0; i &lt; N + 1; i++)&#123; dp[i] = new Array(); for (let j = 0; j &lt; W + 1; j++)&#123; dp[i][j] = 0; &#125; &#125;//先定义二维数组，并均初始化为0 for (i = 1; i &lt;= N; i++)&#123; for (w = 1; w &lt;= W; W++)&#123; if (w - wt[i - 1] &lt; 0)&#123; //当前背包容量放不下时，只能选择不装入背包 dp[i][w] = dp[i - 1][w]; &#125; else &#123; //装入或不装入背包的择优 dp[i][w] = max(dp[i - 1][w - wt[i - 1]] + val[i - 1], dp[i - 1][w]); &#125; &#125; &#125; return dp[N][W];&#125;//使用动态规划遍历时，同时择优并用DP表来存储已经计算完的数据。 动态规划之子集背包分割怎么将⼆维动态规划压缩成⼀维动态规划吗？这就是状态压缩，很容易的， 题目：给定一个只包含正整数的非空数组，是否可以将该数组分割成两个子集，使两个子集的元素和相等： 对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？ ⾸先回忆⼀下背包问题⼤致的描述是什么： 给你⼀个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两 个属性。其中第 i 个物品的重量为 wt[i] ，价值为 val[i] ，现在让你⽤ 这个背包装物品，最多能装的价值是多少？ 那么对于这个问题，我们可以先对集合求和，得出 sum ，把问题转化为背 包问题：给⼀个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i] 。现在让你装物品，是否存在⼀种装法，能够恰好将背包装满？ 你看，这就是背包问题的模型，甚⾄⽐我们之前的经典背包问题还要简单⼀ 些，下⾯我们就直接转换成背包问题，开始套前⽂讲过的背包问题框架即就可。 1、明确状态与选择；状态：背包容量、可选择的物品；选择：是否装进背包 2、dp数组定义：dp[ i ] [ j ]= x 表⽰，对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true ，则说明可以恰好将背包装满，若 x 为 false ，则说明不能恰 好将背包装满。 3、根据选择来思考状态转移的逻辑，恰好把背包装满的条件，其实刚好又取决于其上一个状态；换句话说，如果 j - nums[i-1] 的重量可以被恰好装满，那么只要把第 i 个物品装进去，也可恰好装满 j 的重量；否则的话，重量 j 肯定是装不满的。 4、basecase：想求的最终答案是dp[N] [sum/2]，因此初始条件为dp[…] [0] = true和dp[0] […] = false； 12345678910111213141516171819202122232425262728293031323334const canPartition = (nums) =&gt; &#123; let sum = 0; for (let i = 0; i &lt; nums.length; i++)&#123; sum += nums[i]; &#125; if (sum % 2 != 0) return false; let len = nums.length; sum = sum / 2; let dp = new Array(); //根据初始条件来初始化 for (i = 0; i &lt;= len + 1; i++) &#123; dp[i] = new Array(); for (let j = 0; j &lt;= sum + 1; j++)&#123; dp[i][j] = false; &#125; &#125; for (i = 0; i &lt;= n; i++)&#123; dp[i] [0] = true; &#125; for (i = 0; i &lt;= n; i++)&#123; for (j = 0; j &lt;= sum; j++)&#123; if (j - nums[i - 1] &lt; 0)&#123; //背包不足，不能装入第i个物品 dp[i] [j] = dp[i - 1] [j]; &#125; else &#123; //装入或不装入的选择 dp[i][j] = dp[i - 1] [j] | dp[i - 1] [j - nums[i - 1]]; &#125; &#125; &#125; return dp[n] [sum];&#125; 动态规划之零钱兑换（完全背包问题）题目：给定不同面额的硬币和一个总金额，假设每种硬币有无数个，写出函数来计算能凑成总金额的硬币总和数。 有⼀个背包，最⼤容量为 amount ，有⼀系列物品 coins ，每个物品的重量为 coins[i] ，每个物品的数量⽆限。请问有多少种⽅法，能够把背包恰 好装满？ 这个问题和我们前⾯讲过的两个背包问题，有⼀个最⼤的区别就是，每个物 品的数量是⽆限的，这也就是传说中的「完全背包问题」，没啥⾼⼤上的， ⽆⾮就是状态转移⽅程有⼀点变化⽽已。 1、状态与选择；状态：背包的容量，可选择的物品；选择：是否装进背包； 2、dp数组：若只使用前i个物品，当背包容量为j时，有dp[i] [j]种方法可以装满背包； 3、base case为dp[0] [..] = 0;dp[..] [0] = 1;不使用任何面值则无法完成，背包容量为0则仅有一种。 4、状态转移方程的逻辑：如果不把第i个物品装进背包，则凑出面额j的方法数dp[i] [j]等于dp[i - 1] [j]，继承之前的结果；如果你把第i个物品装进了背包，则说明使用了coins[i - 1] 这个面额，那么dp[i] [j] = dp [i] [j-coins[i - 1]] 12345678910111213141516171819202122232425const change = (amount, coins) =&gt; &#123; let len = coins.length; let dp = new Array(); //根据初始条件来初始化 for (let i = 0; i &lt;= len + 1; i++) &#123; dp[i] = new Array(); for (let j = 0; j &lt;= sum + 1; j++)&#123; dp[i][j] = 0; &#125; &#125; for (i = 0; i &lt;= n; i++)&#123; dp[i] [0] = 1; &#125; for (i = 1; i &lt;=n; i++)&#123; for (j = 1; j &lt;= amount; j++)&#123; if (j - coins[i - 1] &gt;= 0) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[n][amount];&#125; 动态规划最长递增子序列动态规划的通用技巧：数学归纳思想；最长递增子序列LIS；子串与子序列名词的区别：字串一定是连续的，而子序列不一定是连续的。 1、明确状态与选择：状态，序列nums的所有字母；选择：更新子序列还是 2、用dp数组来描述状态，dp[i]表示以nums[i]这个数结尾的最长递增子序列的长度；后续的动态规划子序列解题模板总结了常见的套路: 3、根据选择思考动态转移方程的逻辑：已知dp[0..n-1]，根据nums[n]的值，便能够判断如何更新，找到结尾比nums[n]小的子序列，然后把nums[n]接到最后，形成新子序列，其长度为原子序列+1；且由于未知之前子序列的大小关系，需要使用遍历将前面的dp值全部遍历一遍； 4、base case: dp[i]初始值为1，因为以nums[i]结尾的LIS最少要包含它自己。 12345678910111213141516171819const lengthOfLIS = (nums) =&gt; &#123; let dp = new Array(); for (let i = 0; i &lt; nums.length; i++)&#123; dp[i] = 1; &#125; for (i = 0; i &lt; nums.length; i++)&#123; for (let j = 0; j &lt; i; j++)&#123; if (nums[i] &gt; nums[j])&#123; dp[i] = max.(dp[i], dp[j] + 1); &#125; &#125; &#125; let res = 0; //将每个以nums[i]结尾的LIS长度存到dp之后，遍历一遍找出最大的那个 for (i = 0; i &lt; dp.length; i++)&#123; res = max.(res, dp[i]); &#125; return res;&#125; 动态规划：最长公共子序列LCSLCS是典型的二维动态规划，目的是求两个字符串的LCS长度，子序列问题基本都用动态规划来实现，穷举加剪枝。 1、明确状态与选择：状态，两个字符串；选择，是否添加该元素作为最长公共子序列。 2、确定dp数组的含义： 两字符串数组的通用套路，dp[i] [j]代表s1[1…i]和s2[1…j]的LCS长度。 3、找状态转移方程：其实字符串问题的状态转移套路都差不多，都是判断字符在还是不在的问题，只有2种选择；如果某字符在LCS中，则其肯定同时存在于s1和s2中。 思路为：用2个指针从后往前遍历s1、s2，若相等则该字符一定在lcs中，否则这两个字符至少有一个不在lcs中，需要丢弃一个； 4、base case：均初始化为0，最短可以没有公共元素。 暴力的递归写法如下： 1234567891011121314const longestCommonSubsequence = (str1, str2) =&gt; &#123; const dp = (let i , let j) =&gt; &#123; if (i === -1 || j === -1) return 0; //先初始化空串的base case if (str1[i] === str[j])&#123; //找到一个lcs的元素则继续往前找 return dp(i - 1, j - 1) + 1; &#125; else&#123; //否则，则找出让lcs最长的 return max(dp(i - 1, j), dp(i, j - 1)); &#125; &#125; return dp(str1.length - 1, str2.length - 1);&#125; 可以通过备忘录或者DPtable来优化时间复杂度， 123456789101112131415161718192021const longestCommonSubsequencr = (str1, str2) =&gt; &#123; let m = str1.length, n = str2.length; let dp = new Array(); for (let i = 0; i &lt; m; i++)&#123; dp[i] = new Array(); for (let j = 0; j &lt; n; j++)&#123; dp[i][j] = 0; &#125; &#125; //构建DPtable并初始化 for (i = 0; i &lt; m; i++)&#123; for (j = 0; j &lt; n; j++)&#123; if (str[i] === str[j])&#123; dp[i][j] = 1 + dp[i - 1][j - 1]; &#125; else&#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[m - 1][n - 1];&#125; 对于str1[i]与str2[j]不等的情况，是否可能两个字符都不在，但其实因为后面的选择max始终选择最大的，因此不用考虑，必然被排除在外。先像文本一样写出伪代码来定义DPtable理清逻辑，思考每个状态有哪些选择，用正确逻辑作出正确判断就能做出正确选择。 经典动态规划：编辑距离给定两个字符串s1和s2，计算出将s1转换成s2所使用的最少操作数，可用操作只有插入、删除、替换一个字符。 思路：解决两个字符串的动态规划问题，一般都是用2个指针i、j分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模； 123456789101112131415161718/*base case:当i走完s1或者j走完s2时，可以直接返回另一个字符串剩下的长度；if s1[i] == s2[j]: 啥也不做(skip) i、j同时移动else: 三选一： 插入、删除、替换三选一选择的标准是：均尝试一遍，哪个操作最后得到的编辑距离最小。*/const minDistance = (s1, s2) =&gt; &#123; const dp = (i, j) =&gt;&#123; if (i == -1) return j + 1; if (j == -1) return i + 1; //定义base case if (s1[i] == s2[j]) return dp(i - 1, j - 1); else return min(dp(i, j - 1) + 1，dp(i - 1, j) + 1, dp(i - 1, j - 1) + 1); &#125; return dp(s1.length - 1, s2.length - 1);&#125; dp(i, j)返回s1[0..i]和s2[0..j]的最小编辑距离；同样，上述的解法属于暴力破解，需要使用动态规划技巧来优化重叠子问题 12345678910111213141516171819202122232425262728const minDistance = (s1, s2) =&gt; &#123; let m = str1.length, n = str2.length; let dp = new Array(); for (let i = 0; i &lt; m; i++)&#123; dp[i] = new Array(); for (let j = 0; j &lt; n; j++)&#123; dp[i][j] = 0; &#125; &#125; //构建DPtable并初始化 for (int i = 1; i &lt;= m; i++)&#123; dp[i][0] = i; &#125; for (int j = 1; j &lt;= n; j++)&#123; dp[0][j] = j; &#125; //进行合适的DPtable初始化，DPtable自底向上求解，递归从上至下 for (i = 1; i &lt;= m; i++)&#123; for (j = 1; j &lt;= n; j++)&#123; if (s1[i] === s2[j])&#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else&#123; dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1); &#125; &#125; &#125; return dp[m][n];&#125; 一般来说，处理两个字符串的动态规划问题，均按照本文思路处理，建立DPtable；但这里仅给出了最小编辑距离，具体如何修改则需要给dp数组增加额外的信息。则使用JS中的对象数组，dp[i] [j]中存储的是一个对象 1234567891011121314let arrayObj = [&#123;&#125;];//定义对象数组let m = str1.length, n = str2.length; let dp = new Array(); for (let i = 0; i &lt; m; i++)&#123; dp[i] = new Array(); for (let j = 0; j &lt; n; j++)&#123; dp[i][j] = &#123; &#x27;val&#x27; : 0, &#x27;choice&#x27; : 0, //val为其原本dp数组值，choice为操作，0代表什么也不做，1代表插入，2代表删除，3代表替换 &#125;; &#125; &#125;//最终结果为dp[m][n]，后续则一步步反推，插入=&gt;左移、替换=&gt;左移并上移、删除=&gt;上移,形成一条路径；这样一步步走回来了。 动态规划的子序列模板（最长回文子序列）子序列通常涉及两个字符串，例如：两个字符串的最长公共子序列；既然要用动态规划，关键在于dp数组的定义与寻找状态转移关系，不同问题需要使用不同的dp数组定义。 一、一维的dp数组最长递增子序列LIS：在子数组array[0…i]中，以array[i]为结尾的目标子序列的长度是dp[i]。 目的：符合归纳法，能够从前n-1个的结果中推断出来第n个的结果 二、二维的dp数组涉及两个字符串、数组时：在子数组arr1[0…i]和子数组arr2[0…j]中，我们要求的子序列(最长公共子序列)长度为dp[i] [j]; 只涉及一个字符串、数组：在子数组array[i…j]中，我们要求的子序列(最长回文子序列)的长度为dp[i] [j]。 最长回文子序列DPtable的定义：在子串s[i…j]中，最长回文子序列的长度为dp[i] [j]；找状态转移方程的关键在于归纳思维，即如何从已知的结果推断出未知的部分。 具体来说，如果我们想求dp[i] [j]，假设已经知道子问题dp[i + 1] [j - 1]的结果，是否能想办法算出dp[i] [j]的值。可以，取决于s[i]和s[j]的字符。1、如果他两相等则它们加上便就是当前的最大回文子序列；2、如果她两不相等，说明两者不可能同时出现在最长回文子序列中，于是把它们分别加入s[i+1…j-1]中，看看哪个子串产生的回文子序列更长即可。 base case：dp[i] [j] = 1; 123456789101112131415161718192021222324const longestPalindromeSubseq = (str1) =&gt; &#123; let m = str1.length; let dp = new Array(); for (let i = 0; i &lt; m; i++)&#123; dp[i] = new Array(); for (let j = 0; j &lt; n; j++)&#123; dp[i][j] = 0; &#125; &#125; for (i = 0; i &lt; n; i++)&#123; dp[i][i] = 1; &#125; //根据上面的状态转移方程，为保证每次计算dp[i][j]，左、下、左下三个方向的位置均被计算出来，只能斜着遍历或反着遍历。 for (i = n - 1; i &gt;= 0; i--)&#123; for (let j = i + 1; j &lt; n; j++)&#123; if (s[i] == s[j])&#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125; else&#123; dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n - 1];&#125; 动态规划的正则表达式算法的设计是⼀个螺旋上升、逐步求精 的过程，绝不是⼀步到位就能写出正确算法。 写递归的技巧是管好当下，之后的事抛给递归 动态规划答疑篇最优子结构最优子结构：从子问题的最优结果能够推断出更大规模问题的最优结果；想要满足最优子结构，子问题之间必须相互独立。遇到这种最优子结构失效的情况，策略是改造问题。等价转化：最大分数差&lt;=&gt;最高分数和最低分数的差&lt;=&gt;求最高与最低分数。 最优子结构并不是动态规划独有的性质，但反过来，动态规划一定是要求的求最值的。动态规划就是通过base case一步步反推往上，只有符合最优子结构的问题才有发生这种链式反应的性质。 找寻最优子结构的过程其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就能看出有没有重叠子问题，有则优化。 dp数组的遍历方向对dp数组的遍历方向有所困惑，可以正向、反向遍历，乃至斜向遍历； 123456//斜着遍历for (let l = 2; l &lt;= n; l++)&#123; for (let i = 0; i &lt;= n - 1; i++)&#123; let j = l + i - 1; &#125;&#125; dp遍历设置的两大原则：1、遍历的过程中，所需的状态必须是已经计算出来的；2、遍历的终点必须是存储结果的那个位置； 即根据base case处于的位置来判断dp数组计算的起步，根据递推关系来判断dp数组递推的方向。 动态规划二维变一维动态规划之股票买卖题目：给定一个数组，它的第i个元素是一支给定的股票在第i天的价格，设计一个算法来计算你所能获取的最大利润，且你最多可以完成k笔交易。（你不能同时参与多笔交易，必须在再次购买之前出售） 穷举框架这⾥，我们不⽤递归思想进⾏穷举，⽽是利⽤「状态」进⾏穷举。我们具 体到每⼀天，看看总共有⼏种可能的「状态」，再找出每个「状态」对应的 「选择」。我们要穷举所有「状态」，穷举的⽬的是根据对应的「选择」更 新状态。 ⽐如说这个问题，每天都有三种「选择」：买⼊、卖出、⽆操作，我们⽤ buy, sell, rest 表⽰这三种选择。但问题是，并不是每天都可以任意选择这三 种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作 还应该分两种状态，⼀种是 buy 之后的 rest（持有了股票），⼀种是 sell 之 后的 rest（没有持有股票）。⽽且别忘了，我们还有交易次数 k 的限制，就 是说你 buy 还只能在 k &gt; 0 的前提下操作。 这个问题的「状态」有三个，第⼀个是天 数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨⽤ 1 表⽰持有，0 表⽰没有持有）。然后我们⽤⼀个 三维数组就可以装下这⼏种状态的全部组合： ⽽且我们可以⽤⾃然语⾔描述出每⼀个状态的含义，⽐如说 dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交 易。再⽐如 dp [2] [3] [0] 的含义：今天是第⼆天，我现在⼿上没有持有股 票，⾄今最多进⾏ 3 次交易。很容易理解，对吧？ 我们想求的最终答案是 dp [n - 1] [K] [0]，即最后⼀天，最多允许 K 次交易， 最多获得多少利润。读者可能问为什么不是 dp[n - 1] [K] [1]？因为 [1] 代表⼿ 上还持有股票，[0] 表⽰⼿上的股票已经卖出去了，很显然后者得到的利润 ⼀定⼤于前者。 记住如何解释「状态」，⼀旦你觉得哪⾥不好理解，把它翻译成⾃然语⾔就 容易理解了。 状态转移框架1234567dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell ) 解释：今天我没有持有股票，有两种可能： 要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有； 要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy ) 解释：今天我持有着股票，有两种可能： 要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票； 要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了 现在，我们已经完成了动态规划中最困难的⼀步：状态转移⽅程。如果之前 的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就 ⾏了。不过还差最后⼀点点，就是定义 base case，即最简单的情况 123456789dp[-1][k][0] = 0 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity 解释：还没开始的时候，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。 dp[i][0][0] = 0 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity 解释：不允许交易的情况下，是不可能持有股票的，⽤负⽆穷表⽰这种不可能 总结一下： 1234567base case: dp[-1][k][0] = dp[i][0][0] dp[-1][k][0] = dp[i][0][1] = -infinity 状态转移方程: dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) k=1时12345678910111213141516171819for (int i = 0; i &lt; n; i++) &#123; if (i - 1 == -1)&#123; dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; &#125; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); &#125;return dp[n - 1][0]; 第⼀题就解决了，但是这样处理 base case 很⿇烦，⽽且注意⼀下状态转移 ⽅程，新状态只和相邻的⼀个状态有关，其实不⽤整个 dp 数组，只需要⼀ 个变量储存相邻的那个状态就⾜够了，这样可以把空间复杂度降到 O(1): k= +infinityk为正无穷，则可以把k、k-1看作一样，同样可以改写框架，数组中k已经不会改变，则不需要记录k。 12345678910int maxProfit_k_inf(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); &#125; return dp_i_0; &#125; k = infinity + coldDown每次 sell 之后要等⼀天才能继续交易。只要把这个特点融⼊上⼀题的状态转 移⽅程即可： 12345678910111213141516dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) ;dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]);//解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，⽽不是 i-1 。int maxProfit_with_cool(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; &#125; return dp_i_0; &#125; k = +infinity with fee每次交易要⽀付⼿续费，只要把⼿续费从利润中减去即可。 12345678910111213dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) ;dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee); //解释：相当于买⼊股票的价格升⾼了。 在第⼀个式⼦⾥减也是⼀样的，相当于卖出股票的价格减⼩了。int maxProfit_with_fee(int[] prices, int fee) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); &#125; return dp_i_0; &#125; k = 2k = 2 和前⾯题⽬的情况稍微不同，因为上⾯的情况都和 k 的关系不太⼤。 要么 k 是正⽆穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后⾯要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出 来了。 这道题由于没有消掉 k 的影响，所以必须要对 k 进⾏穷举： 123456789101112int max_k = 2; int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i &lt; n; i++) &#123; for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /*处理 base case */ &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125; &#125;// 穷举了 n × max_k × 2 个状态，正确。 return dp[n - 1][max_k][0]; k = any integer有了上⼀题 k = 2 的铺垫，这题应该和上⼀题的第⼀个解法没啥区别。但是 出现了⼀个超内存的错误，原来是传⼊的 k 值会⾮常⼤，dp 数组太⼤了。 现在想想，交易次数 k 最多有多⼤呢？ ⼀次交易由买⼊和卖出构成，⾄少需要两天。所以说有效的限制 k 应该不超 过 n/2，如果超过，就没有约束作⽤了，相当于 k = +infinity。这种情况是之 前解决过的。 直接把之前的代码重⽤： 123456789101112int maxProfit_k_any(int max_k, int[] prices) &#123; int n = prices.length; if (max_k &gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i &lt; n; i++) for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i0]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices; 动态规划与回溯对比题目：给定一个非负整数组，a1,a2,…an和一个目标数，S。现在你有两个符号+和-；对于数组中的任意一个整数，你都可以添加一个符号到前面，返回可以使最终数组和为目标数S的所有添加符号的方法数。 回溯思路回溯算法就是一个暴力穷举算法；关键在于1、路径（即已经做出的选择），2、选择列表（当前可以做的选择），3、结束条件（到达决策树底层，无法再做选择的条件）。 1、路径：之前已经给前面的数字写出的正负号；2、选择列表：即每个数字可以选择给出正号或者负号；3、结束条件：即已经走到了最后一个数字； 1234567891011121314151617181920212223242526272829303132let result = 0;//主函数const findTargetSumWays = (nums, target) =&gt; &#123; if (nums.length == 0) return 0; backtrack(nums, 0, target); return result const backtrack = (nums, i, rest)&#123; //base case if (i == nums.length)&#123; if (rest == 0)&#123; //说明恰好凑出target result++; &#125; return; &#125; //给nums[i]选择-号 rest += nums[i]; //递归来穷举nums[i+1]的可能性 backtrack(nums, i + 1, rest); //撤销选择 rest -= nums[i]; //给nums[i]选择+号 rest -= nums[i]; //穷举nums[i+1] backtrack(nums, i + 1, rest); //撤销选择 rest += nums[i]; &#125; &#125; 时间复杂度为O(2^N)，N为nums的大小，其实这个回溯算法就是个二叉树的遍历问题，树的高度就是nums的长度，故时间复杂度就是这棵二叉树的节点数，其实比较低效。 消除重叠子问题动态规划快的原因就是消除了重叠子问题，关键在于看是否可能出现重复的状态；对于递归函数来说，函数参数中会变得参数就是状态，对于backtrack函数即i和rest。那么怎么一眼看出存在重叠子问题？ 1、先抽象出算法得递归框架； 1234def dp(i, j): dp(i - 1, j - 1)#1 dp(i, j - 1)#2 dp(i - 1, j)#4 2、对于子问题dp(i-1, j-1)，如何通过原问题dp(i, j)来得到呢？有多种不同路径:比如dp(i,j)=&gt;#1，和dp(i, j)=&gt;#2 =&gt;#3。一旦发现一条重复路径就说明存在巨量重复路径，也就是重叠子问题。 对于上题： 12345678910111213141516171819202122232425262728293031void backtrack(int i, int rest)&#123; backtrack(i + 1，rest - nums[i]); backtrack(i + 1, rest + nums[i]);&#125;//当nums[i]=0时，出现两种状态完全相同得递归函数，这就是重叠子问题//因此状态(i, rest)可以用备忘录来优化const fingTargetSumWays = (nums, target) =&gt;&#123; if (nums.length == 0) return 0; return dp(nums, 0, target);&#125;//备忘录const memo = new Map();const dp = (nums, i, rest) =&gt;&#123; //base case if (i == nums.length) &#123; if (rest == 0) return 1; return 0; &#125; //避免重复计算,转换成字符串从而作为Map的键来存储 let key = i.toString() + &quot;,&quot; + rest.toString； if (memo.has(key)) &#123; return memo.get(key); &#125; //还是穷举 let result = dp(nums, i + 1, rest - nums[i]) + dp(nums, i + 1, rest + nums[i]); //这两种情况，&quot;+&quot;或者&quot;-&quot;号 memo.set(key, result);&#125; 动态规划上述的消除重叠子问题的方案，在最坏情况下的时间复杂度仍为O(2^N)，因为底层逻辑没变，暴力穷举，加上顺手进行了剪枝，提升了算法在某些情况的效率，但不算质的飞跃。其实，这个问题可以转化成一个子集划分的问题，而子集划分问题又是一个典型的背包问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//我们把nums划分为两个子集A、B，分别代表分配+的数和分配-的数，则它们跟target存在如下关系：sum(A) - sum(B) = targetsum(A) = target + sum(B)sum(A) + sum(A) = target + sum(B) + sum(A)2 * sum(A) = target + sum(nums)//因此可以把问题转化为：nums中存在几个子集A，使得A中元素的和为(target + sum(nums)) / 2。//这样就变成了经典的背包问题//dp[i][j]代表前i个数构成结果为j的方法个数const fingTargetSumWays = (nums, target) =&gt; &#123; let sum = 0; for (let i = 0; i &lt; nums.length; i++)&#123; sum += nums[i]; &#125; let len = nums.length; sum = (sum + target) / 2; let dp = new Array(); //根据初始条件来初始化 for (i = 0; i &lt;= len + 1; i++) &#123; dp[i] = new Array(); for (let j = 0; j &lt;= sum + 1; j++)&#123; dp[i][j] = 0; &#125; &#125; for (j = 0; j &lt;= n; i++)&#123; dp[0][j] = 0; &#125; //没有物品则没办法装背包，则为0 for (i = 0; i &lt;= n; i++)&#123; dp[i][0] = 1; &#125; //背包的最大载重为0，则只有一种方法，即什么都不装 for (i = 1; i &lt;= nums.length; i++)&#123; for (j = 1; j &lt;= sum; j++)&#123; if (j - nums[i - 1] &lt; 0)&#123; //背包不足，不能装入第i个物品 dp[i][j] = dp[i - 1] [j]; &#125; else &#123; //装入或不装入的选择 dp[i] [j] = dp[i - 1] [j] + dp[i - 1] [j - nums[i - 1]]; &#125; &#125; &#125; return dp[nums.length][sum];&#125; 总结一下：回溯算法虽好，但是复杂度很高，即使消除一些冗杂计算也只是剪枝，没有本质的改变；而动态规划则比较玄学，经过各种改造后，从一个加减法问题变成了子集问题，又变成背包问题，经过各种套路写出解法，还得使用状态压缩，加上反向遍历。 回溯算法框架解决一个回溯问题，其实即使一个决策树的遍历过程，只需要思考3个问题，1、路径：就是已经做出的选择；2、选择列表：就是你当前可以做的选择；3、结束条件：到达决策树底层，无法再做选择的条件。 12345678910result = []def backtrack(路径，选择列表) if 满足结束条件： result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径，选择列表) 撤销选择 核心其实就是for循环里面的递归，在递归调用前做选择，递归调用之后撤销选择。 回溯之全排列问题穷举n个不重复数的全排列，求有多少个。 则可以画出该算法的决策树如下，每个节点都在做决策。[2]就是路径，记录你已经做过的选择；[1，3]是选择列表，表示当前可以做出的选择；[结束条件]就是遍历到树的底层，即选择列表为空的时候。 我们定义的backtrack函数其实就像一个指针，在这棵树上游走同时正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。 树的遍历问题：前序遍历、后序遍历。前序遍历代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行；函数在树上游走，正确维护其属性就是要在这两个特殊时间点搞动作。我们只要在递归之前做出选择，递归之后撤销选择，就能得到每个节点的选择列表、路径。 1234567891011121314151617181920212223242526272829List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); /* 主函数，输⼊⼀组不重复的数字，返回它们的全排列 */ List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 记录「路径」 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(nums, track); return res; &#125;// 路径：记录在 track 中 // 选择列表：nums 中不存在于 track 的那些元素 // 结束条件：nums 中的元素全都在 track 中出现 void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) &#123; // 触发结束条件 if (track.size() == nums.length) &#123; res.add(new LinkedList(track)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // 排除不合法的选择 if (track.contains(nums[i])) continue; // 做选择 track.add(nums[i]); // 进⼊下⼀层决策树 backtrack(nums, track); // 取消选择 track.removeLast(); &#125; &#125; 我们这⾥稍微做了些变通，没有显式记录「选择列表」，⽽是通过 nums 和 track 推导出当前的选择列表：因为穷举整棵决策树是⽆法避免的。这也是回溯算法的⼀ 个特点，不像动态规划存在重叠⼦问题可以优化，回溯算法就是纯暴⼒穷*举，复杂度⼀般都很⾼。 回溯之N皇后问题给你⼀个 N×N 的棋盘，让你放置 N 个 皇后，使得它们不能互相攻击。 这个问题本质上跟全排列问题差不多，决策树的每⼀层表⽰棋盘上的每⼀ ⾏；每个节点可以做出的选择是，在该⾏的任意⼀列放置⼀个皇后。 则可以直接套用框架： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354vector&lt;vector&lt;string&gt;&gt; res; /* 输⼊棋盘边⻓ n，返回所有合法的放置 */ vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; // &#x27;.&#x27; 表⽰空，&#x27;Q&#x27; 表⽰皇后，初始化空棋盘。 vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;)); backtrack(board, 0); return res; &#125;// 路径：board 中⼩于 row 的那些⾏都已经成功放置了皇后 // 选择列表：第 row ⾏的所有列都是放置皇后的选择// 结束条件：row 超过 board 的最后⼀⾏ void backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return; &#125; int n = board[row].size(); for (int col = 0; col &lt; n; col++) &#123; // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = &#x27;Q&#x27;; // 进⼊下⼀⾏决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = &#x27;.&#x27;; &#125;&#125;//这部分的主要代码其实跟全排列差不多，都是遍历的思想，先检查是否合理，再进行决策并递归进下一层，下一层递归遍历完之后再撤销选择。/* 是否可以在 board[row][col] 放置皇后？ */ bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123; int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i &lt; n; i++) &#123; if (board[i][col] == &#x27;Q&#x27;) return false; &#125; // 检查右上⽅是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (board[i][j] == &#x27;Q&#x27;) return false; &#125; // 检查左上⽅是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (board[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125; 函数 backtrack 依然像个在决策树上游⾛的指针，通过 row 和 col 就可 以表⽰函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝： 这个问题的复杂度确实⾮常⾼，看看我们的决策树，虽 然有 isValid 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，⽽且⽆ 法优化。如果 N = 10 的时候，计算就已经很耗时了。 有的时候，我们并不想得到所有合法的答案，只想要⼀个答案，怎么办呢其实特别简单，只要稍微修改⼀下回溯算法的代码即可： 1234567891011121314151617// 函数找到⼀个答案后就返回 true bool backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return true; &#125; ... for (int col = 0; col &lt; n; col++) &#123; ... board[row][col] = &#x27;Q&#x27;; if (backtrack(board, row + 1)) return true; board[row][col] = &#x27;.&#x27;; &#125; return false; &#125; 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置 做⼀些操作，算法框架如下： 写 backtrack 函数时，需要维护⾛过的「路径」和当前可以做的「选择列 表」，当触发「结束条件」时，将「路径」记⼊结果集 动态规划的三个需要明确的点就是「状态」「选择」和 「base case」，是不是就对应着⾛过的「路径」，当前的「选择列表」和 「结束条件」某种程度上说，动态规划的暴⼒求解阶段就是回溯算法。只是有的问题具有 重叠⼦问题性质，可以⽤ dp table 或者备忘录优化，将递归树⼤幅剪枝，这 就变成了动态规划。⽽今天的两个问题，都没有重叠⼦问题，也就是回溯算 法问题了，复杂度⾮常⾼是不可避免的。 DFS与BFS详解DFS的简要说明(1)：深度优先搜索（Depth-First-Search）是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。 (2)：DFS是图论里面的一种搜索算法，他可以由一个根节点出发，遍历所有的子节点，进而把图中所有的可以构成树的集合都搜索一遍，达到全局搜索的目的。所以很多问题都可以用dfs来遍历每一种情况，从而得出最优解，但由于时间复杂度太高，我们也叫做暴力搜索。 (3)：DFS如同数据结构中的栈结构，是属于一种后进先出的结构，比如说一个羽毛球筒，把它装满之后，我们开始使用时，拿的总是最后放进去的那一个。所以这就导致了所有的点进入栈时有一个顺序，我们称之为 ：DFS序。 (4)：根据dfs的英文全写，我们可以知道这是一种深度优先搜索的搜索算法，什么叫做深度优先？意思就是它搜索一颗子树时，它要遍历到底才会 “回头” ，比如说：上有向图中的 搜索模式 为(以DFS序来描述)：a-&gt;b-&gt;e-&gt;b-&gt;f-&gt;c-&gt;f-&gt;b-&gt;c-&gt;b-&gt;a-&gt;c-&gt;a-&gt;d-&gt;g-&gt;d-&gt;a，有人就会问为什么搜索到c的时候不搜索a呢？因为我们假设的这是一个有向图。而且我们可以看到如果 你面对的图是一个 无向图，这个时候这个树将会持续搜索因为可能会形成环路，使得栈的结构一直进进出出，导致程序崩溃，所以我们也因该注意，在写DFS时，如果面对的是一个无向图的话我们需要进行标记。一般的标记方法有:①这个点的父节点被标记，使得子节点不能回到父节点造成循环②访问过的节点被标记。这两种方法视情况而定。 (5)：对于暴搜来说，因其复杂度太高，我们就会想去优化它的复杂度，这一过程称为剪枝，剪纸分为可行性剪枝和最优化剪枝，关于剪枝引申出一种名为记忆化搜索的方法，该方法与动态规划类似。 BFS简要说明(1)：与DFS相对的那就是BFS了，BFS称为宽度优先搜索也叫做广度优先搜索，他是按层遍历每一种状态的下一种状态。 搞不懂？没关系我们来看一下一个例题：给你一个整数X，问是否存在一个这样一个数字A：①这个数字是X的倍数②这个数字仅由0与1这两种数字组成 例如 X=2，A=10。这个题当然可以用 DFS来做，我们以1为起点 这样就成了一个 0 1 二叉树，意思就是说每一种 情况 我们都可以 有两种选择 要么 添0，要么在后面 添1。所以我们可以写出代码： 12345678910void dfs(int start)&#123; if(A%X==0)//这是我们搜索结束的条件 &#123; ans=A;//让ans记录答案开始return return ans; &#125; dfs(start*10); dfs(start*10+1);&#125; 所以我们开始试例子：输入 2按照dfs序的话，首先不符合条件，然后进入下一步搜索，X*10=10，发现10%2==0，然后开始返回ans记录A，这就是最后答案，但是你会发现程序崩溃了。我们分析一下原因：DFS为深度优先搜索，所以我们的左子树可以看作是在末尾加0，然后右子树可以看作在末尾加1，所以这样就形成了一棵树。按照DFS我们的意图是让他搜索左子树，所以在左子树中找到了 满足条件的 数 ：10。但是为什么程序会崩溃呢？ (2）因为搜索到树之后，按照我们刚刚的DFS序，这个树遍开始回溯(你可以想象成这棵树开始回缩)，每回溯到一个节点，因为这个节点的 右子树还没有搜索，所以会再去搜索这个节点的右子树，但是这个节点的右子树是在末尾进行加1，而末尾是1绝对不可能是 2 的倍数 所以这个树会一直按照 往右子树 搜索的趋势 进行下去，导致程序崩溃。 1234567891011//那是不是这个问题只能枚举了呢？其实DFS是可以的，在网络大神的果断判断之下这个问题出了一个新解：当搜索的深度为19时，此时的答案一定会出现，这时候回溯就好了。所以说我们加一个step记录深度就可以了：void dfs(int start,int step)&#123; if(A%X==0&amp;&amp;step==19)//这是我们搜索结束的条件 &#123; ans=A;//让ans记录答案开始return return ans; &#125; dfs(start*10,step+1); dfs(start*10+1,step+1);&#125; (3)：还有没有更好的方法呢？在考虑这个问题的时候我们回顾一下刚刚为什么程序崩溃，原因就是因为DFS是一个深度优先搜索，他每次必须要 深搜到底 ，所以对于末尾是1来说永远没有结束条件所以它一直会搜索下去！这个时候我们可不可以想有没有这样一种搜索模式，出现A=10这个情况之后我们立刻停止就可以了呢？当然是有的，那就是BFS。 (4)：弄完上面这个例题，也就真正的引出了BFS也发现了DFS的一些小缺点。下面说一下上面留下的定义：按层遍历每一种的状态的下一种状态。首先BFS是与数据结构中的 队列 相似，队列是一种 先进先出的结构，这又比如说 你把一些水果按时间一天一个放进一个箱子里，但这些水果时间长了会变质，我们假设变质日期是一样的，那么你每次拿都是拿的最早放进去的那个。 所以说对于刚刚那个题目而言，我们如果按层遍历就不会出现程序崩溃的现象，比如说 第二层有10 11，那我们就不必搜索下一层了 DFS应用(1).DFS由于有回溯的步骤，所以我们可以对其进行更新，比如并查集合并时的状态压缩都是使用DFS，还有图论中的 tarjan算法，lca等等。 (2)：搜索 有状态约束的 问题，比如说：N皇后问题； BFS应用(1)：求最短路，这个是图论里面的一种应用被称为SPFA算法，在我之前的博客中有总结过，所以在这里不再提。 (2)：求迷宫最短路，这种题目用DFS也是可以解的，用 DFS的思路:有许多条路可以到达终点我们求一下 到达终点的最小值。这样是非常耗时间的 而BFS不一样因为BFS是按层遍历，所以 每一层对于根节点来说距离一定是最小的，不需要再次更新，我们到达终点时这个距离一定一定是最小的，比如说： （3)：同时移动性题目问题，火山在喷发，你在跑问是否可以跑出去。详情之前解释过这个问题： (4)：倒水问题，每次倒水状态之间的转移，之前也有过例题：&amp;&amp;POJ341pots (5)：路径还原，问从一个点到另一个点 的最短路径是多少，而题目不要求你输入最短距离，而是要求你还原路径这种时候通常需要加一个结构体数组来记录，其实上面的例题pots也是一个路径还原的问题，用一个简单的例题总结一下路径还原：","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法框架","slug":"算法框架","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/"}]},{"title":"算法入门","slug":"算法/海贼班算法","date":"2020-09-16T10:46:57.000Z","updated":"2020-09-16T13:03:07.812Z","comments":true,"path":"2020/09/16/算法/海贼班算法/","link":"","permalink":"http://yoursite.com/2020/09/16/%E7%AE%97%E6%B3%95/%E6%B5%B7%E8%B4%BC%E7%8F%AD%E7%AE%97%E6%B3%95/","excerpt":"","text":"leetcode题目167.两数之和给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; numbers.size(); i++)&#123; int t = target - numbers[i], l = i + 1, r = numbers.size() - 1; while (l &lt;= r)&#123; int mid = (l + r) / 2; if (numbers[mid] == t)&#123; v.push_back(i + 1); v.push_back(mid + 1); return v; &#125; if (numbers[mid] &lt; t)&#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; &#125; return v; &#125;&#125;; 7、整数反转给出一个32位的整数，需要将这个整数中每位上的数字进行反转。 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; long long ans = 0; while (x) &#123; ans = ans * 10 + x % 10; x /= 10; &#125; if (ans &lt; INT_MIN || ans &gt; INT_MAX)&#123; return 0; &#125; return (int)ans; &#125;&#125;;//小的类型会越界，则添加一个大的类型将其存储，并在后面添加判断语句。 9、判断回文数判断一个整数是否是回文数；即从右往左和从左往右一样；其实就是将该数反转调过来。 1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; long long y = 0, z = x; if (z &lt; 0)&#123; return false; &#125; while (z)&#123; y = y * 10 + z % 10; z /= 10; &#125; return y == x; &#125;&#125;; 13、罗马数字转整数14、最长公共前缀编写一个函数来查找字符串数组中最长公共前缀，不存在则返回空字符串。关键在于用两个for循环，一个用于遍历字符串数组，另一个用于遍历每个字符串中字符。 相当于就是两个for循环来分别遍历字符串和字符串内字符，然后break用于提前退出来节省时间。 123456789101112131415161718192021222324class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() == 0)&#123; return &quot;&quot;; &#125; string ans = strs[0]; for (int i = 1; i &lt; strs.size(); i++)&#123; string t = ans; ans = &quot;&quot;; for (int j = 0; j &lt; t.size() &amp;&amp; j &lt; strs[i].size(); j++)&#123; if (t[j] == strs[i][j])&#123; ans += t[j]; &#125;else&#123; break; &#125; &#125; if (ans == &quot;&quot;)&#123; break; &#125; &#125; return ans; &#125;&#125;; 20、有效的括号完全包含问题则适用于栈来进行处理 1234567891011121314151617181920class Solution &#123;public: bool isValid(string s) &#123; stack &lt;char&gt; sta; for (int i &#x3D; 0; i &lt; s.size(); i++)&#123; if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;[&#39; || s[i] &#x3D;&#x3D; &#39;&#123;&#39;)&#123; sta.push(s[i]); &#125; else&#123; if (sta.empty() || (s[i] &#x3D;&#x3D; &#39;)&#39; &amp;&amp; sta.top() !&#x3D; &#39;(&#39;) || (s[i] &#x3D;&#x3D; &#39;]&#39; &amp;&amp; sta.top() !&#x3D; &#39;[&#39;) || (s[i] &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; sta.top() !&#x3D; &#39;&#123;&#39;) )&#123; return false; &#125; sta.pop(); &#125; &#125; return sta.empty(); &#125;&#125;; 21、合并两个有序链表将两个升序链表合并成一个新的升序链表并返回，新链表由拼接给定的两个链表的所有节点组成；关键在于链表的操作以及判断边界条件。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; var ans = new ListNode(); var root = ans; while (l1 != null || l2 != null)&#123; if (l1=== null)&#123; root.next = l2; break; &#125; if (l2 === null)&#123; root.next = l1; break &#125; if (l1.val &lt; l2.val)&#123; root.next = l1; l1 = l1.next; &#125; else&#123; root.next = l2; l2 = l2.next; &#125; root = root.next; &#125; return ans.next;&#125;; 26、删除排序数组重复项双指针法 1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; let left = 0, right = 1; while(right &lt; nums.length)&#123; if(nums[left] !== nums[right])&#123; nums[++left] = nums[right]; &#125; right++; &#125; return left + 1;&#125;; 27、移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素 123456789var removeElement = function(nums, val) &#123; let ind = 0; for (let i = 0; i &lt; nums.length; i++)&#123; if (nums[i] != val)&#123; nums[ind++] = nums[i]; &#125; &#125; return ind;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"极客算法专栏","slug":"算法/极客算法专栏","date":"2020-09-16T07:53:11.000Z","updated":"2020-09-16T07:53:11.521Z","comments":true,"path":"2020/09/16/算法/极客算法专栏/","link":"","permalink":"http://yoursite.com/2020/09/16/%E7%AE%97%E6%B3%95/%E6%9E%81%E5%AE%A2%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"堆排序及其相关","slug":"算法/堆排序及其相关","date":"2020-09-15T13:22:07.000Z","updated":"2020-09-15T13:22:07.793Z","comments":true,"path":"2020/09/15/算法/堆排序及其相关/","link":"","permalink":"http://yoursite.com/2020/09/15/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"css设计","slug":"前端/css与html设计","date":"2020-09-15T11:40:46.000Z","updated":"2021-02-22T12:30:05.755Z","comments":true,"path":"2020/09/15/前端/css与html设计/","link":"","permalink":"http://yoursite.com/2020/09/15/%E5%89%8D%E7%AB%AF/css%E4%B8%8Ehtml%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"CSS样式设计flex布局语法传统的解决方案，基于盒装模型，依赖display 属性 + position属性 + float属性。对于特殊布局非常不方便(比如垂直居中)。flex布局可以简便，完整，响应式地实现各种页面布局，目前已得到所有浏览器的支持。 flex布局概念flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒装模型提供最大的灵活性。设为 flex 布局以后，子元素的float，clear和vertical-align属性将失效。采用flex布局的元素，称为flex容器，它的所有子元素自动成为容器成员，称为flex项目 轴我们知道，轴包括主轴和交叉轴默认情况下，主轴的方向是从左向右的，交叉轴垂直于主轴，逆时针方向90度；交叉轴是由主轴决定的，主轴又是由flex-direction决定的；flex-direction属性设置在父容器上，这样子才可以生效。 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;flex1&quot;&gt;子盒子#flex1: 1 &lt;/div&gt; &lt;div class=&quot;flex2&quot;&gt;子盒子#flex2: 1 &lt;/div&gt;&lt;/div&gt;flex-direction: row | row-reverse | column | column-reverse 当你给父盒子(wrapper)设置属性 flex-direction: row时，flex容器的主轴被定义为与文本方向相同，主轴起点和主轴终点与内容方向相同，简单来说就是主轴沿水平方向向右； 当你给父盒子(wrapper)设置属性 flex-direction: row-reverse时，主轴方向与文本方向相反，因此沿着水平方向向左。 当你给父盒子(wrapper)设置属性 flex-direction: column时，可以看到子盒的布局发生了变化，形成了在Y轴上的布局方式，且书写方式与布局一样。flex容器的主轴和块轴相同，主轴起点与主轴终点和书写模式的前后点相同；主轴变为Y轴方向。 当你给父盒子(wrapper)设置属性 flex-direction: column-reverse；主轴与Y轴方向的书写方向相反。 容器父容器父容器包括justify-content：设置子元素在主轴方向上的对齐方式。 justify-content：flex-start；子元素沿着主轴方向开始对齐； justify-content：flex-end；子元素沿着主轴方向终点对齐 justify-content：center；子元素在主轴方向水平居中； justify-content：space-between；子元素在主轴方向上两端对齐，且项目之间间隔相等； justify-content：space-around；子元素在主轴方向上均匀排列每个元素，每个元素周围分配相同的空间。 align-items：设置子元素在交叉轴方向上的对齐方式。 align-items: flex-start；子元素在交叉轴方向上起点对齐； align-items: flex-end；子元素在交叉轴方向上终点对齐； align-items: center；子元素在交叉轴方向上居中对齐； align-items: baseline；子元素在交叉轴方向上以文字基线对齐； align-items: stretch；默认属性，将占满整个容器的高度。 flex-wrap 设置换行方式 绝对子容器是否可以选择换行，一般而言有三种状态，支持换行的话，也支持逆序换行。 flex-flow 设置轴向与换行组合 是 flex-direction 和 flex-wrap 的简写。 所以只要掌握，flex-direction 和 flex-wrap即可。 align-content 多行沿交叉轴对齐方式 当子容器多行排列时，设置行与行之间的对齐方式。 子容器flex属性定义在主轴是如何伸缩的；1、子容器是有弹性的，它们会自动填充剩余空间，子容器的伸缩比由flex属性决定；2、flex是多个属性的缩写，允许1-3个值的连写。 flex-grow 设置扩展比例 flex-shrink 设置收缩比例 flex-basis 设置基准大小 order 设置排列顺序 align-self属性 单独设置子容器如何沿交叉轴排列；1、每个子容器都可以单独定义沿交叉轴排列方式。2、该属性的取值跟父容器中的align-items属性一致，如果两者相同的话，则以子容器align-self属性为主。 align-self : flex-start；起始端对齐；align-self : flex-end;末尾段对齐；align-self : baseline;基线对齐（第一行文字的基线对齐）；align-self : stretch：拉伸对齐。 SCSS预处理器出现原因：1、CSS无法嵌套书写导致代码繁重、冗杂、逻辑混乱；2、没有变量和样式复用机制，属性值只能以字面量的形式重复输出。 sass支持标准的CSS多行注释以及单行注释，前者会被完整输出到编译后的CSS文件中，而后者不会。 变量与数据类型变量以美元符号开头，赋值方法与CSS属性的写法一样； 在CSS的样式中，直接使用变量的名称即可调用变量。 作用域：变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用，不在嵌套规则内定义的变量则可在任何地方使用（全局变量）；将局部变量转换为全局变量可以添加!global声明。 字符串：有引号字符串和无引号字符串。数字：带单位数字与不带单位数字；单位会和数字当做一个整体，进行算数运算。空值：只有一个值null。布尔值。数组。映射。元素。 嵌套在创建的样式中经常会有重复的标签样式出现，scss提供了更简单的方法来实现选择器。 使用嵌套时调用父选择器:进行伪类样式的处理，一般会看作被嵌套选择器是父选择器的后代，之后再用hover实现伪类。但有时，我们不想使用该关系时，想直接使用父选择器再加上&amp;,这样后续使用&amp; &amp;-text 等价于.nav .nav-text会自动使用父选择器。 12345678910111213141516171819.nav &#123; height: 100px; ul &#123; margin: 0; li &#123; float: left; list-style: none; padding: 5px &#125; a &#123; display: block; color: #000; padding: 5px; &amp;:hover &#123; background &#125; &#125; &#125;&#125; 同样，嵌套除了可以用在样式的规则中，从而减少样式书写中重复的部分，除此之外，样式也可以用于属性中；使用属性的嵌套可以更加简洁。 1234567891011121314body &#123; font: &#123; family: Helvetica, Arial, sans-serif; size: 15px; weight: normal; &#125;&#125;.nav &#123; border: 1px solid #000&#123; left: 0; right: 0; &#125;&#125; mxin混合mixin有点像是JS中的函数mixin；在SCSS中使用mixin用的是 123456789101112131415@mixin 名字（参数1， 参数2...）&#123; ...&#125;@mixin alert($text-color, $background) &#123; color: $text-color; back-ground-color: $background; a &#123; color: darken($text-color, 10%); &#125;&#125;.alert-warning &#123; @include alert(#8a6d3b, #fcf8e3); //@include来使用alert定义的样式&#125; @extend继承扩展用一个选择器去继承另一个选择器中定义的所有样式，避免重复的样式编写。这种继承同时会继承alert里面与其相关的内部嵌套选择器的样式. 1234567891011121314@import &quot;base&quot;;//输入时则不用加上前面的下划线 .alert &#123; padding: 15px;&#125;.alert a &#123; font-weight: bold;&#125;.alert-info &#123; @extend .alert; background-color: &#125; @import便于将一个项目需要的样式分割成不同的小的部分Partials，项目名以下划线开头来提醒其为小部分，浏览器不会去单独编译其为CSS。 数值与字符串SCSS中数值均会包含单位；且提供了一些数字函数来更方便地处理数字。 abs()：返回输入参数的绝对值；round(3.5)：四舍五入函数；ceil(3.2)：进位函数；floor(3.6)：退位函数；percentage(650px / 1000px)：变为百分数；min、max函数 关键字、带引号字符串、不带引号字符串； +可以将两个字符串连接到一块，返回的结果会自带引号；字符串+数字=》字符串； 字符串函数：to-upper-case：变大写；to-lower=-case：变小写；str-length:返回长度 颜色rgb函数：rgb(255, 100, 0)橙色;rgba函数：可以使颜色拥有透明度的设置，0~1，(255, 255, 0, 0.8); HSL函数（色相、饱和度、明度）：hsla(60, 100%, 50%, 0.5); adjust-hue函数，调整色相的值，adjust-hue($base-color-hsl, 137deg)； lighten和darken函数：改变函数的明暗程度，lighten($base-color, 30%); saturate、desaturate:增加或减少颜色的纯度，即饱和度，saturate($base-color, 50%); transparentize、opacify：增加与","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"页面设计","slug":"页面设计","permalink":"http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/"}]},{"title":"TypeScript入门","slug":"前端/TypeScript入门","date":"2020-09-09T12:02:33.000Z","updated":"2020-09-09T12:50:55.841Z","comments":true,"path":"2020/09/09/前端/TypeScript入门/","link":"","permalink":"http://yoursite.com/2020/09/09/%E5%89%8D%E7%AB%AF/TypeScript%E5%85%A5%E9%97%A8/","excerpt":"","text":"TypeScript与JS关系JS是一个动态类型语言，即类型不固定，写起来灵活、自由但后期不太好维护，且出错之后不好去管理与排查。TS便是用来解决JS这方面的问题，在JS基础上加了一些类型特性，类型约束+自动补全+智能提示。 类型系统带来什么：1、接口；2、重载；3、泛型。 TS是为了解决JS在编码过程中，在类型的使用错误问题；解决的方法有很多。关注点不在于增加什么新功能，而是仅仅扩大JS的类型检测、类型设定。 index.d.ts：类型声明文件，","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"ES6新增标准","slug":"前端/ES6新增标准","date":"2020-09-07T09:39:59.000Z","updated":"2020-10-13T10:28:15.320Z","comments":true,"path":"2020/09/07/前端/ES6新增标准/","link":"","permalink":"http://yoursite.com/2020/09/07/%E5%89%8D%E7%AB%AF/ES6%E6%96%B0%E5%A2%9E%E6%A0%87%E5%87%86/","excerpt":"","text":"三大组成部分：ECMAScript；DOM（文档对象模型）：对文档的操作；BOM（浏览器对象模型）：主要包括对浏览器的相关操作； let和constlet、const和var的区别var的特性1、var可以重复声明； 2、var作用域：全局作用域和函数作用域； 3、会进行预解析，但可能造成代码混乱； let的特性1、let在同一作用域下不能进行重复声明； 2、let作用域：全局作用域和块级作用域；if、while、for等有{}的语句，let会考虑在花括号之间的为块级作用域，仅在代码块内部起作用；（与C++类似） 3、不进行预解析；JS有预解析机制，在下面声明而在上面去调用并不会报错，然而使用let声明时不会进行预解析； const的特性1、const为常量，声明时必须赋值，而之后并不能对其进行修改； 2、其他情况与let一样，不能重复声明、不能预解析、为块级作用域。 块级作用域之前在写代码时，为了避免与全局冲突，一般会先声明一个匿名函数，并马上对其调用； 123(function()&#123; &#125;)() 有了块级作用域之后，可以直接用{}来生成代码块，便能直接在代码块里添加代码； 如果在循环之中添加了一个块级作用域，将要如何去处理， 123456789&#123; let lis = document.querySelectorAll(&quot;li&quot;); for (let i = 0; i &lt; lis.length; i++)&#123; lis[i].onclick = function()&#123; console.log(i); &#125; &#125;&#125;//这么写相当于生成了lis.length个代码块，遍历i时每个i的值均声成代码块，循环几次便开辟几个块级作用域； 解构赋值对象的解构赋值对象可以有若干属性，且每个属性方法衷都可以存储数据；当你希望用其他的变量将原变量的属性存储起来，原本的JS写法如下： 123456let obj = &#123; a: 1, b: 2&#125;;let a = obj.a;let b = obj.b; 在ES6的标准下，可以把声明改成这样： 123456let obj = &#123; a: 1, b: 2&#125;;let &#123;a, b, c&#125; = obj;//语法中对象的名字必须与obj里面的属性名称一样，这样才能进行对象解构赋值，故c为undefined 数组的解构赋值对象的解构赋值要求变量名与属性名一致，但数组的话，仅要求顺序必须一致； 12345678let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];let [e, f] = arr;//面试题：如何快速交换a, b值let a = 0;let b = 1;[a, b] = [b, a];//使用数组解构赋值便能快速交换； 字符串的解构赋值123let str = &quot;abc&quot;;let [e, f] = str//其实跟数组一样，根据顺序的索引来解构赋值 展开运算符数组展开12345let arr = [1, 2, 3, 4];let arr2 = [&quot;a&quot;, &quot;b&quot;,...arr,&quot;c&quot;, &quot;d&quot;];//如何简单处理，将两个数组加一起//剩余参数let [a, b,...c] = arr; 对象展开1234567891011let obj = &#123; a:1, b:2&#125;;let obj2 = &#123; ...obj, c:3, d:4&#125;;//不建议对象直接赋给另一个对象，不然一个改变另一个也会改变，因为其本身传递的是一个地址，那么如何来处理呢，用obj解构来代替obj，其本质是所有内容而不是对象的地址let obj2 = &#123;...obj&#125;; set对象set本身是一个函数，用于构建对象，还有Data、Array,调用后返回构造对象，统称构造函数，用于构造某一类型的对象，即对象的实例化。 123456789let arr = [1, 2, 3, 4, 5]let s = new Set(arr);arr = [...s]//arr返回之后便是去重之后的结果s.size//size属性，储存保留之后值得个数s.clear()；//清空s.delete(&quot;a&quot;);//删除某项值s.add(6);//添加某项值s.has();//查看是否包含某个值 Map对象12345678910111213let arr = [ [&quot;a&quot;,1], [&quot;b&quot;,2], [&quot;c&quot;,3]]；let s = new Map(arr);//map结构会存成键值对得形式key-valueclear();//清空所有值delete();//删除某一项//参数：key，数据的key值；返回值，true、false是否删除成功get();//获取某一项值has();//是否包含某一项set(key, val);//设置一个值 函数新增内容箭头函数123456789101112131415161718//function()&#123;return ;&#125;let fn = ()=&gt;&#123; console.log(1);&#125;;fn();//箭头函数，=&gt;//形参=&gt;返回值let fn = nub =&gt; nub *2;//多个形参时，则加括号（形参，形参）=&gt;返回值//()=&gt;返回值,没有参数时也要加上括号// ()=&gt;&#123;// 执行语句// return 返回值// &#125;//箭头函数没有arguments，即不能使用不定参,但可以使用扩展运算符加剩余参数来进行实现不定参数的功能,let fn = (a,b...arg)=&gt;//rest参数存在数组中，即拿到该数组便能拿到剩余参数，其实跟前面的展开运算符一致 123456document,onclick = function()&#123; let fn = ()=&gt;&#123; console.log(this); &#125;; fn();&#125; 使用正常函数时，this指针一般指向windows，但换成箭头函数时，this指针指向document；因为箭头函数本身没有this，调用箭头函数的this时，指向的是其声明时所在的作用域的this； 参数默认值问题:ES6中有简便方法设置参数默认值 123let fn = (a = 2,b = 10)=&gt;&#123; &#125; 数组新增方法日期对象123456789101112131415161718192021222324252627new Date().getTime();//方法属于Date返回的对象的方法,需要对对象进行调用Date.now();//直接使用Date的方法；new Array()Array.from();arr.forEach();//需要区分一下哪些方法是构造函数的本身方法，而哪些方法是需要利用对象来调用的方法//新增方法如下Array.from()//把一个类数组转换成真正的数组，类数组：有下标有length；返回值：转换之后的新数组；是Array构造函数的方法&#123; let lis = document.querySelectorAll(&quot;#list li&quot;); //map是数组方法，因此需要先将lis从类数组变成数组 let arr=[]; lis = Array.from(lis); lis.map(item=&gt;&#123; return item; &#125;); lis = Array.from(lis,(item,index)=&gt;&#123; console.log(item, index); return index; &#125;);&#125;//利用from组成新数组//of方法将放入的元素组成新数组后返回&#123; Array.of(1,2,3,4,&quot;5&quot;);&#125;//isArray方法：判断接收的数据是否是数组，类数组不是数组 数组的find、findIndex1234567891011121314&#123; //find查找数组中满足要求的第一个元素的值 let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]; arr.indexOf(&quot;a&quot;); let arr = [1,2,3,4]; let val = arr.find((item,index)=&gt;&#123; if(item &gt; 3)&#123; return true; &#125; &#125;); val = arr.find(item=&gt; item &gt;= 3); console.log(val); //fingIndex返回数组中满足要求的第一个元素的索引&#125; 数组扁平化处理1234567891011121314151617let arr = &#123; [&quot;小明&quot;，&quot;18&quot;], [&quot;小刚&quot;，&quot;18&quot;],&#125;arr.flat(n);//flat(n)将多维数组转换成低维的数组，向下提取n层;后续传递的参数决定了提取几层//当嵌套多层时，使用flat(Infinity);//提取无限层，确保变为一维数组//利用flatMap来扁平化处理后得到每一项let newArr = arr.flatMap((item,index)=&gt;&#123; cosole.log(item,index); item = item.filter((item,index)=&gt;&#123; return index == 0; &#125;); return item;&#125;);console.log(newArr); flatMap参数：callback回调函数，可以生成一个新数组中元素的参数；可选参数：thisArg，执行callback函数时，使用的this值；返回值：一个包含将数组和子数组中所有元素的数组。 flatMap：只能处理一层的数组，要处理多层的话需要进行if判断是否里面还存在数组，并进行递归操作进行多次扁平化。 12345//fill语句，将数组用...数据填充满，从第几位开始填充，且本身是不修改原数组长度的//includes判断数组中是否包含一个指定的值let arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;];arr.includes(&quot;c&quot;,2);//后面参数代表从第几位开始检索 字符串新增方法12345678910111213let str = &quot;开课吧和面为课堂&quot;；str.startsWith(&quot;开课吧&quot;);//返回一个bool值str.endsWith(&quot;面为课堂&quot;)；str.repeat(30);//模板字符串，如何快速地构造出想要的字符串//$&#123;&#125;插值表达式，可以用值，也可以用函数，适合该值有复杂的逻辑处理let p = document.querySelector(&quot;p&quot;);let name = &quot;小明&quot;;let age = 18;let school = &quot;大学&quot;;p.innerHTML = `今年&lt;strong&gt;$&#123;name&#125;&lt;/strong&gt;就要&lt;strong&gt;$&#123;age&#125;&lt;/strong&gt;岁了，终于升入&lt;strong&gt;$&#123;school&#125;&lt;/strong&gt;了`；//先用``反引号将整个值包起来，在用插值表达式来一个个插入值//模板字符串可以换行 对象新增方法12345678910111213141516171819202122232425let a = 0;let b = 1;let name = &quot;小明&quot;;let obj = &#123; a, b, c()&#123; console.log(&quot;a&quot;); &#125;, [name]: 111;&#125;;//可以直接在obj里面起属性名表达式，可通过变量来给属性名赋值。//对象合并,其实可以使用之前的对象展开来进行合并let obj = &#123; a: 1, b :2&#125;;let obj2 = &#123; c : 3, d :4&#125;;Object.assign(obj2 ，obj);//第一个参数为合并传入的对象//is方法 obj函数下的方法，接受两个值并判断是否一样 Babelbabel是一个JavaScript编译器，用于语法编译，把JS本身不识别、不兼容的语法糖编译成兼容的，babel最简单的使用：将babel引入到页面当中。 1234567891011121314let a = 0;let b = 1;let obj = &#123; a, b, c()&#123; console.log(1); &#125;&#125;;let obj2 = &#123; d: 4, ...obj, e: 5&#125;; PromisePromise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点： 1、对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变； 2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 回调函数一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 其实回调就是一种利用函数指针进行函数调用的过程. 为什么要用回调呢?比如我要写一个子模块给你用,来接收远程socket发来的命令.当我接收到命令后,需要调用你的主模块的函数, 来进行相应的处理.但是我不知道你要用哪个函数来处理这个命令,我也不知道你的主模块是什么.cpp或者.h,或者说,我根本不用关心你在主模块里怎么处理它,也不应该关心用什么函数处理它……怎么办呢？使用回调! 使用回调函数实际上就是在调用某个函数（通常是API函数）时，将自己写的一个函数（这个函数就是回调函数）的地址作为参数传递给那个函数。回调其实就是提供使用某模块的一种方法。回调函数就好比是一个中断处理函数。 在解释这种思想前我想先说明一下，回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。 既然我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢，答案是函数指针（不一定一定是函数指针）也就是使用回调的方式。如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。 123456789101112131415var async=function(callback)&#123; setTimeout(function()&#123; //1秒后回调 callback(&#x27;data&#x27;); &#125;,1000);&#125;;async(function(data)&#123; alert(data);&#125;);var friends = [&quot;Mike&quot;, &quot;Stacy&quot;, &quot;Andy&quot;, &quot;Rick&quot;];friends.forEach(function (eachName, index)&#123;console.log(index + 1 + &quot;. &quot; + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick&#125;); 需要注意的很重要的一点是回调函数并不会马上被执行。它会在包含它的函数内的某个特定时间点被“回调”（就像它的名字一样）。因此，即使第一个jQuery的例子如下所示： 12345//匿名函数不会再参数中被执行//这是一个回调函数 $(&quot;#btn_1&quot;).click(function()&#123; alert(&quot;Btn 1 Clicked&quot;);&#125;); 这个回调函数在包含它的函数内的某一点执行，就好像这个回调函数是在包含它的函数中定义的一样。这意味着回调函数本质上是一个闭包。正如我们所知，闭包能够进入包含它的函数的作用域，因此回调函数能获取包含它的函数中的变量，以及全局作用域中的变量。 回调函数基本原理命名或匿名函数作为回调在前面的jQuery例子以及forEach的例子中，我们使用了再参数位置定义的匿名函数作为回调函数。这是在回调函数使用中的一种普遍的魔术。另一种常见的模式是定义一个命名函数并将函数名作为变量传递给函数。 123456789101112131415161718192021222324252627//全局变量var allUserData = [];//普通的logStuff函数，将内容打印到控制台 function logStuff (userData)&#123; if ( typeof userData === &quot;string&quot;) &#123; console.log(userData); &#125; else if ( typeof userData === &quot;object&quot;)&#123; for(var item in userData)&#123; console.log(item + &quot;: &quot; + userData[item]); &#125; &#125;&#125; //一个接收两个参数的函数，后面一个是回调函数 function getInput (options, callback)&#123; allUserData.push(options); callback(options);&#125;//当我们调用getInput函数时，我们将logStuff作为一个参数传递给它 //因此logStuff将会在getInput函数内被回调（或者执行） getInput(&#123;name:&quot;Rich&quot;,speciality:&quot;Javascript&quot;&#125;, logStuff);//name:Rich//speciality:Javascript 传递参数给回调函数既然回调函数在执行时仅仅是一个普通函数，我们就能给它传递参数。我们能够传递任何包含它的函数的属性（或者全局书讯给）作为回调函数的参数。在前面的例子中，我们将options作为一个参数传递给了毁掉函数。现在我们传递一个全局变量和一个本地变量： 在执行之前确保回调函数是一个函数在调用之前检查作为参数被传递的回调函数确实是一个函数，这样的做法是明智的。同时，这也是一个实现条件回调函数的最佳时间。我们来重构上面例子中的getInput函数来确保检查是恰当的。 123456789function getInput(options, callback)&#123; allUserData.push(options); //确保callback是一个函数 if(typeof callback === &quot;function&quot;)&#123; //调用它，既然我们已经确定了它是可调用的 callback(options); &#125;&#125; 使用this对象的方法作为回调函数时的问题当回调函数是一个this对象的方法时，我们必须改变执行回调函数的方法来保证this对象的上下文。否则如果回调函数被传递给一个全局函数，this对象要么指向全局window对象（在浏览器中）。要么指向包含方法的对象。 12345678910111213141516171819202122232425var clientData = &#123; id: 094545, fullName : &quot;Not Set&quot;, //setUsrName是一个在clientData对象中的方法 setUserName: fucntion (firstName, lastName)&#123; //这指向了对象中的fullName属性 this.fullName = firstName + &quot; &quot; + lastName; &#125;&#125; function getUserInput(firstName, lastName, callback)&#123; //在这做些什么来确认firstName/lastName //现在存储names callback(firstName, lastName);&#125;//在下面你的代码例子中，当clientData.setUsername被执行时，this.fullName并没有设置clientData对象中的fullName属性。相反，它将设置window对象中的fullName属性，因为getUserInput是一个全局函数。这是因为全局函数中的this对象指向window对象//全局函数中的thos都是指向window对象的getUserInput(&quot;Barack&quot;,&quot;Obama&quot;,clientData.setUserName);console.log(clientData,fullName); //Not Set//fullName属性将在window对象中被初始化 console.log(window.fullName); //Barack Obama 使用Call和Apply来保存this使用回调函数时一定要注意由于函数位置的改变，导致的this指针指向位置不同 我们知道了每个Javascript中的函数都有两个方法:Call 和 Apply。这些方法被用来设置函数内部的this对象以及给此函数传递变量。 call接收的第一个参数为被用来在函数内部当做this的对象，传递给函数的参数被挨个传递（当然使用逗号分开）。Apply函数的第一个参数也是在函数内部作为this的对象，然而最后一个参数确是传递给函数的值的数组。 123456789101112//注意到我们增加了新的参数作为回调对象，叫做“callbackObj”function getUserInput(firstName, lastName, callback. callbackObj)&#123; //在这里做些什么来确认名字 callback.apply(callbackObj, [firstName, lastName]);&#125;//我们将clientData.setUserName方法和clientData对象作为参数，clientData对象会被Apply方法使用来设置this对象 getUserName(&quot;Barack&quot;, &quot;Obama&quot;, clientData.setUserName, clientData);//clientData中的fullName属性被正确的设置console.log(clientUser.fullName); //Barack Obama 多重回调函数我们可以将不止一个的回调函数作为参数传递给一个函数，就像我们能够传递不止一个变量一样。 在执行异步代码时，无论以什么顺序简单的执行代码，经常情况会变成许多层级的回调函数堆积 给你的函数命名并传递它们的名字作为回调函数，而不是主函数的参数中定义匿名函数。 模块化L将你的代码分隔到模块中，这样你就可以到处一块代码来完成特定的工作。然后你可以在你的巨型应用中导入模块 Promise基本用法Promise对象是一个构造函数，用来生成Promise实例 1234567891011121314151617181920212223242526272829303132333435363738const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);//Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。//resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。//Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。//Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;);//then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。let promise = new Promise(function(resolve, reject) &#123; console.log(&#x27;Promise&#x27;); resolve();&#125;);promise.then(function() &#123; console.log(&#x27;resolved.&#x27;);&#125;);console.log(&#x27;Hi!&#x27;);// Promise// Hi!// resolved//Promise 新建后就会立即执行，首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面我们写异步加载图片和实现Ajax操作的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error(&#x27;Could not load image at &#x27; + url)); &#125;; image.src = url; &#125;);&#125;//上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); &#125;); return promise;&#125;;getJSON(&quot;/posts.json&quot;).then(function(json) &#123; console.log(&#x27;Contents: &#x27; + json);&#125;, function(error) &#123; console.error(&#x27;出错了&#x27;, error);&#125;);//上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。//如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;)//一个异步操作p2的结果是返回另一个异步操作p1，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;fail&#x27;)), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail//上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。//调用resolve或reject并不会终结 Promise 的参数函数的执行。//一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise的各类方法使用then方法Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 12345678getJSON(&quot;/post/1.json&quot;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function (comments) &#123; console.log(&quot;resolved: &quot;, comments);&#125;, function (err)&#123; console.log(&quot;rejected: &quot;, err);&#125;);//上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数 catch方法Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950getJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;发生错误！&#x27;, error);&#125;);//上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error(&#x27;test&#x27;); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error(&#x27;test&#x27;));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);//这两种写法是等价的，reject()方法的作用等同于抛出错误；//如果promise状态已经变成resolved，再抛出错误是无效的Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了//Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获//一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;);//因为第二种写法可以捕获前面then方法中执行的错误，也·更接近同步的写法（try、catch），因此建议总是使用catch()方法 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 不过，Node.js 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。 一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 finally方法finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 finally本质上是then方法的特例。如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 finally方法的实现： 1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; all方法Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 12345678910111213const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 race方法Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 promise的链式调用12345678910111213141516171819202122232425262728293031function start() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;start&#x27;); &#125;); &#125; start() .then(data =&gt; &#123; // promise start console.log(&#x27;result of start: &#x27;, data); return Promise.resolve(1); // p1 &#125;) .then(data =&gt; &#123; // promise p1 console.log(&#x27;result of p1: &#x27;, data); return Promise.reject(2); // p2 &#125;) .then(data =&gt; &#123; // promise p2 console.log(&#x27;result of p2: &#x27;, data); return Promise.resolve(3); // p3 &#125;) .catch(ex =&gt; &#123; // promise p3 console.log(&#x27;ex: &#x27;, ex); return Promise.resolve(4); // p4 &#125;) .then(data =&gt; &#123; // promise p4 console.log(&#x27;result of p4: &#x27;, data); &#125;); promise俗称链式调用，它是es6中最重要的特性之一简单的说可以不停的then调用嵌套在调用（异步之后，链式调用方式执行回调），这种操作方式称为promise ⑴． resolved（全部置为完成状态） ①.初始化：比如说以国家，省份，县市（china ，jiangshu ，xian）三个方法来演示下链式调用关系（采用setTimeout模拟异步操作） 1234567891011121314151617181920212223242526272829303132333435363738394041424344 function china()&#123; console.log(&#x27;china中国&#x27;) var p =new Promise( function( resolve,reject ) &#123; setTimeout(function()&#123; console.log(&#x27;中国 国家&#x27;) resolve(&#x27;教育大省份&#x27;) &#125;,1000) &#125; ) return p; &#125; function jiangshu(data)&#123; console.log(&#x27;江苏&#x27;+data); var p=new Promise(function(resolve,reject)&#123; setTimeout(function ()&#123; console.log(&#x27;江苏 省份&#x27;) resolve(&#x27;地级市&#x27;); &#125;,2000) &#125;) return p; &#125; function xian(data)&#123; console.log(&#x27;盱眙县&#x27;+data) var p=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(&#x27;盱眙县&#x27;); resolve (&#x27;淮河镇&#x27;) &#125;,2000) &#125;) return p; &#125;china ().then(jiangshu).then(xian).then(function(data)&#123; console.log(data)&#125;)/*输出：china 中国中国 国家江苏教育大省份江苏 省份盱眙县地级市盱眙县淮河镇 \\rejected（部分置为无效状态）** ①.初始化：同样的以上述的函数为例 1234567891011121314151617181920212223242526272829303132333435363738function china()&#123; console.log(&#x27;china中国&#x27;) var p =new Promise( function( resolve,reject ) &#123; setTimeout(function()&#123; console.log(&#x27;中国 国家&#x27;) reject(&#x27;教育大省份&#x27;) &#125;,1000) &#125; ) return p; &#125; function jiangshu(data)&#123; console.log(&#x27;江苏是&#x27;+data); varp=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(&#x27;江苏 省份&#x27;) resolve(&#x27;地级市&#x27;); &#125;,2000) &#125;) returnp; &#125;//函数写完之后，就开始结合then来链式调用了china() .then(jiangshu,function(data)&#123; console.log(data)&#125;) // 等同于（null不执行） china() .then(null,function(data)&#123; console.log(data)&#125;) //等同于（直接执行catch回调，抛出异常，页面也不会卡死，直接走catch） china() .then(jiangshu).catch(function(data)&#123;console.log(data)&#125;)//(备注：为reject的时候，执行then的第二个参数回调，不会执行jiangshu)//控制台输出：china 中国//中国 国家//教育大省份","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"深入探究JavaScript","slug":"前端/深入探究JavaScript","date":"2020-09-06T13:28:16.000Z","updated":"2020-10-26T11:54:36.743Z","comments":true,"path":"2020/09/06/前端/深入探究JavaScript/","link":"","permalink":"http://yoursite.com/2020/09/06/%E5%89%8D%E7%AB%AF/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6JavaScript/","excerpt":"","text":"JS方法/函数重载的姿势JavaScript不支持重载的语法，它没有重载所需要的函数签名。 ECMAScript函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。 — JavaScript高级程序设计（第3版）3.7.2小节 在JavaScript中，函数名本身就是变量，函数声明类似于变量赋值。当同个函数名被多次声明时，后声明的内容将覆盖前面的内容。尽管JavaScript无法做到真正的重载，但是可以通过检查传入函数中参数的类型和数量并作相应的处理，从而实现重载的效果，曲线救国。 借助流程控制语句通过判断传入参数的数量（arguments.length），执行相应的代码块。 巧用闭包特性1234var ninja = &#123;&#125;;addMethod(ninja, &#x27;whatever&#x27;, function()&#123;/* code */&#125;);addMethod(ninja, &#x27;whatever&#x27;, function(a)&#123;/* code */&#125;);addMethod(ninja, &#x27;whatever&#x27;, function(a,b)&#123;/* code */&#125;); addMethod函数接收3个参数：目标对象、目标方法名、函数体，当函数被调用时： 先将目标object[name]的值存入变量old中，因此起初old中的值可能不是一个函数；接着向object[name]赋值一个代理函数，并且由于变量old、fn在代理函数中被引用，所以old、fn将常驻内存不被回收。 123456789101112function addMethod(object, name, fn) &#123; var old = object[name]; // 保存前一个值，以便后续调用 object[name] = function()&#123; // 向object[name]赋值一个代理函数 // 判断fn期望接收的参数与传入参数个数是否一致 if (fn.length == arguments.length) // 若是，则调用fn return fn.apply(this, arguments) else if (typeof old == &#x27;function&#x27;) // 若否，则判断old的值是否为函数 // 若是，则调用old return old.apply(this, arguments); &#125;;&#125; 代理函数被调用时： 先判断传入参数与其父级作用域中fn期望接收参数的个数是否一致，若是则调用该fn； 若否，则判断其父级作用域中old值类型是否为函数，若是则调用该old； 当old中存有上一次生成的代理函数时，则会重复前面两个步骤，直至old值不为代理函数。 上述两种方法都是通过检查参数个数来实现重载，不区分参数类型。此外，方法1在继承时重载的那些函数无法被重写，而方法2通过逐个执行代理函数，比对参数个数，直至找到目标函数，效率不高。 巧用引用类型特性核心思想：由于ECMAScript函数是一种引用类型对象，可扩展属性与方法。借此通过创建一个容器用于存储要重载的函数，并将容器挂载到代理函数上以便后续访问，而代理函数利用闭包特性访问容器。 重载顺序：首先查找参数类型匹配的函数，其次查找参数个数匹配的函数。 存储格式：键值对，键名由逗号与参数个数或参数类型组成，键值为要重载的函数，如下： 12345&#123; &#x27;,0&#x27;: function()&#123;/* code */&#125;, &#x27;,1&#x27;: function(a)&#123;/* code */&#125;, &#x27;,string,number&#x27;: function(a,b)&#123;/* code */&#125;&#125; 工具函数被调用时： 先判断是否已重载过，若有，直接将要重载的函数按格式存入容器； 若未重载过，则创建一个容器变量； 判断未重载前的值是否为一个函数，若是，则以逗号+参数个数的格式存入容器； 将要重载的函数存入容器； 代理原函数，并将容器挂载到代理函数上； 当代理函数被调用时，将依次查找容器中匹配的函数并调用。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 重载工具函数 * @param &#123;Object&#125; ctx - 上下文 * @param &#123;String&#125; name - 函数名 * @param &#123;Function&#125; fn - 函数体 * @param &#123;String&#125; type - 参数类型 * @author 范围兄 &lt;ambit_tsai@qq.com&gt; * @example 不指定参数类型 * overload(obj, &#x27;do&#x27;, function()&#123;...&#125;); * overload(obj, &#x27;do&#x27;, function(a)&#123;...&#125;); * @example 指定参数类型 * overload(obj, &#x27;do&#x27;, function(a,b)&#123;...&#125;, &#x27;string,number&#x27;); */function overload(ctx, name, fn, type)&#123; type = type? type.trim().toLowerCase(): fn.length; // 已重载过 if(typeof ctx[name]===&#x27;function&#x27; &amp;&amp; typeof ctx[name]._$fnMap===&#x27;object&#x27;)&#123; ctx[name]._$fnMap[&#x27;,&#x27;+type] = fn; // 将fn存入_$fnMap return; &#125; // 未重载过 var fnMap = &#123;&#125;; // 容器 if(typeof ctx[name] === &#x27;function&#x27;)&#123; // 若ctx[name]是一个函数，则存入容器 fnMap[&#x27;,&#x27;+ctx[name].length] = ctx[name]; &#125; fnMap[&#x27;,&#x27;+type] = fn; ctx[name] = function overloading()&#123; // 代理 var args = arguments, len = args.length, type, i; for(i=0, type=&#x27;&#x27;; i&lt;len; ++i)&#123; // 计算参数类型 type += &#x27;,&#x27; + typeof args[i]; &#125; // 依次匹配：参数类型-&gt;参数个数 if(fnMap[type]) return fnMap[type].apply(this, args); if(fnMap[&#x27;,&#x27;+len]) return fnMap[&#x27;,&#x27;+len].apply(this, args); throw &#x27;Overload: no matched function&#x27;; &#125;; ctx[name]._$fnMap = fnMap; // 将fnMap挂载到代理上&#125; JS异步操作的方法回调函数回调函数是异步编程中最基本的方法。假设有三个函数f1、f2、f3，f2需要等待f1的执行结果，而f3是独立的，不需要f1和f2的结果，如果我们写成同步，就是这样的： 12 f1(); f2(); f3() 如果f1执行的很快，可以； 但是如果f1执行的很慢，那么f2和f3就会被阻塞，无法执行。这样的效率是非常低的。但是我们可以改写，将f2写成是f1的回调函数，如下： 123456 function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000); &#125; 那么这时候执行代码就是这样： 12f1(f2);f3() 这样，就是一个异步的执行了，即使f1很费时间，但是由于是异步的，那么f3()就会很快的得到执行，而不会受到f1和f2的影响。 注意： 如果我们把f1写成这样呢？ 1234function f1(callback)&#123; // f1的任务代码 callback();&#125; 然后，我们同样可以这么调用： 12f1(f2);f3() 这时候还是异步的吗？ 答案：不是异步。 这里的回调函数并非真正的回调函数，如果没有利用setTimeout含函数，那么f3()的执行同样需要等到f1(f2)完全执行完毕，这里要注意。而我们就是利用setTImeout才能做出真正的回调函数。 事件监听另一种异步的思路是采用事件驱动模式。任务的执行不取决于代码的顺序， 而取决于某个事件是否发生。 还是以f1、f2、f3为例子。 首先，为f1绑定一个事件（这里采用jquery的写法）： 12f1.on(&#x27;done&#x27;, f2);f3() 这里的意思是： 当f1发生了done事件，就执行f2， 然后，我们对f1进行改写： 123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger(&#x27;done&#x27;); &#125;, 1000); &#125; f1.trigger(‘done’)表示， 执行完成后，立即触发done事件，从而开始执行f2。 这种方法的优点就是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化，缺点就是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布订阅第二种方法的事件，实际上我们完全可以理解为“信号”，即f1完成之后，触发了一个 ‘done’，信号，然后再开始执行f2。 我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”这个信号， 从而知道什么时候自己可以开始执行。 这个就叫做“发布/订阅模式”， 又称为“观察者”模式 。 这个模式有多种实现， 下面采用Ben Alman的Tiny PUb/Sub，这是jQuery的一个插件。 首先，f2向”信号中心”jquery订阅”done”信号， 1jQuery.subscribe(&quot;done&quot;, f2); 然后，f1进行如下改写： 123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(&quot;done&quot;); &#125;, 1000); &#125; jquery.pushlish(“done”)的意思是： f1执行完成后，向“信号中心”jQuery发布“done”信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（unsubscribe）。 1 jQuery.unsubscribe(&quot;done&quot;, f2); 这种方法的性质和“事件监听”非常类似，但是明显是优于前者的，因为我们可以通过查看“消息中心”，了解到存在多少信号、每个信号有多少个订阅者，从而监控程序的运行。 promise对象promise是commonjs工作组提出来的一种规范，目的是为异步编程提供统一接口。 简答的说，它的思想是每一个异步任务返回一个promise对象，该对象有一个then方法，允许指定回调函数。 比如,f1的回调函数f2，可以写成： 1f1().then(f2); f1要进行下面的改写（这里使用jQuery的实现）： 12345678 function f1()&#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise; &#125; 这样的优点在于，回调函数编程了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现很多强大的功能 。 如：指定多个回调函数： 1 f1().then(f2).then(f3); 再比如，指定发生错误时的回调函数： 1f1().then(f2).fail(f3); 而且，他还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。 所以，你不用担心是否错过了某个事件或者信号，这种方法的确定就是编写和理解，都比较困难。 generator函数的异步应用而generator函数将JavaScript异步编程带入了一个全新的阶段！ 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 协程 传统的编程语言中，早就有了异步编程的解决方案，其中一种叫做协程，意思是多个线程互相协作，完成异步任务。 协程优点像函数，又有点像线程，运行流程如下： 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面的协程A，就是异步任务，因为它分为两段（或者多段）执行。 举例来说，读取文件的协程写法如下： 12345function *asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面代码的函数asyncJob是一个协程，奥妙就在于yield命令， 它表示执行到此处，执行权交给其他协程，也就是说yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续向后执行，它的最大优点就是代码的写法非常像同步操作，如果去除yield命令，简直是一模一样。 协程的Generator函数实现 Generator函数是协程在ES6中的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个Generator函数就是一个封装的异步任务，或者说异步任务的容器。 异步任务需要暂停的地方，都用yield语句注明。 如下： 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; 在调用gen函数时 gen(1)， 会返回一个内部指针（即遍历器）g。 这是Generator函数不同于普通函数的另一个地方，即执行它（调用函数）不会返回结果， 返回的一个指针对象 。调用指针g的next方法，会移动内部指针（即执行异步任务的第一阶段），指向第一个遇到的yield语句，这里我们是x + 2，但是实际上这里只是举例，实际上 x + 2 这句应该是一个异步操作，比如ajax请求。 换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。 value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。 Generator函数的数据交换和错误处理 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的value属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 12345678function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; 上面代码中，第一next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的value属性，返回的就是2（变量y的值）。 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw(&#x27;出错了&#x27;);// 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装**下面看看如何使用 Generator 函数，执行一个真实的异步任务。** 1234567var fetch = require(&#x27;node-fetch&#x27;);function* gen()&#123; var url = &#x27;https://api.github.com/users/github&#x27;; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 1234567891011function* gen(x) &#123; yield 1; yield 2; yield 3; return 4;&#125;var a = gen();console.log(a.next());console.log(a.next());console.log(a.next());console.log(a.next()); 最终，打印台输出 即开始调用gen()，并没有真正的调用，而是返回了一个生成器对象，a.next()的时候，执行第一个yield，并立刻暂停执行，交出了控制权； 接着，我们就可以去a.next() 开始恢复执行。。。 如此循环往复。 每当调用生成器对象的next的方法时，就会运行到下一个yield表达式。 之所以称这里的gen（）为生成器函数，是因为区别如下： 普通函数使用function来声明，而生成器函数使用 function * 来声明。 普通函数使用return来返回值，而生成器函数使用yield来返回值。 普通函数式run to completion模式 ，即一直运行到末尾； 而生成器函数式 run-pause-run 模式， 函数可以在执行过程中暂停一次或者多次。并且暂停期间允许其他代码执行。 async/awaitasync函数基于Generator又做了几点改进： 内置执行器，将Generator函数和自动执行器进一步包装。 语义更清楚，async表示函数中有异步操作，await表示等待着紧跟在后边的表达式的结果。 适用性更广泛，await后面可以跟promise对象和原始类型的值(Generator中不支持) 很多人都认为这是异步编程的终极解决方案，由此评价就可知道该方法有多优秀了。它基于Promise使用async/await来优化then链的调用,其实也是Generator函数的语法糖。 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。 await得到的就是返回值，其内部已经执行promise中resolve方法，然后将结果返回。使用async/await的方式写回调任务： 1234567891011async function dolt()&#123; console.time(&#x27;dolt&#x27;); const time1=300; const time2=await step1(time1); const time3=await step2(time2); const result=await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&#x27;dolt&#x27;);&#125;dolt(); 可以看到，在使用await关键字所在的函数一定要是async关键字修饰的。 功能还很新，属于ES7的语法，但使用Babel插件可以很好的转义。另外await只能用在async函数中，否则会报错 JS的事件执行机制一、js的内存模型 二、js代码执行机制： 所有同步任务都在主线程上的栈中执行。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，选择出需要首先执行的任务（由浏览器决定，并不按序）。 三、宏任务与微任务： MacroTask（宏观Task） setTimeout, setInterval, , requestAnimationFrame（请求动画）, I/O MicroTask（微观任务） process.nextTick, Promise, Object.observe, MutationObserver 先同步 再取出第一个宏任务执行 所有的相关微任务总会在下一个宏任务之前全部执行完毕 如果遇见 就 先微后宏 案例一：（在主线程上添加宏任务）123456789console.log(1)setTimeout(function () &#123; console.log(2);&#125;,0)console.log(3) //1 3 2 先看代码：一个打印，一个定时器，一个打印 因为定时器是异步操作，又是宏任务，所以先执行第一个打印，接着将setTimeout放入宏任务队列，接着执行第二个打印，再执行宏任务队列中的setTimeout 案例二：（在主线程上添加微任务）12345678console.log(1) new Promise(function(resolve,reject)&#123; console.log(&#x27;2&#x27;) resolve() &#125;).then(function()&#123; console.log(3) &#125;) console.log(4) //1 2 4 3 先看代码：一个打印，一个new promise,一个promise.then，一个打印 因为new promise会立即执行，promise.then是异步操作且是微任务 所以，先执行第一个打印，执行new Promise，将promise.then放入微任务队列，接着执行第二个打印，再执行微任务队列中的promise.then 案例三：（宏任务中创建微任务）12345678910111213141516171819202122232425262728293031console.log(&#x27;1&#x27;); setTimeout(function () &#123; console.log(&#x27;2&#x27;); new Promise(function (resolve) &#123; console.log(&#x27;3&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;4&#x27;) &#125;) &#125;,0) new Promise(function (resolve) &#123; console.log(&#x27;5&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;6&#x27;) &#125;) setTimeout(function () &#123; console.log(&#x27;7&#x27;); new Promise(function (resolve) &#123; console.log(&#x27;8&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;9&#x27;) &#125;) console.log(&#x27;10&#x27;) &#125;,0) console.log(&#x27;11&#x27;) // 1 5 11 6 2 3 4 7 8 10 9 先看代码：一个打印，第一个定时器，一个new promise,一个promise.then,第二个定时器，一个打印 定时器是异步操作，又是宏任务，\\promise.then是异步操作且是微任务**** 所以，先执行第一个打印（1），将第一个定时器放入宏任务队列，执行new Promise（5），将promise.then放入微任务队列，将第二个定时器放入宏任务队列，执行打印（11）； 主线程上的代码执行完毕后，看是否有微任务？此时：微任务队列中有一个promise.then,执行它（6）；微任务执行完毕看宏任务队列； 此时宏任务队列中两个定时器，延时都是0秒，所以按顺序执行就ok,先执行第一个定时器 第一个定时器中：一个打印，一个mew promise,一个promise.then(微任务)；**（宏任务中包含微任务，一定要将宏任务中的微任务执行完，再去执行下一个宏任务）** 先执行打印（2），再执行new promise(3),**再执行promise.then(**4);第一个宏任务执行完，执行第二个宏任务（第二个定时器） 第二个定时器中：一个打印，一个new promise，一个promise.then(微任务),一个打印 先执行第一个打印（7），再执行new promise(8),再执行第二个打印（10），在执行promise.then（9） 案例四：（微任务中创建宏任务）12345678910111213new Promise((resolve) =&gt; &#123; console.log(&quot;1&quot;) resolve() &#125;).then(() =&gt; &#123; console.log(&quot;2&quot;) setTimeout(() =&gt; &#123; console.log(&quot;3&quot;) &#125;,0) &#125;) setTimeout(() =&gt; &#123; console.log(&quot;4&quot;) &#125;,1000) console.log(&quot;5&quot;) //1 5 2 3 4 先看代码：一个new promise,（一个then,一个定时器（0秒）），一个定时器（1秒），一个打印 微任务中有宏任务，则将宏任务放入宏任务队列任务中 先执行new promise(1),再将promise.then放入微任务队列，将定时器放入宏任务队列（0秒），将定时器放入宏任务队列（1秒），执行打印(5) 接着看微任务队列，执行promise.then(2);微任务队列中都执行完再看宏任务队列 宏任务队列中两个定时器，一个延时0秒，一个延时1秒，所以先执行延时0秒的那个 第一个定时器：执行（3）； 第二个定时器：执行（4） JS事件执行本文是承接Promise来说的，大家都知道，JavaScript脚本是单线程的语言，虽然有H5的Web-Worker加持，但是创建出来的子线程完全受主线程控制，且不得操作DOM，所以还是无法改变JavaScript单线程的本质 JavaScript是单线程执行的，无法同时执行多段代码。当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列。一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是Ajax请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。假如当前JavaScript线程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于JavaScript 线程是拥挤还是空闲。 这里就涉及到了执行栈(Stack)和队列任务(Queue Task)的概念，将同步任务都放入主线程的Stack当中，将异步和延时的任务都放入Event Queue里面等待执行，Event Queue即为事件队列，所包含的全是事件，等执行栈为空之后就代表主线程执行完毕，再去Event Queue中读取第一个事件放入主线程，执行完毕再读取第二个…因此形成一个JavaScript的Event Loop(事件循环)，Event Loop就是JavaScript的实现异步的一种方式，也是JavaScript的执行机制。 至于定时器(timer)嘛，因为里面的参数有一个是回调函数，另一个是延时执行的毫秒数，所以他也要放进队列中，而上面的引用部分有个延时0毫秒，它的含义就是立即放入队列，而不是立即放进执行栈执行；JavaScript还有一种函数叫做回调函数，阮一峰大神是这么说的： 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 下面这幅图是从别人那里偷来的(ps:主要这幅图太有说服力度了，不信你看)： ![img](https:////upload-images.jianshu.io/upload_images/8560482-92ec4b6e10c45e30.png?imageMogr2/auto-orient/strip|imageView2/2/w/601/format/webp nodeJs里面提出了和任务队列有关联的方法process.nextTick(callback)，它的含义是本次循环完毕等到下一次循环开始再执行，也就是在当前执行栈的尾部。 在网上经常看到这样的关键字，从广义上来讲，我们弄明白了同步异步，但是狭义上来说还有两个新的概念，其实这个概念我还真不确定官方是否同意，我是看到闹闹不爱闹在掘金中阐明的: 宏任务macro task [ˈmækrəʊ]：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。exp:script（全局任务），setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 微任务micro task [ˈmaɪkrəʊ]： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。exp:process.nextTick，promise,Object.observer,MutationObserver 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 不管这个东西存不存在，既然国人都这么叫了，那我是这么理解的： 他们口中的宏观任务就是我们的回调函数，宏观任务和微观任务就是我们的Event Queue，执行栈执行完毕会执行微观任务再执行宏观任务，我不建议大家继续这么称呼，其实macro task和micro task都属于是浏览器执行js的执行机制，这个我不是为了较真，估计我也是被我们公司的老总教训的太多了，不去不去怕了怕了o((⊙﹏⊙))o…. 12345678910111213setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;);Promise.resolve(function () &#123; console.log(&#x27;resolve&#x27;);&#125;);new Promise(function(resolve) &#123; console.log(&#x27;promise&#x27;); resolve();&#125;).then(function() &#123; console.log(&#x27;then&#x27;);&#125;);console.log(&#x27;console&#x27;); 其实这个栗字很简单，进入script主线程，遇到setTimeout push到macro task，遇到resolve push到macro task，new Promise立即执行，率先打印，then push到micro task，接着第二个打印console，然后执行micro task打印出then，接着执行macro task打印出setTimeout，因为Promise.resolve这个回到函数未调用，有的浏览器报undefined，有的不打印。 到了这里就差不多了，为了帮助大家彻底吃透它，再来一剂猛药： 12345678910111213141516171819202122232425262728293031323334console.log(&#x27;1&#x27;);setTimeout(() =&gt; &#123; console.log(&#x27;9&#x27;); this.$nextTick(() =&gt; &#123; console.log(&#x27;11&#x27;); &#125;); new Promise(function(resolve) &#123; console.log(&#x27;10&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;12&#x27;) &#125;);&#125;,5000);this.$nextTick(() =&gt; &#123; console.log(&#x27;3&#x27;);&#125;);new Promise(function(resolve) &#123; console.log(&#x27;2&#x27;); resolve();&#125;).then(function() &#123; console.log(&#x27;4&#x27;);&#125;);setTimeout(() =&gt; &#123; console.log(&#x27;5&#x27;); this.$nextTick(() =&gt; &#123; console.log(&#x27;7&#x27;); &#125;); new Promise(function(resolve) &#123; console.log(&#x27;6&#x27;); resolve(); &#125;).then(function() &#123; console.log(&#x27;8&#x27;); &#125;);&#125;); 看到诸多异步延时任务先不要慌，一步一步来解读，代码中的this.$nextTick(callback)千万不要解读成上面的process.nextTick(callback)，否则你会被坑惨的，process是nodeJs里面的，nodeJs执行机制和JavaScript的执行机制是不同的，nodeJs不会看你代码的层级关系哦，只关心你的事件的类型，按照这个顺序来执行代码，而我们的js是按照父级的事件，有着层级关系的执行。 vueJs的主线程先执行，首先打印出1，第一个setTimeout push到macro task，nextTick放入micro task，Promise立即执行，then push进micro task，第二个setTimeout push到macro task，接着执行micro task，打印3 4，最后执行macro task，注意这里有个坑，macro task里面有两个timer，第一个5000ms之后执行，所以先执行第二个，所以最后的答案小学生都知道，打印顺序从1到12。 防抖函数一、函数为什么要防抖有如下代码 123window.onresize = () =&gt; &#123; console.log(&#x27;触发窗口监听回调函数&#x27;)&#125; 当我们在PC上缩放浏览器窗口时，一秒可以轻松触发30次事件。手机端触发其他Dom时间监听回调时同理。 这里的回调函数只是打印字符串，如果回调函数更加复杂，可想而知浏览器的压力会非常大，用户体验会很糟糕。 resize或scroll等Dom事件的监听回调会被频繁触发，因此我们要对其进行限制。 二、实现思路函数去抖简单来说就是对于一定时间段的连续的函数调用，只让其执行一次，初步的实现思路如下： 第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。 三、Debounce 应用场景 每次 resize/scroll 触发统计事件 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好） 四、函数防抖最终版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function debounce(method, wait, immediate) &#123; let timeout // debounced函数为返回值 // 使用Async/Await处理异步，如果函数异步执行，等待setTimeout执行完，拿到原函数返回值后将其返回 // args为返回函数调用时传入的参数，传给method let debounced = function(...args) &#123; return new Promise (resolve =&gt; &#123; // 用于记录原函数执行结果 let result // 将method执行时this的指向设为debounce返回的函数被调用时的this指向 let context = this // 如果存在定时器则将其清除 if (timeout) &#123; clearTimeout(timeout) &#125; // 立即执行需要两个条件，一是immediate为true，二是timeout未被赋值或被置为null if (immediate) &#123; // 如果定时器不存在，则立即执行，并设置一个定时器，wait毫秒后将定时器置为null // 这样确保立即执行后wait毫秒内不会被再次触发 let callNow = !timeout timeout = setTimeout(() =&gt; &#123; timeout = null &#125;, wait) // 如果满足上述两个条件，则立即执行并记录其执行结果 if (callNow) &#123; result = method.apply(context, args) resolve(result) &#125; &#125; else &#123; // 如果immediate为false，则等待函数执行并记录其执行结果 // 并将Promise状态置为fullfilled，以使函数继续执行 timeout = setTimeout(() =&gt; &#123; // args是一个数组，所以使用fn.apply // 也可写作method.call(context, ...args) result = method.apply(context, args) resolve(result) &#125;, wait) &#125; &#125;) &#125; // 在返回的debounced函数上添加取消方法 debounced.cancel = function() &#123; clearTimeout(timeout) timeout = null &#125; return debounced&#125; 需要注意的是，如果需要原函数返回值，调用防抖后的函数的外层函数需要使用Async/Await语法等待执行结果返回 使用方法见代码： 1234567891011121314151617function square(num) &#123; return Math.pow(num, 2)&#125;let debouncedFn = debounce(square, 1000, false)window.addEventListener(&#x27;resize&#x27;, async () =&gt; &#123; let val try &#123; val = await debouncedFn(4) &#125; catch (err) &#123; console.error(err) &#125; // 停止缩放1S后输出： // 原函数的返回值为：16 console.log(`原函数返回值为$&#123;val&#125;`)&#125;, false) 具体的实现步骤请往下看 五、Debounce 的实现1. 《JavaScript高级程序设计》（第三版）中的实现123456789101112function debounce(method, context) &#123; clearTimeout(method.tId) method.tId = setTimeout(() =&gt; &#123; method.call(context) &#125;, 1000)&#125;function print() &#123; console.log(&#x27;Hello World&#x27;)&#125;window.onresize = debounce(print) 我们不停缩放窗口，当停止1S后，打印出Hello World。 有个可以优化的地方: 此实现方法有副作用（Side Effect），改变了输入\b值（method），给method新增了属性 2. 优化第一版：消除副作用，将定时器隔离1234567891011function debounce(method, wait, context) &#123; let timeout return function() &#123; if (timeout) &#123; clearTimeout(timeout) &#125; timeout = setTimeout(() =&gt; &#123; method.call(context) &#125;, wait) &#125;&#125; 3. 优化第二版：自动调整this正确指向\b之前的函数我们需要手动传入函数执行上下文context，现在优化将 this 指向正确的对象。 12345678910111213function debounce(method, wait) &#123; let timeout return function() &#123; // 将method执行时this的指向设为debounce返回的函数被调用时的this指向 let context = this if (timeout) &#123; clearTimeout(timeout) &#125; timeout = setTimeout(() =&gt; &#123; method.call(context) &#125;, wait) &#125;&#125; 4. 优化第三版：函数可传入参数即便我们的函数不需要传参，但是别忘了JavaScript 在事件处理函数中会提供事件对象 event，所以我们要实现传参功能。 123456789101112131415function debounce(method, wait) &#123; let timeout // args为返回函数调用时传入的参数，传给method return function(...args) &#123; let context = this if (timeout) &#123; clearTimeout(timeout) &#125; timeout = setTimeout(() =&gt; &#123; // args是一个数组，所以使用fn.apply // 也可写作method.call(context, ...args) method.apply(context, args) &#125;, wait) &#125;&#125; 5. 优化第四版：提供立即执行选项有些时候我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发n毫秒后，才可以重新触发执行。 12345678910111213141516171819202122232425262728function debounce(method, wait, immediate) &#123; let timeout return function(...args) &#123; let context = this if (timeout) &#123; clearTimeout(timeout) &#125; // 立即执行需要两个条件，一是immediate为true，二是timeout未被赋值或被置为null if (immediate) &#123; // 如果定时器不存在，则立即执行，并设置一个定时器，wait毫秒后将定时器置为null // 这样确保立即执行后wait毫秒内不会被再次触发 let callNow = !timeout timeout = setTimeout(() =&gt; &#123; timeout = null &#125;, wait) if (callNow) &#123; method.apply(context, args) &#125; &#125; else &#123; // 如果immediate为false，则函数wait毫秒后执行 timeout = setTimeout(() =&gt; &#123; // args是一个类数组对象，所以使用fn.apply // 也可写作method.call(context, ...args) method.apply(context, args) &#125;, wait) &#125; &#125;&#125; 6. 优化第五版：提供取消功能有些时候我们需要在不可触发的这段时间内能够手动取消防抖，代码实现如下： 12345678910111213141516171819202122232425262728293031function debounce(method, wait, immediate) &#123; let timeout // 将返回的匿名函数赋值给debounced，以便在其上添加取消方法 let debounced = function(...args) &#123; let context = this if (timeout) &#123; clearTimeout(timeout) &#125; if (immediate) &#123; let callNow = !timeout timeout = setTimeout(() =&gt; &#123; timeout = null &#125;, wait) if (callNow) &#123; method.apply(context, args) &#125; &#125; else &#123; timeout = setTimeout(() =&gt; &#123; method.apply(context, args) &#125;, wait) &#125; &#125; // 加入取消功能，使用方法如下 // let myFn = debounce(otherFn) // myFn.cancel() debounced.cancel = function() &#123; clearTimeout(timeout) timeout = null &#125;&#125; 至此，我们已经比较完整地实现了一个underscore中的debounce函数。 六、遗留问题需要防抖的函数可能是存在返回值的，我们要对这种情况进行处理，underscore的处理方法是将函数返回值在返回的debounced函数内再次返回，但是这样其实是有问题的。如果参数immediate传入值不为true的话，当防抖后的函数第一次被触发时，如果原始函数有返回值，其实是拿不到返回值的，因为原函数是在setTimeout内，是异步延迟执行的，而return是同步执行的，所以返回值是undefined。 第二次触发时拿到的返回值其实是第一次执行的返回值，第三次触发时拿到的返回值其实是第二次执行的返回值，以此类推。 1. 使用回调函数处理函数返回值123456789101112131415161718192021222324252627282930313233function debounce(method, wait, immediate, callback) &#123; let timeout, result let debounced = function(...args) &#123; let context = this if (timeout) &#123; clearTimeout(timeout) &#125; if (immediate) &#123; let callNow = !timeout timeout = setTimeout(() =&gt; &#123; timeout = null &#125;, wait) if (callNow) &#123; result = method.apply(context, args) // 使用回调函数处理函数返回值 callback &amp;&amp; callback(result) &#125; &#125; else &#123; timeout = setTimeout(() =&gt; &#123; result = method.apply(context, args) // 使用回调函数处理函数返回值 callback &amp;&amp; callback(result) &#125;, wait) &#125; &#125; debounced.cancel = function() &#123; clearTimeout(timeout) timeout = null &#125; return debounced&#125; 这样我们就可以在函数防抖时传入一个回调函数来处理函数的返回值，使用代码如下： 1234567891011121314function square(num) &#123; return Math.pow(num, 2)&#125;let debouncedFn = debounce(square, 1000, false, val =&gt; &#123; console.log(`原函数的返回值为：$&#123;val&#125;`)&#125;)window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; debouncedFn(4)&#125;, false)// 停止缩放1S后输出：// 原函数的返回值为：16 2. 使用Promise处理返回值123456789101112131415161718192021222324252627282930313233343536function debounce(method, wait, immediate) &#123; let timeout, result let debounced = function(...args) &#123; // 返回一个Promise，以便可以使用then或者Async/Await语法拿到原函数返回值 return new Promise(resolve =&gt; &#123; let context = this if (timeout) &#123; clearTimeout(timeout) &#125; if (immediate) &#123; let callNow = !timeout timeout = setTimeout(() =&gt; &#123; timeout = null &#125;, wait) if (callNow) &#123; result = method.apply(context, args) // 将原函数的返回值传给resolve resolve(result) &#125; &#125; else &#123; timeout = setTimeout(() =&gt; &#123; result = method.apply(context, args) // 将原函数的返回值传给resolve resolve(result) &#125;, wait) &#125; &#125;) &#125; debounced.cancel = function() &#123; clearTimeout(timeout) timeout = null &#125; return debounced&#125; 使用方法一：在调用防抖后的函数时，使用then拿到原函数的返回值 1234567891011121314function square(num) &#123; return Math.pow(num, 2)&#125;let debouncedFn = debounce(square, 1000, false)window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; debouncedFn(4).then(val =&gt; &#123; console.log(`原函数的返回值为：$&#123;val&#125;`) &#125;)&#125;, false)// 停止缩放1S后输出：// 原函数的返回值为：16 使用方法二：调用防抖后的函数的外层函数使用Async/Await语法等待执行结果返回 使用方法见代码： 123456789101112131415161718function square(num) &#123; return Math.pow(num, 2)&#125;let debouncedFn = debounce(square, 1000, false)window.addEventListener(&#x27;resize&#x27;, async () =&gt; &#123; let val try &#123; val = await debouncedFn(4) &#125; catch (err) &#123; console.error(err) &#125; console.log(`原函数返回值为$&#123;val&#125;`)&#125;, false)// 停止缩放1S后输出：// 原函数的返回值为：16","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"探究语言逻辑","slug":"探究语言逻辑","permalink":"http://yoursite.com/tags/%E6%8E%A2%E7%A9%B6%E8%AF%AD%E8%A8%80%E9%80%BB%E8%BE%91/"}]},{"title":"深入探究C++","slug":"C++/深入探究C","date":"2020-09-06T12:27:42.000Z","updated":"2020-09-06T13:23:42.782Z","comments":true,"path":"2020/09/06/C++/深入探究C/","link":"","permalink":"http://yoursite.com/2020/09/06/C++/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6C/","excerpt":"","text":"C++的继承与多态接口继承与实现继承派生类将基类中除去构造函数和析构函数的其他方法继承了过来。public继承概念由两部分组成，函数接口(function interfaces)继承和函数实现(function implementations)继承。作为类的开发人员，我们主要研究类的三种继承情况：1、派生类只继承成员函数的接口(也就是声明)，需要自己来重新定义该函数的实现；2、派生类同时继承函数的接口和实现，但又希望能够覆写(override)它们所继承的实现；3、派生类同时继承函数的接口和实现，并且不允许覆盖任何东西，只能利用父函数的实现； 1234567891011class Shape&#123;//形状public: virtual void draw() const = 0; virtual void error(const std::string&amp; msg); int objectID() const; ...&#125;;class Rectangle:public Shape&#123;...&#125;;//矩形class Ellipse:public Shape&#123;...&#125;;//椭圆 Shape是个抽象类，它的纯虚函数draw使它成为一个抽象类，所以客户不能够创建Shape class的实体，只能创建它的派生类的实体 Shape类声明了三个函数，第一个是draw，在视屏中划出当前对象，第二个是error，准备让那些“需要报导某个错误”的成员函数调用，第三个是objectID，返回当前对象的独一无二的整数识别码，每个函数的声明方式都不相同，draw是个纯虚函数(pure virtual)，error是个虚函数( 简朴的(非纯)impure virtual函数)，objectID是个非虚函数(non-virtual)函数。 纯虚函数通常有两个特点：它们必须被任何“继承了他们”的具象类重新声明；并且它们在抽象类中通常没有定义。所以结论是：声明一个纯虚函数的目的是为了让派生类只继承函数的接口。 虚函数（简朴的impure virtual函数）背后的故事和纯虚函数（pure virtual函数）有点不同，一如往常，派生类继承其函数接口，但虚函数（简朴的impure virtual函数）会提供一份实现代码，派生类可能覆写（override）它，所以结论是： 声明虚函数（简朴的impure virtual函数）的目的是让派生类继承该函数的接口和缺省实现，考虑error函数，其接口表示，每个类都必须支持一个“当遇上错误是可调用”的函数，但每个类可自由处理错误，若某个类不想针对错误做出任何特殊行为，它可以退回到Shape类提供的缺省错误处理行为。但是允许虚函数（简朴的impure virtual函数）同时指定函数声明和函数缺省行为，却有可能造成危险，考虑下面的例子： 123456789101112131415161718192021222324252627//XYZ航空公司的飞机继承体系，该公司只有A型和B型两种飞机，两者都以相同方式飞行，因此XYZ设计的继承体系为：class Airport&#123;...&#125;;class Airplane&#123;public : virtual void fly(const Airport&amp; destination); ...&#125;void Airplane::fly(const Airport&amp; destination)&#123; //缺省代码，将飞机飞至指定的目的地&#125;class ModelA:public Airplane&#123;...&#125;;class ModelB:public Airplane&#123;...&#125;;//现在，新增加一个C型飞机，C型和A型、B型的飞行方式不同，XYZ公司的程序员在继承体系中针对C型飞机加了一个类，但由于急于让飞机上线，竟然忘了定义其fly函数：class ModelC:public Airplane&#123; ... //为声明fly函数&#125; 若代码中出现如下操作：Airport PDX(…);//PDX是机场名字Airplane* pa = new ModelC;…pa-&gt;fly(PDX);//调用Airplane::fly 这将酿成大祸，这个程序试图以ModelA或ModelB的飞行方式来飞ModelC。解决该问题的要点在于切断“虚函数接口”和其“缺省实现”之间的连接，下面是一种做法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Airplane&#123;public: virtual void fly(const Airplane&amp; destination) = 0; ...protected: void defaultFly(const Airport&amp; destination);&#125;;void Airplane::defaultFly(const Airport&amp; destination)&#123; // 缺省行为，将飞机飞至指定的目的地&#125;//现在ModelA和ModelB调用的飞行的缺省实现为：class ModelA:public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly(destination); ... &#125;&#125;;class ModelB:public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly(destination); ... &#125;&#125;;//现在ModelC class 不可能意外继承不正确的fly实现代码，因为Airplane中的纯虚函数迫使ModelC必须提供自己的fly版本：class ModelC:public Airplane&#123;public: virtual void fly(const Airport&amp; destination); &#123; ... &#125;&#125;;void ModelC::fly(const Airport&amp; destination)&#123; //将C型飞机飞至指定目的地&#125; 最后考虑Shape的非虚函数objectID()。若成员函数是个非虚函数，意味着它并不打算在派生类中有不同的行为，实际上非虚成员函数所表现的不变性远重要于特异性，因为它表示不论派生类变得多么特异化，就其自身而言，它的行为都不可以改变。 1、接口继承和实现继承不同。在public继承之下，派生类总是继承基类的接口； 2、纯虚函数只是具体指定接口继承； 3、虚函数( 简朴的（非纯）impure virtual函数)具体指定接口继承及缺省实现继承； 4、非虚函数(non-virtual函数)具体指定接口继承以及强制性实现继承。 总结接口继承：派生类只继承函数的接口 实现继承：派生类同时继承函数的接口和实现 虚函数是重载的一种表现方式，是一种动态的重载方式。 非虚函数：继承该函数的接口和一份强制性实现，继承类必须含有某个接口，必须使用基类的实现 虚函数：会继承该函数的接口和缺省实现。继承类必须含有某个接口，可以自己实现，也可以不实现，而采用基类定义的缺省实现。 纯虚函数：纯虚函数在基类中没有定义，接口继承。含有纯虚函数的类无法实例化。要求继承类必须含有某个接口，并对接口函数实现。 多态与继承继承访问修饰符继承方式有三种——public、protected和private，不同的继承方式对继承到派生类中的基类成员有什么影响？ 总的来说，父类成员的访问限定符通过继承派生到子类中之后，访问限定符的权限小于、等于原权限。其中，父类中的private成员只有父类本身及其友元可以访问，通过其他方式都不能进行访问，当然就包括继承。protected多用于继承当中，如果对父类成员的要求是——子类可访问而外部不可访问，则可以选择protected继承方式。 父子类中同名元素overload重载函数重载有三个条件，一函数名相同，二形参类型、个数、顺序不同，三相同作用域。根据第三个条件，可知函数重载只可能发生在一个类中 overhide隐藏在派生类中将基类中的同名成员方法隐藏，要想在派生类对象中访问基类同名成员得加上基类作用域。(注意，如果该同名方法在基类中实现了重载，在派生类对象中同样需要指定作用域，而不能通过简单的传参，调用带参重载方法) override函数覆盖基类、派生类中的同名方法 函数头相同(参数、返回值)，且基类中该方法为虚函数，则派生类中的同名方法将基类中方法覆盖。函数隐藏和函数覆盖都是发生在基类和派生类之间的，可以这么理解：基类和派生类中的同名函数，除去是覆盖的情况，其他都是隐藏的情况。 引用与指针. 基类对象和派生类对象派生类对象可以赋值给基类对象，基类对象不可以赋值给基类对象；对于基类对象和派生类对象，编译器默认支持从下到上的转换，上是基类，下是派生类。 基类指针(引用)和派生类指针(引用)基类指针(引用)可以指向派生类对象，但只能访问派生类中基类部分的方法，不能访问派生类部分方法。派生类指针(引用)不可以指向基类对象，解引用可能出错，因为派生类的一些方法可能基类没有。 虚函数分析：当Base类中有虚函数时，不论是Base类还是Derive类，它们的大小都增加了4个字节。并且当Base指向Derive对象时，Base的类型却变为Derive，不再和指针本身的类型相关，这是怎么回事呢？ 虚函数指针 实际上，Base和Derive类增加的4个字节就是虚函数指针的大小，每一个类只要有虚函数(包括继承而来的)，它就有且只有一个虚函数指针，类的大小就是总的成员变量的大小加上一个虚函数指针的大小。虚函数指针指向的是一张虚表，里面是这个类所有虚函数的地址，一个类对应一张虚函数表，而虚函数指针存在于每一个对象中，并且永远占据对象内存的前四个字节。 虚函数表又称为“虚表”，它在编译期间就已经确定，在程序运行时就会被装载到只读数据段，在整个程序运行期间都会一直存在。一个类实例化的多个对象，它们 的虚函数指针指向的是同一张虚表。 虚函数要求成员函数能实现为虚函数需要满足两个前提条件： 1.成员方法能取地址 2.成员方法依赖于对象。第一点毋庸置疑，虚函数表中需要存储虚函数的地址。第二点，我们怎么调用虚函数的？通过虚函数指针来找到虚表从而调用其中的方法，而虚函数指针又存在于对象中，所以这就意味着虚函数的调用需要依赖对象。 那么，我们可以确定一些不能实现为虚函数的方法： 1.构造函数——构造函数就是用来创建对象的，如何将其实现为虚函数，使其依赖一个对象调用？ 2.inline函数——内联函数直接在调用点展开，不能取地址 3.static方法——静态方法是属于整个类的，不依赖与单个对象。 成员函数能实现为虚函数需要满足两个前提条件： 1.成员方法能取地址 2.成员方法依赖于对象。第一点毋庸置疑，虚函数表中需要存储虚函数的地址。第二点，我们怎么调用虚函数的？通过虚函数指针来找到虚表从而调用其中的方法，而虚函数指针又存在于对象中，所以这就意味着虚函数的调用需要依赖对象。 前面我们探讨了那些不能实现虚函数的情况，析构函数是可以的。那么什么时候应该将析构函数实现为虚函数呢？答案是：当基类指针指向堆上开辟的派生类对象时。 静态绑定发生在编译阶段、动态绑定发生在运行阶段。","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"探究语言逻辑","slug":"探究语言逻辑","permalink":"http://yoursite.com/tags/%E6%8E%A2%E7%A9%B6%E8%AF%AD%E8%A8%80%E9%80%BB%E8%BE%91/"}]},{"title":"二叉树算法","slug":"算法/二叉树算法","date":"2020-09-06T08:12:42.000Z","updated":"2020-09-27T03:24:20.660Z","comments":true,"path":"2020/09/06/算法/二叉树算法/","link":"","permalink":"http://yoursite.com/2020/09/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/","excerpt":"","text":"思路指南数据结构的存储方式其实只有两种，顺序存储（数组）和链式存储（链表），要有递归的思想，自顶而下，从抽象到具体； 队列、栈：用数组实现，要处理扩容、缩容问题；用链表实现，需要更多内存空间存储节点指针； 图：用二维数组实现，邻接矩阵，判断连通性迅速单图如果稀疏则会耗费时间；链表实现：邻接表，节省空间，但操作效率不够； 散列表：通过散列函数将键映射到一个大数组中，拉链法：链表特性，操作简单但需要额外空间存储指针；线性探查法：数组特性，以便连续寻址，不需要指针存储空间但操作复杂； 树：用数组实现：堆，完全二叉树；链表实现，正常二叉树，二叉搜索树、AVL树、红黑树、区间树、B树； 二者优缺点数组：紧凑连续存储，可以随机访问，通过索引快速搜索，相对节省空间，但需要一次分别配够空间，若需要扩容，则重新分配空间并拷贝过去，T(n) = O(n)，且每次进行插入与删除时，必须搬移后面所有数据以保持连续，T(n) = O(N)。 链表：元素不连续，靠指针指向下一个元素的位置，故不存在数组的扩容问题；在知道前驱、后驱时操作指针插入、删除的T(n)=O(1)，但同样因为不连续从而不能根据索引计算对应元素地址，无法随机访问，同样会消耗更多存储空间。 基本操作遍历+访问；具体为：增删改查。 线性的，以for/while迭代为代表； 12345void traverse(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; // 迭代访问 arr[i] &#125; &#125; 链表遍历框架，兼具迭代与递归 1234567891011121314/* 基本的单链表节点 */ class ListNode &#123; int val; ListNode next; &#125;void traverse(ListNode head) &#123; for (ListNode p = head; p != null; p = p.next) &#123; // 迭代访问 p.val &#125; &#125;void traverse(ListNode head) &#123; // 递归访问 head.val traverse(head.next);&#125; 二叉树遍历框架：典型的非线性递归遍历结构 123456789/* 基本的⼆叉树节点 */ class TreeNode &#123; int val; TreeNode left, right; &#125;void traverse(TreeNode root) &#123; traverse(root.left); traverse(root.right); &#125; N叉树的遍历：非线性递归 123456789/* 基本的 N 叉树节点 */ class TreeNode &#123; int val; TreeNode[] children; &#125;void traverse(TreeNode root) &#123; for (TreeNode child : root.children) traverse(child);&#125; N叉树的遍历可扩展为图的遍历，如何实现图的环？：用个布尔数组visited做标记。 你就会发现只要涉及递归的问题，都是树的问题；其实很多动态规划问题就是在遍历⼀棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别⼈解法的核⼼思 路。再看看回溯算法，前⽂回溯算法详解⼲脆直接说了，回溯算法就是个 N 叉 树的前后序遍历问题，没有例外。 medium二叉树刷题（树的核心是递归遍历）二叉树中序遍历方法一：基于栈的遍历 1、如果left节点存在，就入栈，然后跳left； 2、如果left和right都不存在，则保存当前节点，然后出栈，并让left等于null； 3、如果right存在，且left不存在，则保存当前节点，然后跳right。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */// 中序遍历const inorderTraversal = (root) =&gt; &#123; let list = []; let stack = []; let node = root; while(node || stack.length) &#123; // 遍历左子树 while(node) &#123; stack.push(node); node = node.left; &#125; node = stack.pop(); list.push(node.val); node = node.right; &#125; return list;&#125; 1234567891011121314151617const inorderTraversal = root =&gt; &#123; let res = [], stack = [] while (root || stack.length) &#123; if (root.left) &#123; stack.push(root)； root = root.left； &#125; else if (!root.left &amp;&amp; !root.right) &#123; res.push(root.val)； root = stack.pop()； root &amp;&amp; (root.left = null)； &#125; else if (root.right) &#123; res.push(root.val)； root = root.right； &#125; &#125; return res&#125; 方法二：递归 12345678910111213141516171819var inorderTraversal = function(root) &#123; let arr = []; if(!root) return []; let nums = [root]; //递归方法实现 MiddleOrder(root,arr); return arr;&#125;;function MiddleOrder(root,arr)&#123; if(root.left)&#123; MiddleOrder(root.left,arr); &#125; arr.push(root.val); if(root.right)&#123; MiddleOrder(root.right,arr); &#125;&#125; 前序遍历二叉树方法一：基于栈的迭代实现 首先根入栈将根节点出栈，将根节点值放入结果数组中 然后遍历左子树、右子树，因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈 继续出栈（左子树被出栈）……. 12345678910111213141516// 前序遍历const preorderTraversal = (root) =&gt; &#123; const list = []; const stack = []; let node = root; while (node || stack.length)&#123; while (node)&#123; stack.push(node.right); list.push(node.val); node = node.left; &#125; node = stack.pop(); &#125; return list;&#125; 12345678910111213141516// 前序遍历var preorderTraversal = (root) =&gt; &#123; let result = [] var preOrderTraverseNode = (node) =&gt; &#123; if(node) &#123; // 先根节点 result.push(node.val) // 然后遍历左子树 preOrderTraverseNode(node.left) // 再遍历右子树 preOrderTraverseNode(node.right) &#125; &#125; preOrderTraverseNode(root) return result&#125;; 后序遍历二叉树按照左子树-根-右子树的方式，将其转换成迭代方式。 思路：每到一个节点 A，因为根要最后访问，将其入栈。然后遍历左子树，遍历右子树，最后返回到 A。 但是出现一个问题，无法区分是从左子树返回，还是从右子树返回。 因此，给 A 节点附加一个标记T。在访问其右子树前，T 置为 True。之后子树返回时，当 T 为 True表示从右子树返回，否则从左子树返回。 当 T 为 false 时，表示 A 的左子树遍历完，还要访问右子树。 同时，当 T 为 True 时，表示 A 的两棵子树都遍历过了，要访问 A 了。并且在 A 访问完后，A 这棵子树都访问完成了。 1, 先遍历左节点, 当遍历到末尾节点时, 记录值 2, 然后跳回上一层节点, 顺便让left等于null 3, 再遍历右节点, 同样是遍历到末尾节点时, 记录值 4, 第二次返回时, 让右节点等于null 通过这种人为的方式，不断创造末尾节点值。 1234567891011121314151617181920const postorderTraversal = root =&gt; &#123; let res = [], stack = []; while (root || stack.length) &#123; if (root.left) &#123; stack.push(root); root = root.left; &#125; else if (root.right) &#123; stack.push(root); root = root.right; &#125; else &#123; res.push(root.val); root = stack.pop(); if (root &amp;&amp; root.left) root.left = null; else if (root &amp;&amp; root.right) root.right = null; &#125; &#125; return res;&#125; 不同的二叉搜索树给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 思路：动态规划；为了构建一颗二叉搜索树，可以遍历每一个数字i,将其作为树根，并将1…i-1作为左子树，i+1…n作为右子树，接着可以按照同样方式递归构建左右子树。原问题可以分成规模较小的两个子问题，且解可以复用，因此用动态规划处理。 具体步骤：题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1 \\leq i \\leq n)(1≤i≤n)。可见，G(n) 是我们求解需要的函数。 动态规划问题的关键在于构建状态转移方程。 123456789101112var numTrees = function(n) &#123; const G = new Array(n + 1).fill(0); G[0] = 1; G[1] = 1; for (let i = 2; i &lt;= n; ++i) &#123; for (let j = 1; j &lt;= i; ++j) &#123; G[i] += G[j - 1] * G[i - j]; &#125; &#125; return G[n];&#125;; 在本题目的扩展下，如果要求生成所有由1-n节点所组成的二叉搜索树。 和二叉搜索树一的解法不同，一的目的是求数量，而这道题是求具体的解，所以不能从树的规律来简化；利用树的递归特性，采用DFS来递归求解； n个数组成的二叉树，分为分别以1,2,3…,n为顶点的树；以i为例：f[i]的左边树就是1到i-1个数组成的二叉搜索树，因为左边的节点都比顶点小；f[i]的右边子树就是[i+1]到n的数组成的二叉搜索树，因为右边的节点都比顶点大；左右两侧都是树的数组；组合之后，f[i]的数组组合就得到了。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;number&#125; n * @return &#123;TreeNode[]&#125; */var generateTrees = function (n) &#123; if (n == 0) return []; function getTree(s, e) &#123; if (s &gt; e) return [null]; if (s == e) return [new TreeNode(s)]; var tree = []; var i = s; while (i &lt;= e) &#123; var lefts = getTree(s, i - 1), rights = getTree(i + 1, e); while (lefts.length) &#123; var left = lefts.pop(), j = 0; while (j &lt; rights.length) &#123; var right = rights[j]; j++; var node = new TreeNode(i); node.left = left; node.right = right; tree.push(node); &#125; &#125; i++; &#125; return tree; &#125; return getTree(1, n);&#125;; 从构建1棵树到构建n棵树，该递归思路其实清晰可见。 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：1、节点的左子树只包含小于当前节点的数。2、节点的右子树只包含大于当前节点的数。3、所有左子树和右子树自身必须也是二叉搜索树。 方法一：设计一个递归函数来判断，函数表示考虑以root为跟的子树，其子树所有节点是否都在（l,r）的范围内。不在则直接返回，在的话则继续递归调用其左右子树是否满足。 12345678const helper = (root, lower, upper)=&gt;&#123; if (root == null) return ture; if (root.val &lt;= lower || root.val &gt;= upper) return false; return helper(root.left, lower, root.val) &amp;&amp; helper(root.right, root.val, upper);&#125;var isValidBST = function(root) &#123; return helper(root, -Infinity, Infinity);&#125;; 方法二：中序遍历，二叉搜索树的中序遍历结果一定是升序序列。 1234567891011121314151617var isValidBST = function(root) &#123; let stack = []; let inorder = -Infinity; while (stack.length || root !== null) &#123; while (root !== null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if (root.val &lt;= inorder) return false; inorder = root.val; root = root.right; &#125; return true;&#125;; 对称二叉树验证一个二叉树是否对称 方法一：递归；左子树和右子树镜像对称则这个树是对称的，1、根节点的值相同；2、一个树的右子树跟另一个树的左子树镜像对称。其实本质跟二叉树相等的递归一样。 1234567891011121314151617const isSymmetric = (root) =&gt; &#123; const check = (left, right) =&gt; &#123; if (left == null &amp;&amp; right == null) return true; if (left &amp;&amp; right) &#123; return left.val == right.val &amp;&amp; check(left.left, right.right) &amp;&amp; check(left.right, right.left); &#125; return false; &#125;; if (root) &#123; return check(root.left, root.right); &#125; else &#123; return true; &#125;&#125;; 方法二：BFS广度遍历法；入队列的顺序：1、左子树的左子树，右子树的右子树；2、左子树的右子树，右子树的左子树；出队列的时候，检查两两是否对称。 JS中array类型提供了pop()和push()方法来模仿栈这个数据结构的方法；push()方法接受任意数量的参数，并将其逐个添加到数组尾部，并返回修改后数组的长度；pop()方法则从数组末尾溢出最后一项，减少数组的length值，然后返回溢出的项。 而JS用push()和shift()方法结合来模仿队列；shift()方法溢出数组中的第一项并返回该项，同时将数组长度减一；同时也提供了unshift()方法，能在数组前端添加任意项并返回新数组的长度。因此同时使用unshift()和pop()可以从相反方向模拟数列，在前端添加项，从末端移除项。 12345678910111213141516171819202122232425262728293031const isSymmetric = (root) =&gt; &#123; if (root == null) return true; const leftQueue = [root.left]; // 队列存放左子树 const rightQueue = [root.right]; // 队列存放右子树 while (leftQueue.length &amp;&amp; rightQueue.length) &#123; const left = leftQueue.shift(); const right = rightQueue.shift(); // 左右子树都为空，没有子节点可入列，continue if (left == null &amp;&amp; right == null) &#123; continue; &#125; if ((left == null &amp;&amp; right) || (left &amp;&amp; right == null)) &#123; return false; &#125; if (left.val != right.val) &#123; return false; &#125; leftQueue.push(left.left); rightQueue.push(right.right); leftQueue.push(left.right); rightQueue.push(right.left); &#125; // 其中一个子树还有节点没遍历，说明不对称 if (leftQueue.length || leftQueue.length) &#123; return false; &#125; else &#123; return true; &#125;&#125;; 方法三：利用两个栈来对递归进行模拟 12345678910111213141516171819202122232425var isSymmetric = (root) =&gt; &#123; if (!root) return true let leftStack = [], rightStack = [] // 维护两个栈 let curLeft = root.left // 当前的左子树 let curRight = root.right // 当前的右子树 while (curLeft || curRight || leftStack.length || rightStack.length) &#123; while (curLeft) &#123; // 左子树存在 leftStack.push(curLeft) // 推入leftStack栈 curLeft = curLeft.left // 不断将左子树入栈 &#125; while (curRight) &#123; // 右子树存在 rightStack.push(curRight) // 推入rightStack栈 curRight = curRight.right // 不断将右子树压入栈 &#125; if (leftStack.length !== rightStack.length) return false // 栈的高度不相等，说明结构不对称 curLeft = leftStack.pop() // 栈顶节点出栈，赋给curLeft curRight = rightStack.pop() // 栈顶节点出栈，赋给curRight if (curLeft.val !== curRight.val) return false // 两个栈出栈的节点值不相等 不对称 curLeft = curLeft.right // 考察左子树的right curRight = curRight.left // 考察右子树的left &#125; return true&#125; 二叉树的BFS与DFSDFS：深度优先搜索一般使用递归的方法进行实现。 1234567var dfs = (root) =&gt; &#123; if (root == null)&#123; return ; &#125; dfs(root.left); dfs(root.right);&#125; BFS则是使用队列的数据结构来进行遍历； 12345678910111213var dfs = (root) =&gt; &#123; var queue = []; queue.push(root); while (queue.length != 0)&#123; var node = queue.shift(); if (node.left != null)&#123; queue.push(node.left); &#125; if (node.right != null)&#123; queue.push(node.right); &#125; &#125;&#125; 递归的方法其实隐含地使用了系统的栈，不需要自己去维护数据结构；BFS这种独特的遍历方式正式其用于求解层序遍历和最短路径问题的根本原因。 层序遍历与最小路径问题1、层序遍历；利用BFS遍历二叉树无法区分队列中的节点来自哪一层，因此需要修改下代码记录队列中节点数量n（即这一层的节点数），然后一口气处理该层n个节点。 12345678910111213141516171819var dfs = (root) =&gt; &#123; var queue = [], res = [], level = []; queue.push(root); while (queue.length != 0)&#123; var n = queue.length; for (var i = 0; i &lt; n; i++)&#123; var node = queue.shift(); level.push(node.val); if (node.left != null)&#123; queue.push(node.left); &#125; if (node.right != null)&#123; queue.push(node.right); &#125; &#125; res.pop(level); &#125; return res;&#125; 其实根据上述层序遍历的代码，要实现二叉树层序遍历的反向输出，只需要修改最后res的入队列方式即可，用unshift来代替pop。 2、最短路径问题：在树中一个节点到一个节点的路径是唯一的，但在图中可能有多条路径，找寻哪一条路径最短。在BFS中，距离源点越近的点会先被遍历到。（Dijkstra算法解决的是带权最短路径问题，而BFS解决的是无权最短路径问题） 二叉树的锯齿形层次遍历给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行） 思路：典型广度优先题目；广度优先通过队列处理 【深度优先用栈】 1、将一层记录在数组中 并记录数组长度找下一行所有数据将数组首位弹出 将首位的左右节点追在数组后； 2、按照记录的数组长度 将上层的结点全部弹出后 此时数组只剩下下一行结点了 此时就完成了一层的遍历；类似上题 与上题区别 每层输出反向 加个条件即可 1234567891011121314151617181920212223242526272829303132* @return &#123;number[][]&#125; *var zigzagLevelOrder = function(root) &#123; if(root==null) return [] var arr=[root] var res=[] var go=true while(arr.length&gt;0)&#123; var n=arr.length var now=[] if(go)&#123; while(n--&gt;0)&#123; var node=arr.shift() now.push(node.val) if(node.left!=null)arr.push(node.left) if(node.right!=null)arr.push(node.right) &#125; res.push(now) &#125;else&#123; while(n--&gt;0)&#123; var node=arr.pop() now.push(node.val) if(node.right!=null)arr.unshift(node.right) if(node.left!=null)arr.unshift(node.left) &#125; res.push(now) &#125; go=!go &#125; return res&#125;; 前序跟中序遍历构造二叉树思路：构建一个二叉树需要构建三部分：root、左子树、右子树；左子树、右子树的构建，又包括：root、左子树、右子树解题关键在于定位出根节点，划分出左右子树，然后 递归 构建左右子树 具体做法：preorder 数组的第一项肯定是根节点 —— 因为前序遍历的顺序是 [根| 左|右 ][根∣左∣右]。由根节点，在 inorder [左 | 根 | 右][左∣根∣右] 中划分出左、右子树的 inorder 序列。通过 inorder 中左右子树的节点个数，在 preorder 中确定左、右子树的 preorder 序列。得到左、右子树的 preorder 和 inorder 序列，就能递归构建左右子树。 12345678const buildTree = (preorder, inorder) =&gt; &#123; if (inorder.length == 0) return null; const root = new TreeNode(preorder[0]); const mid = inorder.indexOf(preorder[0]); root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid)); root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1)); return root;&#125;; 优化一:字符串截取性能消耗比较大，没必要每次均将preorder、inorder切割；用两个指针表示即可，写一个接受指针的辅助函数。 12345678910111213const buildTree = (preorder, inorder) =&gt; &#123; const helper = (p_start, p_end, i_start, i_end) =&gt; &#123; if (p_start &gt; p_end) return null; let rootVal = preorder[p_start]; // 根节点的值 let root = new TreeNode(rootVal); // 根节点 let mid = inorder.indexOf(rootVal); // 根节点在inorder的位置 let leftNum = mid - i_start; // 左子树的节点数 root.left = helper(p_start + 1, p_start + leftNum, i_start, mid - 1); root.right = helper(p_start + leftNum + 1, p_end, mid + 1, i_end); return root; &#125;; return helper(0, preorder.length - 1, 0, inorder.length - 1);&#125;; 再次优化：每次递归都要indexof寻找根节点位置，耗费性能；可提前把inorder数组元素和索引存到hash表中。 1234567891011121314151617const buildTree = (preorder, inorder) =&gt; &#123; const map = new Map(); for (let i = 0; i &lt; inorder.length; i++) &#123; map.set(inorder[i], i); &#125; const helper = (p_start, p_end, i_start, i_end) =&gt; &#123; if (p_start &gt; p_end) return null; let rootVal = preorder[p_start]; // 根节点的值 let root = new TreeNode(rootVal); // 根节点 let mid = map.get(rootVal); // 根节点在inorder的位置 let leftNum = mid - i_start; // 左子树的节点数 root.left = helper(p_start + 1, p_start + leftNum, i_start, mid - 1); root.right = helper(p_start + leftNum + 1, p_end, mid + 1, i_end); return root; &#125;; return helper(0, preorder.length - 1, 0, inorder.length - 1);&#125;; 中序跟后序遍历构造二叉树通常从先序序列或者后序序列开始，根据不同遍历方法的规律，选择合适的节点构造树。例如：先序序列的 第一个 节点是根节点，然后是它的左孩子，右孩子等等。后序序列的 最后一个 节点是根节点，然后是它的右孩子，左孩子等等。 从先序/后序序列中找到根节点，根据根节点将中序序列分为左子树和右子树。从中序序列中获得的信息是：如果当前子树为空（返回 None），否则继续构造子树。 创建 hashmap 存储中序序列：value -&gt; its index 。 方法 helper 的参数是中序序列中当前子树的左右边界，该方法仅用于检查子树是否为空。下面分析 helper(in_left = 0, in_right = n - 1) 的逻辑： 1、如果 in_left &gt; in_right，说明子树为空，返回 None。 2、选择后序遍历的最后一个节点作为根节点。 3、假设根节点在中序遍历中索引为 index。从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。 4、根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。 5、返回根节点 root 1234567891011121314var buildTree = function(inorder, postorder) &#123; let p = i = postorder.length - 1; let build = (stop) =&gt; &#123; if(inorder[i] != stop) &#123; let root = new TreeNode(postorder[p--]) root.right = build(root.val) i-- root.left = build(stop) return root &#125; return null &#125; return build()&#125; 翻转二叉树递归三步法：1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。 12345678910111213141516171819/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode&#125; */var invertTree = function(root) &#123; if (root == null) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root;&#125;; 将有序数组转换为二叉搜索树该解题的本质不在于二叉搜索树和中序遍历，本质是平衡。 如何满足平衡条件：每次把一组数最中间的位置作为树的头拎起来，剩余的部分平均分两份，剩余的一个随便给左子树或右子树； 123456def 做一棵树（数组的哪个段落要做成树）：#这个段落用索引表示即可，与具体数字无关 #假设这个段落叫A吧 树的根部 = 这个段落A最中间的数字 树的左边 = 做一棵树（这个段落A的左边部分） 树的右边 = 做一棵树（这个段落A的右边部分） return 这棵树 二叉搜索树中序遍历后正好是一个递增的数组；因此，其实这个树就是我们中序遍历二叉树的结果。因此我们以和中序遍历相反的方式，从中间开始取root进行构建二叉树即可。 #可以看到整个题解只和index有关，和数组里的具体数字无关， #因为题目给出的“有序数列”帮助我们满足了“二叉搜索树”的条件。因此只需要操作index来对节点进行重新构建即可。 123456789101112131415161718const sortedArrayToBST = (nums) =&gt; &#123; const buildBST = (nums, start, end) =&gt; &#123; if (start &gt; end) &#123; return null; &#125;//无符号右移&gt;&gt;&gt;的操作是：丢弃右边指定位数，并左边补上0，因此等于除以2。 const mid = (start + end) &gt;&gt;&gt; 1; const root = new TreeNode(nums[mid]); root.left = buildBST(nums, start, mid - 1); root.right = buildBST(nums, mid + 1, end); return root; &#125;; return buildBST(nums, 0, nums.length - 1);&#125;; 二叉树hard题目恢复二叉搜索树二叉搜索树中的两个节点被错误地交换。 请在不改变其结构的情况下，恢复这棵树。 找到二叉搜索树中序遍历得到值序列的不满足条件的位置。本方法开辟一个新数组 \\textit{nums}nums 来记录中序遍历得到的值序列，然后线性遍历找到两个位置 i和 j，并重新遍历原二叉搜索树修改对应节点的值完成修复， 12345678910111213141516171819202122232425262728293031323334353637383940414243const inorder = (root, nums) =&gt; &#123; if (root === null) &#123; return; &#125; inorder(root.left, nums); nums.push(root.val); inorder(root.right, nums);&#125;const findTwoSwapped = (nums) =&gt; &#123; const n = nums.length; let x = -1, y = -1; for (let i = 0; i &lt; n - 1; ++i) &#123; if (nums[i + 1] &lt; nums[i]) &#123; y = nums[i + 1]; if (x === -1) &#123; x = nums[i]; &#125; else break; &#125; &#125; return [x, y];&#125;const recover = (r, count, x, y) =&gt; &#123; if (r !== null) &#123; if (r.val === x || r.val === y) &#123; r.val = r.val === x ? y : x; if (--count === 0) &#123; return; &#125; &#125; recover(r.left, count, x, y); recover(r.right, count, x, y); &#125;&#125;var recoverTree = function(root) &#123; const nums = []; inorder(root, nums); const [first, second] = findTwoSwapped(nums); recover(root, 2, first, second); &#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"JavaScript编程","slug":"前端/JavaScript编程","date":"2020-09-04T10:55:49.000Z","updated":"2020-09-06T08:02:55.444Z","comments":true,"path":"2020/09/04/前端/JavaScript编程/","link":"","permalink":"http://yoursite.com/2020/09/04/%E5%89%8D%E7%AB%AF/JavaScript%E7%BC%96%E7%A8%8B/","excerpt":"","text":"HTML定义了网页的内容；CSS 描述了网页的布局；JavaScript确定了网页的行为。 一个完成的JS实现由下面三部分组成：1、核心ECMAScript；2、文档对象模型DOM；2、浏览器对象模型BOM。 1、ECMAScript与Web浏览器没有依赖关系，就是对实现该标准规定的各方面内容的语言的描述； 2、文档对象模型DOM：针对XML但经过扩展用于HTML的应用程序编程接口API；DOM把整个页面映射为一个多层节点结构，HTML页面中每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据；通过DOM创建的这个表示文档的树形图，开发者获得了控制页面内容和结构的主动权。借助DOM提供的API，开发人员可以自如地删除、添加、替换或修改任何节点。 3、浏览器对象模型BOM：开发人员使用BOM控制浏览器显示的界面以外的部分， 1、使用script元素嵌入JavaScript代码时，只须为script指定type属性，type=”text/javascript”，之后将JS代码直接放在元素内部，且包含在script内部的JS代码将从上至下被解释；即在解释器对script页面内的所有代码求值完以前，页面中其余内容都不会被浏览器加载或显示。 2、如果要通过script元素来包含外部JS文件，那么需要SRC属性，是一个指向外部JS文件的链接； 且带有src属性的script元素不应该在其script和/script标签之间再包含额外的JS代码，如果包含则只会下载并执行外部脚本文件而忽略内部嵌入的代码。 甚至SRC属性可以包含外部域的JS 12&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.somewhere.com/afile.js&quot;&gt;&lt;/script&gt; 现代WEB应用一般把全部JS引用放在body元素中页面内容的后面，以免加载时间过长；或者加上defer作为延迟脚本（延迟至html页面加载完毕），加上async作为异步脚本（不让页面等待两个脚本下载、执行，从而异步加载其他内容）。 一般还是尽可能得用外部文件来包含JS代码，可维护性、可缓存、适应未来。 1、基本概念变量松散类型变量，定义时用var后跟变量名，该变量可以用于保存任何值；但用var操作符定义的变量将成为定义该变量作用域中得局部变量，如果在函数中定义，则函数退出后便会销毁该变量。省略var操作符时可定义全局变量，但及其不推荐。 数据类型5种简单得：Undefined（未定义）、Null（空）、Boolean（布尔型）、Number（数值）、String（字符串）；还有一种复杂的：Object（对象），数据类型具有动态性，无需再定义。用typeof操作符来返回给定变量的数据类型。 Undefined：只有一个值undefined，使用var声明变量时未对其初始化； Null：只有一个值null，逻辑上表示一个空对象指针，因此使用typeof检测null值时会返回object，定义的变量要存储值则先初始化为null，可直接检查该值判断是否已经保存了一个对象的引用。事实上，undefined值派生自null值，因此它们的相等性测试返回true。 Boolean类型：只有两个字面值：true、false，且区分大小写，即True和False不是布尔类型，只是标识符，调用转型函数Boolean（）可以转换成对应的布尔值。 Number类型：表示整型和浮点数值，十进制、八进制（字面值第一位为0）、十六进制（字面值第一位为0X），ECMAScript会适时地自动将浮点型变为整型，对于极大、极小的数可用e来表示法表示的浮点数值表示。数值范围：Number.MIN_VALUE到Number.MAX_VALUE。 NaN：非数值，是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况。任何涉及NaN的操作都会返回NaN，因此用isNaN()函数，不能转换成数值的值都会导致该函数返回true，字符串”blue“不能转换成数值，因此返回true。 12var floatNum = 3.125e7//e表示法表示的数值等于e前面的数乘以10的指数次幂 Number():用于任何数据类型转换成数值；parseInt()：处理整数；parseFloat()：处理浮点数字字符。 String类型：单、双引号没有区别，包含一些转义序列；ECMAScript中字符串不可变，要改变一个字符串，首先要销毁原来的字符串，再用一个包含新值得字符串填充该变量。 toString()方法，返回对应值字符串；String()转型函数。 object类型：对象其实就是一组数据和功能的集合，对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object的每个实例都具有下列方法、属性： constructor:保存着用于创建当前对象的函数，构造函数； hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在，其中作为参数的属性名propertyName必须以字符串的形式指定； isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型； propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举，与hasOwnProperty(propertyName)方法一样，作为参数的属性名必须以字符串形式指定； toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应； toString()：返回对象的字符串表示； valueOf()：返回对象的字符串、数值或布尔值表示。 操作符一元加操作符：对非数值应用时，该操作符会像Number转型函数一样对这个值执行转换；一元减操作符主要用于表示负数； 位操作符：用于最基本的层次上，即按内存中表示数值的位来操作数据，按位非~；按位与&amp;；按位或 | ;按位异或 ^；左移 &lt;&lt;;有符号的","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"CSS样式表编程","slug":"前端/CSS样式表编程","date":"2020-09-02T13:58:38.000Z","updated":"2020-09-17T07:17:33.361Z","comments":true,"path":"2020/09/02/前端/CSS样式表编程/","link":"","permalink":"http://yoursite.com/2020/09/02/%E5%89%8D%E7%AB%AF/CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1、CSS语法两个主要部分：选择器 + 一条或者多条声明；每条声明由一个属性和一个值组成，属性是希望设置的样式属性，每个属性有一个值。CSS声明总是以分号结束，声明总以大括号括起来。 如果要在HTML元素中设置CSS样式，需要在元素中设置id、class选择器。 id选择器可以为标有特定id的HTML元素指定特定的样式，HTML元素以id属性来设置id选择器，CSS中id选择器以#来定义。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;#para1&#123; text-align:center; color:red;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;para1&quot;&gt;Hello World!&lt;/p&gt;&lt;p&gt;这个段落不受该样式的影响。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; class选择器用于描述一组元素的样式，区别在于class可以在多个元素中使用， 插入CSS外部样式表：改变一个文件来改变一个站点的外观；每个页面使用 link标签链接到样式表。link标签在文档的头部：而浏览器会从文件mystyle.css中读到样式，并根据它来格式文档。外部样式表可在任何文本编辑器进行编辑，不能包含任何html标签，应该以CSS的扩展名进行保存， 123hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url(&quot;/images/back40.gif&quot;);&#125; 内部样式表：当单个文档需要特殊格式时，可以使用，可用style标签在文档头部定义内部样式表。 1234567&lt;head&gt;&lt;style&gt;hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125;&lt;/style&gt;&lt;/head&gt; 内联样式： 多重样式：某些属性在不同样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 多重样式优先级：可以在同一个HTML文档内部引用多个外部样式表。优先级如下：内联样式&gt;内部样式&gt;外部样式&gt;浏览器默认样式 CSS背景背景属性用于定义HTML元素的背景： background-color：背景颜色；background-image：背景图像；background-repeat:设置背景不平铺；background-position:背景定位； CSS文本格式格式：颜色color、对齐方式text-align、文本修饰text-decoration、文本大小写转换text-transform、文本缩进text-indent。 字体：两种类型的字体系列名称，通用字体、特定字体。font-family属性设置文本的字体系列， CSS链接四个基本的链接样式实例： a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 CSS盒子模型所有HTML元素可以看作盒子，在CSS中，box model这一术语是用来设计和布局时使用的，CSS盒模型本质上是一个盒子，封装周围的HTML元素，包括：边框、边距、填充、实际内容。盒模型允许我们在其他元素和周围元素边框之间的空间放置元素。 不同部分的说明： outline轮廓：绘制于元素周围的一条线，位于边框边缘的外围，起突出元素的作用。 Margin(外边距)** - 清除边框外的区域，外边距是透明的。可以单独改变元素四周边框，也可以一次改变所有属性。 Border(边框)** - 围绕在内边距和内容外的边框，允许一个元素边框的样式和颜色。 Padding(内边距)** - 清除内容周围的区域，内边距是透明的。 Content(内容)** - 盒子的内容，显示文本和图像 CSS分组与嵌套分组选择器：在样式表中有很多具有相同样式的元素，可使用分组选择器，每个选择器用逗号分隔。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;h1,h2,p&#123; color:green;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;h2&gt;Smaller heading!&lt;/h2&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 嵌套选择器：适用于选择器内部的选择器样式， p{ }: 为所有 p 元素指定一个样式。 .marked{ }: 为所有 class=”marked” 的元素指定一个样式。 .marked p{ }: 为所有 class=”marked” 元素内的 p 元素指定一个样式。 p.marked{ }: 为所有 class=”marked” 的 p 元素指定一个样式 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;p&#123; color:blue; text-align:center;&#125;.marked&#123; background-color:red;&#125;.marked p&#123; color:white;&#125;p.marked&#123; text-decoration:underline;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这个段落是蓝色文本，居中对齐。&lt;/p&gt;&lt;div class=&quot;marked&quot;&gt;&lt;p&gt;这个段落不是蓝色文本。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;所有 class=&quot;marked&quot;元素内的 p 元素指定一个样式，但有不同的文本颜色。&lt;/p&gt; &lt;p class=&quot;marked&quot;&gt;带下划线的 p 段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS显示与定位display元素设置一个元素应如何显示，visibility属性指定一个元素可见还是隐藏。 visibility：hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间，虽被隐藏但仍旧影响布局。display：none可以隐藏某个元素，且隐藏的元素不会占用任何空间。 块元素：h1(标题)、p（段落）、div（文档中的块级元素） 内联元素：span（文档中的内联元素）、a（书签） 可以随时改变元素的种类，从而使页面以不同的方式进行组合。 Position属性：static（默认位置）、relative（相对正常位置的相对位置）、fixed（相对浏览器是固定位置，即使窗口滚动它也不会滚动）、absolute（绝对定位的元素相对于已定位的父元素，如果没有已定位的父元素，则其位置相对于html）、sticky（粘性定位：依赖于用户的滚动，在relative与fixed之间切换）。 元素的定位与文档流无关，所以可以覆盖页面上其他元素，z-index属性指定了一个元素的堆叠顺序，实现重叠。 CSS布局overflow属性用于控制内容溢出元素框时显示的方式，在对应的区间内添加滚动条。 float属性会使元素向左或者向右移动，其周围的元素也会重新排列，往往用于图像或者布局。一个浮动元素会尽量向左或向右移动，直至其外边缘碰到包含框或另一个浮动框的边框。 对齐：1、要水平居中对齐一个元素，可使用margin:auto；并设置到元素的宽度放置它溢出到容器的边缘。2、文本居中对齐，可使用text-align：center；3、图片居中对齐：margin：auto；4、左右对齐：使用定位方式，position：absolute；5、左右对齐：使用float方式；6、垂直居中对齐 CSS组合选择符说明了两个选择器直接的关系，包含了四种组合方式：后代选择器、子元素选择器、相邻兄弟选择器、普通兄弟选择器 CSS伪类、伪元素添加一些选择器的特殊效果，伪类的语法：selector:pseudo-class {property:value;}；伪元素的语法：selector:pseudo-element {property:value;} 在支持CSS的浏览器中，链接的不同状态可以以不同方式进行显示。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;a:link &#123;color:#000000;&#125; /* 未访问链接*/a:visited &#123;color:#00FF00;&#125; /* 已访问链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 鼠标点击时 */&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;/css/&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; a:hover 必须在 a:link 和 a:visited 之后，需要严格按顺序才能看到效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; a:active 必须在 a:hover 之后。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 伪类可以和CSS类配合使用，以根据链接的被访问与否来判断链接的颜色。 first-child伪类来选择父类的第一个子元素；lang伪类：有能力为不同的语言定义特殊的规则； first-line伪元素用于向文本的首行设置特殊样式，first-letter伪元素用于向文本首字母设置特殊样式；before伪元素可以在元素内容前面插入新元素；after伪元素可以在元素的内容后面插入新内容； CSS各类工具垂直导航栏实例1、先用ul、ui元素构建一个链接列表； 2、利用CSS格式在列表中删除边距和填充； 3、只用a元素的样式，建立一个垂直的导航栏； 4、在点击了选项后，可以添加active类来标准哪个选项被选中； 5、在li、a上添加text-align:center来让链接居中，并在border ul上添加border属性来让导航栏有边框； 6、创建一个左边是全屏高度的固定导航条，右边是可滚动的内容； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;body &#123; margin: 0;&#125;ul &#123; list-style-type: none; margin: 0; padding: 0; width: 25%; background-color: #f1f1f1; position: fixed; height: 100%; overflow: auto;&#125;li a &#123; display: block; color: #000; padding: 8px 16px; text-decoration: none;&#125;li a.active &#123; background-color: #4CAF50; color: white;&#125;li a:hover:not(.active) &#123; background-color: #555; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;margin-left:25%;padding:1px 16px;height:1000px;&quot;&gt; &lt;h2&gt;Fixed Full-height Side Nav&lt;/h2&gt; &lt;h3&gt;Try to scroll this area, and see how the sidenav sticks to the page&lt;/h3&gt; &lt;p&gt;Notice that this div element has a left margin of 25%. This is because the side navigation is set to 25% width. If you remove the margin, the sidenav will overlay/sit on top of this div.&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt; &lt;p&gt;Some text..&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 水平导航栏实例1、指定元素，使用float浮动元素； 2、创建一个水平导航条实例，并在鼠标移动到选项之后修改背景颜色，点击选项后添加active类来标准哪个选项被选中； 3、将导航条的最右边选项设置设置右对齐，通过border-right样式来添加分割线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;ul &#123; list-style-type: none; margin: 0; padding: 0; overflow: hidden; border: 1px solid #e7e7e7; background-color: #f3f3f3;&#125;li &#123; float: left;&#125;li a &#123; display: block; color: #666; text-align: center; padding: 14px 16px; text-decoration: none;&#125;li a:hover:not(.active) &#123; background-color: #ddd;&#125;li a.active &#123; color: white; background-color: #4CAF50;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 下拉菜单实例使用CSS创建一个鼠标移上去后显示下拉菜单的效果， HTML部分：我们可以使用任何的HTML元素来打开下拉菜单，如span、button元素；使用容器元素来创建下拉菜单的内容，并放在你相放的位置；使用div元素来包裹这些元素并使用CSS来设置下拉内容的样式。 CSS部分：.dropddown类使用position:relative，将设置下拉菜单的内容放置在下拉按钮（position:absolute）的右下位置。.dropdown-content类中是实际的下拉菜单，默认是隐藏的，在鼠标移动到指定元素后会显示。:hover选择器将用于用户将鼠标移动到下拉按钮上时显示下拉菜单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt;/* 下拉按钮样式 */.dropbtn &#123; background-color: #4CAF50; color: white; padding: 16px; font-size: 16px; border: none; cursor: pointer;&#125;/* 容器 &lt;div&gt; - 需要定位下拉内容 */.dropdown &#123; position: relative; display: inline-block;&#125;/* 下拉内容 (默认隐藏) */.dropdown-content &#123; display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);&#125;/* 下拉菜单的链接 */.dropdown-content a &#123; color: black; padding: 12px 16px; text-decoration: none; display: block;&#125;/* 鼠标移上去后修改下拉菜单链接颜色 */.dropdown-content a:hover &#123;background-color: #f1f1f1&#125;/* 在鼠标移上去后显示下拉菜单 */.dropdown:hover .dropdown-content &#123; display: block;&#125;/* 当下拉内容显示后修改下拉按钮的背景颜色 */.dropdown:hover .dropbtn &#123; background-color: #3e8e41;&#125;&lt;/style&gt;&lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;dropbtn&quot;&gt;下拉菜单&lt;/button&gt; &lt;div class=&quot;dropdown-content&quot;&gt; &lt;a href=&quot;#&quot;&gt;菜鸟教程 1&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;菜鸟教程 2&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;菜鸟教程 3&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; CSS提示工具实例1、基础提示框，提示框在鼠标移动到指定元素上显示。 HTML使用容器元素（like div）并添加tooltip类，在鼠标移动到div时显示提示信息；提示文本放在内联元素上（span）并使用class=”tooltiptext”。 CSS中tooltip类使用position:relative，提示文本需要设置定位置position:absolute。tooltiptext类用于实际的提示文本，模式为隐藏的，:hover选择器用于鼠标移动到指定元素div时显示的提示。 1234567891011121314151617181920212223242526272829303132&lt;style&gt;/* Tooltip 容器 */.tooltip &#123; position: relative; display: inline-block; border-bottom: 1px dotted black; /* 悬停元素上显示点线 */&#125; /* Tooltip 文本 */.tooltip .tooltiptext &#123; visibility: hidden; width: 120px; background-color: black; color: #fff; text-align: center; padding: 5px 0; border-radius: 6px; /* 定位 */ position: absolute; z-index: 1;&#125; /* 鼠标移动上去后显示提示框 */.tooltip:hover .tooltiptext &#123; visibility: visible;&#125;&lt;/style&gt; &lt;div class=&quot;tooltip&quot;&gt;鼠标移动到这 &lt;span class=&quot;tooltiptext&quot;&gt;提示文本&lt;/span&gt;&lt;/div&gt; 2、定位提示工具：通过修改容器元素的top、left、right值来修改提示框显示的位置；如果想要提示框显示在头部和底部，需要使用margin-left属性，并设置为-60px 3、可以使用CSS伪元素::after以及content属性为提示工具创建一个小箭头标志，箭头由边框组成，但组合起来后提示工具像语音提示框。 12345678910.tooltip .tooltiptext::after &#123; content: &quot; &quot;; position: absolute; top: 100%; /* 提示工具底部 */ left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: black transparent transparent transparent;&#125; 图片廊1、CSS创建图片廊： 1234567891011121314151617181920212223242526272829303132333435&lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo1.jpg&quot;&gt; &lt;img src=&quot;http://static.runoob.com/images/demo/demo1.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo2.jpg&quot;&gt; &lt;img src=&quot;http://static.runoob.com/images/demo/demo2.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo3.jpg&quot;&gt; &lt;img src=&quot;http://static.runoob.com/images/demo/demo3.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://static.runoob.com/images/demo/demo4.jpg&quot;&gt; &lt;img src=&quot;http://static.runoob.com/images/demo/demo4.jpg&quot; alt=&quot;图片文本描述&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2、使用CSS3的媒体查询来创建响应式图片廊 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;img_fjords.jpg&quot;&gt; &lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_fjords.jpg&quot; alt=&quot;Trolltunga Norway&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;img_forest.jpg&quot;&gt; &lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_forest.jpg&quot; alt=&quot;Forest&quot; width=&quot;600&quot; height=&quot;400&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;img_lights.jpg&quot;&gt; &lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_lights.jpg&quot; alt=&quot;Northern Lights&quot; width=&quot;600&quot; height=&quot;400&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;responsive&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;img_mountains.jpg&quot;&gt; &lt;img src=&quot;http://www.runoob.com/wp-content/uploads/2016/04/img_mountains.jpg&quot; alt=&quot;Mountains&quot; width=&quot;600&quot; height=&quot;400&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt;这里添加图片文本描述&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;div style=&quot;padding:6px;&quot;&gt; &lt;h4&gt;重置浏览器大小查看效果&lt;/h4&gt;&lt;/div&gt; CSS3中属性的透明度是opacity，同时可以利用hover属性增加当用户将鼠标悬停在其中一个图像时会发生什么的时间，此时调为opacity=1 12345678910img&#123; opacity:0.4; filter:alpha(opacity=40); /* IE8 及其更早版本 */&#125;img:hover&#123; opacity:1.0; filter:alpha(opacity=100); /* IE8 及其更早版本 */&#125; 透明盒子中的文字： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;style&gt;div.background&#123; width:500px; height:250px; background:url(https://www.runoob.com/images/klematis.jpg) repeat; border:2px solid black;&#125;div.transbox&#123; width:400px; height:180px; margin:30px 50px; background-color:#ffffff; border:1px solid black; opacity:0.6; filter:alpha(opacity=60); /* IE8 及更早版本 */&#125;div.transbox p&#123; margin:30px 40px; font-weight:bold; color:#000000;&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;background&quot;&gt;&lt;div class=&quot;transbox&quot;&gt;&lt;p&gt;这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 图像拼合技术：单个图像的集合，多个图像的网页会降低服务器的请求数量，并节省带宽。与其使用三个独立图像不如使用这种单个图像。 123456img.home&#123;width:46px;height:44px;background:url(img_navsprites.gif) 0 0;&#125; :hover选择器可以运用于所有元素，因此所有元素都可以显示鼠标悬停在元素上的显示效果。 CSS媒体允许指定文件如何在不同媒体中实现，而一些CSS属性只设计了某些媒体，而其他的属性可用于许多不同的媒体类型。 @media规则允许在相同样式表为不同媒体设置不同的样式 123456789101112@media screen&#123; p.test &#123;font-family:verdana,sans-serif;font-size:14px;&#125;&#125;@media print&#123; p.test &#123;font-family:times,serif;font-size:10px;&#125;&#125;@media screen,print&#123; p.test &#123;font-weight:bold;&#125;&#125; CSS属性选择性具有特定属性的HTML元素样式不仅仅是class和id，下面的实例改变了标题title=’runoob‘元素的边框样式 1234[title=runoob]&#123; border:5px solid green;&#125; 表单样式：属性选择器无需使用class或id的形式。 12345678910111213input[type=&quot;text&quot;]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow;&#125;input[type=&quot;button&quot;]&#123; width:120px; margin-left:35px; display:block;&#125; 可用CSS属性选择器来渲染HTML的表单元素，使用width属性设置输入框的宽度；使用padding属性可以在输入框中添加内边距；使用border属性可以修改input边框得大小或颜色；使用background-color属性设置输入框得背景颜色； CSS计数器CSS计数器根据规则来递增变量，以下实例在页面创建一个计数器，且每个h2元素计数值都会递归，并在每个h2元素前添加Section计数值。 12345678body &#123; counter-reset: section;&#125; h2::before &#123; counter-increment: section; content: &quot;Section &quot; counter(section) &quot;: &quot;;&#125; 嵌套计数器：在每一个h1元素前添加计数值Section，嵌套得计数值则放在h2元素得前面，内容为 主标题计数值、副标题计数值。 1234567891011121314151617body &#123; counter-reset: section;&#125; h1 &#123; counter-reset: subsection;&#125; h1::before &#123; counter-increment: section; content: &quot;Section &quot; counter(section) &quot;. &quot;;&#125; h2::before &#123; counter-increment: subsection; content: counter(section) &quot;.&quot; counter(subsection) &quot; &quot;;&#125; 2、CSS网页布局网页布局一般分为以下几个部分：头部区域、菜单导航区域、内容区域、底部区域。 1、头部区域一般位于整个网页得顶部，用于设置网页得标题或LOGO； 2、菜单导航区域包含了一些链接，引导用户浏览其他页面； 3、内容区域一般有三种形式，1列用于移动端；2列用于平板设备；3列用于PC桌面设备。 4、底部区域在网页的最下方，一般包含版权信息与联系方式； 通过以上的方式，我们创建了一个响应式等页面， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102* &#123; box-sizing: border-box;&#125; body &#123; font-family: Arial; padding: 10px; background: #f1f1f1;&#125; /* 头部标题 */.header &#123; padding: 30px; text-align: center; background: white;&#125; .header h1 &#123; font-size: 50px;&#125; /* 导航条 */.topnav &#123; overflow: hidden; background-color: #333;&#125; /* 导航条链接 */.topnav a &#123; float: left; display: block; color: #f2f2f2; text-align: center; padding: 14px 16px; text-decoration: none;&#125; /* 链接颜色修改 */.topnav a:hover &#123; background-color: #ddd; color: black;&#125; /* 创建两列 *//* Left column */.leftcolumn &#123; float: left; width: 75%;&#125; /* 右侧栏 */.rightcolumn &#123; float: left; width: 25%; background-color: #f1f1f1; padding-left: 20px;&#125; /* 图像部分 */.fakeimg &#123; background-color: #aaa; width: 100%; padding: 20px;&#125; /* 文章卡片效果 */.card &#123; background-color: white; padding: 20px; margin-top: 20px;&#125; /* 列后面清除浮动 */.row:after &#123; content: &quot;&quot;; display: table; clear: both;&#125; /* 底部 */.footer &#123; padding: 20px; text-align: center; background: #ddd; margin-top: 20px;&#125; /* 响应式布局 - 屏幕尺寸小于 800px 时，两列布局改为上下布局 */@media screen and (max-width: 800px) &#123; .leftcolumn, .rightcolumn &#123; width: 100%; padding: 0; &#125;&#125; /* 响应式布局 -屏幕尺寸小于 400px 时，导航等布局改为上下布局 */@media screen and (max-width: 400px) &#123; .topnav a &#123; float: none; width: 100%; &#125;&#125; 3、CSS总结已经实现了，如何创建样式表来同时控制多重页面的样式和布局，比如如何定位元素、控制元素的可见性和尺寸、设置元素的形状、将一个元素置于另一个元素之后，以及向某些选择器添加特殊的效果，比如；链接。 CSS实例类型索引：runoob.com/css/css-examples.html。 4、CSS3教程CSS3用于控制网页样式和布局，CSS3被拆分为“模块”，旧规范已拆分为小块，还增加了新的。最重要的CSS3模块如下：选择器、盒模型、背景和边框、文字特效、2D3D转换、动画、多列布局、用户界面。 CSS格式背景边框：在CSS3中可添加圆角边框，添加阴影框，并作为边界形象而不使用设计程序。border-radius属性用于创建圆角；box-shadow属性用来添加阴影；border-image属性用于创建边框，允许你指定一个图片作为边框，用于创建上文边框的原始图像。 背景：包含新背景属性，提供更大背景元素控制。background-image添加背景图片；background-size指定背景图像大小；background-origin指定背景图像的位置区域；且CSS3允许在元素上添加多个背景图像。background-clip背景裁剪属性是从指定位置开始绘制。 渐变：可在两个或多个指定颜色之间显示平稳的过渡，linear gradients线性渐变：上、下、左、右、对角，radial gradients由中心定义。同样也可以定义一个角度而不用预定义方向：background-image: linear-gradient(angle, color-stop1, color-stop2);同样也可以使用多个颜色节点的定义、支持透明度以创建减弱变淡效果transparent，repeating-linear-gradient()函数用于重复线性渐变。 文本效果：text-shadow文本阴影、box-shadow盒子阴影、也可以在::before和::after两个伪元素中添加阴影效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;#boxshadow &#123; position: relative; -moz-box-shadow: 1px 2px 4px rgba(0, 0, 0,0.5); -webkit-box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); padding: 10px; background: white;&#125;/* Make the image fit the box */#boxshadow img &#123; width: 100%; border: 1px solid #8a4419; border-style: inset;&#125;#boxshadow::after &#123; content: &#x27;&#x27;; position: absolute; z-index: -1; /* hide shadow behind image */ -webkit-box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); width: 70%; left: 15%; /* one half of the remaining 30% */ height: 100px; bottom: 0;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;boxshadow&quot;&gt; &lt;img src=&quot;rock600x400.jpg&quot; alt=&quot;Norway&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 阴影使用的一个特例是卡片效果， CSS文本溢出属性Text Overflow指定应向用户如何显示溢出内容；自动换行属性word-wrap允许强制文本换行，即使分裂中间一个字。 CSS3单词拆分换行属性指定换行规则： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt; p.test1&#123; width:9em; border:1px solid #000000; word-break:keep-all;&#125;p.test2&#123; width:9em; border:1px solid #000000; word-break:break-all;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;test1&quot;&gt; This paragraph contains some text. This line will-break-at-hyphenates.&lt;/p&gt;&lt;p class=&quot;test2&quot;&gt; This paragraph contains some text: The lines will break at any character.&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; word-break 属性不兼容 Opera.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS3字体：自己的字体是在@font-face规则中描述定义的，必须首先定义字体的名称然后指向该字体文字文件。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; @font-face&#123; font-family: myFirstFont; src: url(&#x27;Sansation_Light.ttf&#x27;) ,url(&#x27;Sansation_Light.eot&#x27;); /* IE9 */&#125;div&#123; font-family:myFirstFont;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; Internet Explorer 9 只支持 .eot 格式的字体.&lt;/p&gt;&lt;div&gt;使用 CSS3,网站终于可以使用字体以外的预先选择“合法”字体&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS32D、3D转换CSS3转换可以对元素进行移动、缩放、转动、拉长或拉伸，转换的效果是让某个元素改变形状、大小和位置。 2D变换： translate()：根据X、Y轴位置给定的参数，从当前元素位置移动；rotate()：在一个给定度数顺时针旋转的元素，参数为负值则为逆时针；scale(）:增减元素的大小；skew()方法：包含两个参数值，分别表示X轴和Y轴倾斜的角度；matrix()方法和2D变换方法合并成一个，有6个参数包含旋转、缩放、移动、倾斜功能； 3D变换：能够将图片视为一个3D的小纸片进行翻转、变换运动，而不只是旋转与改变大小。 rotateX()方法：围绕其在一个给定度数X轴旋转的元素； rotateY()方法：围绕其在一个给定度数Y轴旋转的元素； 5、CSS3动画CSS3过渡元素从一种样式逐渐改变成另一种的效果，指定添加效果的CSS属性、指定效果的持续时间。要添加多个样式的变换效果，添加的属性由逗号分隔。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt; div&#123; width:100px; height:100px; background:red; transition:width 2s; -webkit-transition:width 2s; /* Safari */&#125;div:hover&#123; width:300px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt;该实例无法在 Internet Explorer 9 及更早 IE 版本上工作。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;鼠标移动到 div 元素上，查看过渡效果。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS3创建动画@keyframes规则：创建动画，其内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式； 当在@keyframes创建动画，把它绑定到一个选择器，否则动画不会有任何效果，指定这2个CSS3的动画属性绑定向一个选择器：规定动画名称与时长。下例将myfirst动画捆绑到div元素，时长为5秒。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; div&#123; width:100px; height:100px; background:red; animation:myfirst 5s; -webkit-animation:myfirst 5s; /* Safari and Chrome */&#125;@keyframes myfirst&#123; from &#123;background:red;&#125; to &#123;background:yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; from &#123;background:red;&#125; to &#123;background:yellow;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 该实例在 Internet Explorer 9 及更早 IE 版本是无效的。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画的实质是元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式、次数，并用百分比来规定变化发生的事件。以下可以改变元素背景色与位置： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; div&#123; width:100px; height:100px; background:red; position:relative; animation:myfirst 5s; -webkit-animation:myfirst 5s; /* Safari and Chrome */&#125;@keyframes myfirst&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 该实例在 Internet Explorer 9 及更早 IE 版本是无效的。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用下例设置所有的属性，并使用了简写的动画animation属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt; div&#123; width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate;&#125;@keyframes myfirst&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 该实例在 Internet Explorer 9 及更早 IE 版本是无效的。&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS用户界面与布局1、多列布局CSS3可将文本内容设计成像报纸一样的多列布局；column-count：指定需要分割的列数，column-gap：指定列与列之间间隙；column-rule-style：指定列与列间边框样式； 2、resize指定一个元素是否应该由用户去调整大小；box-sizing属性：允许以确切的方式适应某区域的具体内容；outline-offset属性对轮廓进行偏移，并在超出边缘的位置绘制轮廓。 3、CSS3来布局图片：border-radius来设置圆角、椭圆形图片；border属性来创建缩略图,在图片外层添加一个链接； 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;a &#123; display: inline-block; border: 1px solid #ddd; border-radius: 4px; padding: 5px; transition: 0.3s;&#125;a:hover &#123; box-shadow: 0 0 2px 1px rgba(0, 140, 186, 0.5);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;缩略图作为连接&lt;/h2&gt;&lt;p&gt;我们使用 border 属性来创建缩略图。在图片外层添加一个链接。&lt;/p&gt;&lt;p&gt;点击图片查看效果：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;paris.jpg&quot;&gt; &lt;img src=&quot;paris.jpg&quot; alt=&quot;Paris&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 响应式图片会自动适应不同尺寸屏幕， 4、卡片式图片并在图片下方添加图片描述文字。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;body &#123;margin:25px;&#125;div.polaroid &#123; width: 80%; background-color: white; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); margin-bottom: 25px;&#125;div.container &#123; text-align: center; padding: 10px 20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;响应式卡片&lt;/h2&gt;&lt;div class=&quot;polaroid&quot;&gt; &lt;img src=&quot;rock600x400.jpg&quot; alt=&quot;Norway&quot; style=&quot;width:100%&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;The Troll&#x27;s tongue in Hardanger, Norway&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;polaroid&quot;&gt; &lt;img src=&quot;lights600x400.jpg&quot; alt=&quot;Norway&quot; style=&quot;width:100%&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;Northern Lights in Norway&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS filter属性用于为元素添加可视效果，模糊、饱和度。 如何结合CSS和JavaScript来一起渲染图片：首先用CSS来创建modal窗口，默认为隐藏，然后使用JavaScript来显示模态窗口，当点击图片时，图片会在弹出的窗口中显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;#myImg &#123; border-radius: 5px; cursor: pointer; transition: 0.3s;&#125;#myImg:hover &#123;opacity: 0.7;&#125;/* The Modal (background) */.modal &#123; display: none; /* Hidden by default */ position: fixed; /* Stay in place */ z-index: 1; /* Sit on top */ padding-top: 100px; /* Location of the box */ left: 0; top: 0; width: 100%; /* Full width */ height: 100%; /* Full height */ overflow: auto; /* Enable scroll if needed */ background-color: rgb(0,0,0); /* Fallback color */ background-color: rgba(0,0,0,0.9); /* Black w/ opacity */&#125;/* Modal Content (image) */.modal-content &#123; margin: auto; display: block; width: 80%; max-width: 700px;&#125;/* Caption of Modal Image */#caption &#123; margin: auto; display: block; width: 80%; max-width: 700px; text-align: center; color: #ccc; padding: 10px 0; height: 150px;&#125;/* Add Animation */.modal-content, #caption &#123; -webkit-animation-name: zoom; -webkit-animation-duration: 0.6s; animation-name: zoom; animation-duration: 0.6s;&#125;@-webkit-keyframes zoom &#123; from &#123;-webkit-transform: scale(0)&#125; to &#123;-webkit-transform: scale(1)&#125;&#125;@keyframes zoom &#123; from &#123;transform: scale(0.1)&#125; to &#123;transform: scale(1)&#125;&#125;/* The Close Button */.close &#123; position: absolute; top: 15px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; transition: 0.3s;&#125;.close:hover,.close:focus &#123; color: #bbb; text-decoration: none; cursor: pointer;&#125;/* 100% Image Width on Smaller Screens */@media only screen and (max-width: 700px)&#123; .modal-content &#123; width: 100%; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;图片模态框&lt;/h2&gt;&lt;p&gt;本实例演示了如何结合 CSS 和 JavaScript 来一起渲染图片。&lt;/p&gt;&lt;p&gt;首先，我们使用 CSS 来创建 modal 窗口 (对话框), 默认是隐藏的。&lt;p&gt;&lt;p&gt;然后，我们使用 JavaScript 来显示模态窗口，当我们点击图片时，图片会在弹出的窗口中显示：&lt;/p&gt;&lt;img id=&quot;myImg&quot; src=&quot;//www.runoob.com/wp-content/uploads/2016/04/img_lights.jpg&quot; alt=&quot;Northern Lights, Norway&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;!-- The Modal --&gt;&lt;div id=&quot;myModal&quot; class=&quot;modal&quot;&gt; &lt;span class=&quot;close&quot;&gt;×&lt;/span&gt; &lt;img class=&quot;modal-content&quot; id=&quot;img01&quot;&gt; &lt;div id=&quot;caption&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 获取模态窗口var modal = document.getElementById(&#x27;myModal&#x27;);// 获取图片模态框，alt 属性作为图片弹出中文本描述var img = document.getElementById(&#x27;myImg&#x27;);var modalImg = document.getElementById(&quot;img01&quot;);var captionText = document.getElementById(&quot;caption&quot;);img.onclick = function()&#123; modal.style.display = &quot;block&quot;; modalImg.src = this.src; modalImg.alt = this.alt; captionText.innerHTML = this.alt;&#125;// 获取 &lt;span&gt; 元素，设置关闭模态框按钮var span = document.getElementsByClassName(&quot;close&quot;)[0];// 点击 &lt;span&gt; 元素上的 (x), 关闭模态框span.onclick = function() &#123; modal.style.display = &quot;none&quot;;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、CSS3按钮back-ground属性设置颜色；font-size属性设置大小；border-radius属性设置圆角按钮；border属性设置边框颜色；:hover选择器来修改鼠标悬停在按钮上的样式，并用transition-duration属性来设置hover效果的速度；box-shadow属性为按钮添加阴影；opacity属性添加透明度，看上去类似禁用的效果。 按钮动画：1、鼠标移动时添加箭头标记； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;.button &#123; display: inline-block; border-radius: 4px; background-color: #f4511e; border: none; color: #FFFFFF; text-align: center; font-size: 28px; padding: 20px; width: 200px; transition: all 0.5s; cursor: pointer; margin: 5px;&#125;.button span &#123; cursor: pointer; display: inline-block; position: relative; transition: 0.5s;&#125;.button span:after &#123; content: &#x27;»&#x27;; position: absolute; opacity: 0; top: 0; right: -20px; transition: 0.5s;&#125;.button:hover span &#123; padding-right: 25px;&#125;.button:hover span:after &#123; opacity: 1; right: 0;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;按钮动画&lt;/h2&gt;&lt;button class=&quot;button&quot; style=&quot;vertical-align:middle&quot;&gt;&lt;span&gt;Hover &lt;/span&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2、点击时添加压下效果： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;.button &#123; display: inline-block; padding: 15px 25px; font-size: 24px; cursor: pointer; text-align: center; text-decoration: none; outline: none; color: #fff; background-color: #4CAF50; border: none; border-radius: 15px; box-shadow: 0 9px #999;&#125;.button:hover &#123;background-color: #3e8e41&#125;.button:active &#123; background-color: #3e8e41; box-shadow: 0 5px #666; transform: translateY(4px);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;按钮动画 - &quot;按压效果&quot;&lt;/h2&gt;&lt;button class=&quot;button&quot;&gt;Click Me&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 6、CSS分页当网站有很多个页面时，需要使用分页来为每个页面做导航，以下实例演示如何用HTML和CSS来创建分页。 1、用.active来设置当前页样式，且鼠标悬停可用:hover选择器来修改样式； 2、用border-radius来为选中的页码添加圆角样式，添加transition属性添加鼠标移动到页码上时的过渡效果，border属性来添加带边框分页； 3、margin属性为每个页码间添加空格，font-size属性设置分页的字体大小，在容器元素上添加text-align:center样式实现分页居中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;ul.pagination &#123; display: inline-block; padding: 0; margin: 0;&#125;ul.pagination li &#123;display: inline;&#125;ul.pagination li a &#123; color: black; float: left; padding: 8px 16px; text-decoration: none; transition: background-color .3s; border: 1px solid #ddd;&#125;ul.pagination li a.active &#123; background-color: #4CAF50; color: white; border: 1px solid #4CAF50;&#125;ul.pagination li a:hover:not(.active) &#123;background-color: #ddd;&#125;div.center &#123;text-align: center;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;分页居中&lt;/h2&gt;&lt;div class=&quot;center&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;«&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;6&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;7&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;»&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7、CSS框大小设置CSS3中box-sizing属性可以设置width和height中，包含了padding（内边距）和border（边框）； 1、不使用box-sizing属性时，高 = height + border + padding；宽 = width + padding + border。高度、宽度设置一样时，真实展示大小不一定一样，因为指定的padding不同。 2、使用box-sizing时，该属性同时包括内边框与边框，其实这样效果更好，在元素上添加box-sizing:border-box的简单实例。 8、CSS3弹性盒子Flex Box是一种新的布局模式，当页面需要适应不同的屏幕大小以及设备类型时，确保元素拥有恰当的行为的布局方式，提供flexbox的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 由弹性容器container和弹性子元素item组成，弹性容器通过设置display值为flex,将其定义为弹性容器。弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。以下元素展示了弹性子元素在一行内显示，从左到右: 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; .flex-container &#123; display: -webkit-flex; display: flex; width: 400px; height: 250px; background-color: lightgrey;&#125;.flex-item &#123; background-color: cornflowerblue; width: 100px; height: 100px; margin: 10px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;flex-item&quot;&gt;flex item 1&lt;/div&gt; &lt;div class=&quot;flex-item&quot;&gt;flex item 2&lt;/div&gt; &lt;div class=&quot;flex-item&quot;&gt;flex item 3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; justify-content内容对齐属性应用在弹性容器上，把弹性项沿着容器的主轴线对齐；justify-content: flex-start | flex-end | center | space-between | space-around align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。align-items: flex-start | flex-end | center | baseline | stretch flex-wrap 属性用于指定弹性盒子的子元素换行方式;flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit; align-content 属性用于修改 flex-wrap 属性的行为。类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。align-content: flex-start | flex-end | center | space-between | space-around | stretch 弹性子元素的属性： 1、排序：order；用整数值来定义排列顺序，数值小的排在前面。可以为负值 2、对齐：margin；设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 3、align-self 属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。align-self: auto | flex-start | flex-end | center | baseline | stretch 4、flex 属性用于指定弹性子元素如何分配空间。flex: auto | initial | none | inherit | [ flex-grow ] || [ flex-shrink ] || [ flex-basis ] 9、CSS3多媒体查询@media：CSS3的多媒体查询继承了CSS2中所有思想：取代了查找设备的类型，根据设置自适应显示。 多媒体查询由多种媒体组成，可以包含一个或多个表达式，表达式根据条件是否成立返回 true 或 false。 @media not|only mediatype and (expressions) { CSS 代码…; } 如果指定的多媒体类型匹配设备类型则查询结果返回 true，文档会在匹配的设备上显示指定样式效果。除非你使用了 not 或 only 操作符，否则所有的样式会适应在所有设备上显示效果。 not是用来排除掉某些特定的设备的，比如 @media not print（非打印设备）。 only: 用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件。 all:所有设备，这个应该经常看到。 以下实例在屏幕可视窗口尺寸小于 600 像素时将 div 元素隐藏： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;div.example &#123; background-color: yellow; padding: 20px;&#125;@media screen and (max-width: 600px) &#123; div.example &#123; display: none; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;屏幕可视尺寸小于 600 px 时，隐藏以下元素。&lt;/h2&gt;&lt;div class=&quot;example&quot;&gt;我是会隐藏的元素。&lt;/div&gt;&lt;p&gt;重置浏览器大小，查看效果。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 实例：制作一个电子邮箱的链接列表，注意 data-email 属性。在 HTML 中我们可以使用带 data- 前缀的属性来存储信息。当浏览器的宽度在 520 到 699px, 邮箱链接前添加邮件图标；当浏览器的宽度在 700 到 1000px, 会在邮箱链接前添加 “Email”；当浏览器的宽度大于 1001px 时，会在链接后添加邮件地址。我们会使用 data- 属性来为每个人名后添加邮件地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;ul &#123; list-style-type: none;&#125;ul li a &#123; color: green; text-decoration: none; padding: 3px; display: block;&#125;@media screen and (max-width: 699px) and (min-width: 520px), (min-width: 1151px) &#123; ul li a &#123; padding-left: 30px; background: url(email-icon.png) left center no-repeat; &#125;&#125;@media screen and (max-width: 1000px) and (min-width: 700px) &#123; ul li a:before &#123; content: &quot;Email: &quot;; font-style: italic; color: #666666; &#125;&#125;@media screen and (min-width: 1001px) &#123; ul li a:after &#123; content: &quot; (&quot; attr(data-email) &quot;)&quot;; font-size: 12px; font-style: italic; color: #666666; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;重置浏览器窗口，查看效果!&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;&lt;a data-email=&quot;johndoe@example.com&quot; href=&quot;mailto:johndoe@example.com&quot;&gt;John Doe&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-email=&quot;marymoe@example.com&quot; href=&quot;mailto:marymoe@example.com&quot;&gt;Mary Moe&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-email=&quot;amandapanda@example.com&quot; href=&quot;mailto:amandapanda@example.com&quot;&gt;Amanda Panda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"html","slug":"前端/html前端开发","date":"2020-09-02T03:17:52.000Z","updated":"2020-09-02T13:57:20.272Z","comments":true,"path":"2020/09/02/前端/html前端开发/","link":"","permalink":"http://yoursite.com/2020/09/02/%E5%89%8D%E7%AB%AF/html%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/","excerpt":"","text":"使用堆的数据结构来对数组进行排序，找出第k大的数据，时间复杂度为O(n) 堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 堆是非线性数据结构，相当于一维数组，有两个直接后继。 1、基础知识可视化的html页面结构中，只有&lt; body &gt;区域才会在浏览器中显示。 目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，需要在头部将字符声明为UTF-8或GBK。 1&lt;meta charset=&quot;UTF-8&quot;&gt; html元素语法：1、HTML元素以开始标签起始，以结束标签终止；2、元素的内容是开始标签与结束标签之间的内容；3、某些HTML元素具有空内容，空内容在开始标签中进行关闭，以开始标签的结束而结束；4、大多数HTML可拥有属性 嵌套的HTML元素大多数HTML元素可以嵌套，HTML元素可包含其他HTML元素，且HTML文档由相互嵌套的HTML元素组成。 通常不要忘了用结束标签，虽然可以正确显示，但忘记使用结束标签往往会产生不可预料的结果或错误。 HTML标签对大小写不敏感，请一般使用小写标签。 HTML属性元素可设置属性；属性可以在元素中添加附加信息；属性一般描述于开始标签；属性总是以名称、值对的形式出现。比如：name=”value”。 HTML链接由&lt; a &gt;标签定义，链接地址在href属性中指定。 1&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt; HTML格式&lt; hr &gt;标签在HTML页面中创建水平线，用于分隔内容； HTML注释：在开始括号之后紧跟一个叹号，结束括号前不需要 1&lt;!-- 这是一个注释 --&gt; &lt; br &gt;使用br标签：在不产生一个新段落的情况下进行换行； &lt; p &gt;定义一个段落 HTML使用标签&lt; b &gt;与&lt; i &gt;对输出的文本进行格式 1234&lt;b&gt;加粗文本&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;电脑自动输出&lt;/code&gt;&lt;br&gt;&lt;br&gt;这是 &lt;sub&gt; 下标&lt;/sub&gt; 和 &lt;sup&gt; 上标&lt;/sup&gt; HTML链接由&lt; a &gt;标签定义，链接地址在href属性中指定。 target属性：定义被链接的文档在何处显示；id属性：创建一个在HTML文档书签的标记； 1&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt; HTML头部&lt; head &gt;元素包含了所有的头部标签元素，可以插入脚本、CSS（样式文件）以及各种meta信息 &lt; title &gt; 定义不同文档的标题； &lt; base &gt; 描述了基本的链接地址、链接目标，作为默认链接； &lt; link &gt; 定义了文档与外部资源之间的关系，用于链接到样式表； &lt; style &gt;元素：定义了HTML文档的样式文件引用地址，在该元素中直接添加样式来渲染HTML； &lt; meta &gt;元素：描述了一些基本的元数据，通常用于指定网页的描述，关键词，文件最后的修改时间，作者和其他元数据。 &lt; script &gt; 用于加载脚本文件，如javascript HTML样式 CSS用于渲染HTML元素标签的样式，三种方式添加到HTML中：1、内联样式：在HTML元素中使用style属性；2、内部样式表：在HTML文档头部使用&lt; style &gt; 来包含CSS；3、外部引用：使用外部CSS文件。 最好的方式是外部引用；当特殊的样式需要应用到个别元素时，就可以使用内联样式，在相关标签中使用样式属性。 12&lt;h1 style=&quot;font-family:verdana;&quot;&gt;一个标题&lt;/h1&gt;&lt;p style=&quot;font-family:arial;color:red;font-size:20px;&quot;&gt;一个段落。&lt;/p&gt; 内部样式表：当单个文件需要特别样式时，在&lt; head &gt;部分通过&lt; style &gt;标签定义。 123456&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;background-color:yellow;&#125;p &#123;color:blue;&#125;&lt;/style&gt;&lt;/head&gt; 当样式被应用到很多页面时，外部样式表是理想选择，使用外部样式表，可以通过更改一个文件来修改一整个站点的外观。 123&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt; HTML图像图像由&lt; img &gt; 标签定义，为空标签，只有属性而无闭合标签，可使用源属性src，其值是图像的URL地址。alt属性用来为图像定义一串预备的可替换文本，在浏览器无法载入图像时，替换文本告诉读者他们失去的信息。 height、width属性用于设置图像的高度与宽度； HTML表格表格由&lt; table &gt;标签来定义，每个表格有若干行（由&lt; tr &gt;标签定义），每行被分割为若干单元格（由&lt; td &gt;标签定义），td指表格数据即数据单元格的内容，border属性来定义表格的边框。 12345678910&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; HTML列表无序列表用&lt; ul &gt;标签 有序列表始于&lt; ol &gt;标签，每个列表项始于&lt; li &gt;标签，且列表各项会自动使用数字来标记。 自定义列表：项目及其注释的组合；以&lt; dl &gt;标签开始，每个自定义列表项从&lt; dt &gt;开始，每个自定义列表的定义以 &lt; dd &gt;开始。 HTML区块可通过 &lt; div &gt;和&lt; span &gt;将元素组合起来 大多数HTML元素被定义为块级元素、内联元素；块级元素，通常以新行开始和结束，内联元素：显示时不会以新行开始； &lt; div &gt;元素是块级元素，可用于组合其他元素的容器，无特定含义，与CSS一同使用时，可用于对大的内容块设置样式属性；&lt; div &gt;元素的另一个常见作用是文档布局，用table显示表格化数据，用div进行表格定义布局。 &lt; span &gt;元素是内联元素，可用作文本的容器 HTML布局使用div、table元素来创建多列，CSS用于元素定位或为页面创建背景以及色彩丰富的外观。 使用CSS最大的好处是，如果将带啊存放到外部样式表中，那么站点更易于维护，通过编辑单一的文件就可以改变所有页面的布局。 HTML表单用于收集不同类型的用户输入，表单是一个包含表单元素的区域，表单元素允许用户在表单中输入内容，表单标签用&lt; form &gt;来设置。 输入元素input，输入类型由类型属性type定义。text：文本域；password：密码字段；radio：单选按钮；checkbox：复选框；submit：提交按钮 HTML框架、通过使用框架可以在同一个浏览器窗口显示不止一个页面； iframe语法：&lt; iframe src=”URL” &gt;&lt; /iframe &gt; 使用height、width来设置高宽，frameborder属性用于定义iframe表示是否显示边框 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;iframe src=&quot;demo_iframe.htm&quot; name=&quot;iframe_a&quot;&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=&quot;//www.runoob.com&quot; target=&quot;iframe_a&quot;&gt;RUNOOB.COM&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; 因为 a 标签的 target 属性是名为 iframe_a 的 iframe 框架，所以在点击链接时页面会显示在 iframe框架中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 因为 a 标签的 target 属性是名为 iframe_a 的 iframe 框架，所以在点击链接时页面会显示在 iframe框架中 HTML颜色由16进制符号来定义，RGB三向通道，FF FF FF 141个颜色名称是在HTML和CSS颜色规范定义的，17中表针颜色，124种非标准。 HTML脚本script标签用于定义客户端脚本，比如JavaScript，script元素即可包含脚本语句，也可以通过src属性指向外部脚本文件。JavaScript最常用与图片操作、表单验证以及内容·动态更新。 noscript提供无法使用脚本时的替代内容，可包含普通HTML页面的body元素中能够找到的所有元素。 HTML字符实体其中，某些字符是预留的，比如&gt; 、&lt;；因此需要在源代码中使用字符实体；常用字符实体是不间断空格&amp;nbsp，由于浏览器总会截断HTML页面的空格，只留下一个，因此如果需要在页面中增加空格数量，需要用到&amp;nbsp。 字符实体的名称对大小写敏感。 HTML URLURL是一个网页地址，Web浏览器通过URL从Web服务器请求页面，当点击页面上链接时，对应标签指向万维网上地址。 一个网页地址实例: http://www.runoob.com/html/html-tutorial.html 语法规则: scheme://host.domain:port/path/filename 说明: scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 runoob.com :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 http：超文本传输协议；https:安全超文本传输协议；ftp：文件传输协议；file：自己计算机上文件。 URL 只能使用 ASCII 字符集. 来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。 URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 HTML速查列表 2、H5前端开发为了更好地处理今天的互联网应用，HTML5添加了很多新元素及功能，比如: 图形的绘制，多媒体内容，更好的页面结构，更好的形式 处理，和几个api拖放元素，定位，包括网页 应用程序缓存，存储，网络工作者，等。 HTML5 Canvascanvas标签定义图形，只是图形的容器，必须使用脚本来绘制图形。 一个画布在网页中是一个矩形框，通过canvas元素来绘制，指定id属性，height、width属性来定义画布大小，使用style属性来添加边框。 H5内联SVGSVG指可伸缩矢量图形，用于定义用于网络的基于矢量的图形；使用XML格式定义图形，SVG图像在放大或改变尺寸的情况下其图形质量不会有损失，SVG是万维网联盟的标准。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt; &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot;&gt;&lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; SVG是一种使用XML描述2D图形的语言，而Canvas通过JavaScript绘制2D图形。 SVG基于XML，因此SVG DOM中的每个元素都是可用的，可以为某个元素附加JavaScript事件处理器，在SVG中，每个被绘制的图形均被视为对象，若SVG对象属性发生变化，那么浏览器能自动重现图形； Canvas是逐像素进行渲染，一旦图形被绘制完成，便不会得到浏览器的关注，如果其位置发生变化，则整个场景需要进行重新绘制。 HTML5 MathML标签math，MathML是数学标记语言，基于XML的标准，用于互联网上书写数学符号与公式。 HTML5拖放drag和drop拖放是一种常见的特性，即抓取对象以后拖到另一个位置，在H5中任何元素都可以拖放。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev)&#123; ev.preventDefault();&#125; function drag(ev)&#123; ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt; &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;img id=&quot;drag1&quot; src=&quot;/images/logo.png&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt; &lt;/body&gt;&lt;/html&gt; 1、设置元素可拖放：把draggable属性设置为true； 2、拖动什么：ondragstart属性调用了一个函数drag(event)，并在函数中用dataTransfer.setData()方法设置被拖数据的数据类型和值； 3、放到何处：ondragover事件规定在何处放置被拖动的数据，默认中无法将数据、元素放置到其他元素中，通过调用ondragover事件的event.preventDefault()方法 4、进行放置：当放置被拖数据时，会发生drop事件，在上面的例子中ondrop属性调用了一个函数，drop(event) 123456function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data));&#125; 调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 被拖数据是被拖元素的 id (“drag1”) 把被拖元素追加到放置元素（目标元素）中 H5地理定位H5视频H5规定了一种通过video元素来包含视频的标准方法， 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;您的浏览器不支持Video标签。&lt;/video&gt; video与audio元素同样拥有方法、属性、事件，且均可以使用JavaScript进行控制。方法：用于播放、暂停、加载；属性：时长、音量可以被读取或设置；其中DOM事件可以通知用户。下面的例子调用了play()和pause()方法，且使用了paused、width属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;button onclick=&quot;playPause()&quot;&gt;播放/暂停&lt;/button&gt; &lt;button onclick=&quot;makeBig()&quot;&gt;放大&lt;/button&gt; &lt;button onclick=&quot;makeSmall()&quot;&gt;缩小&lt;/button&gt; &lt;button onclick=&quot;makeNormal()&quot;&gt;普通&lt;/button&gt; &lt;br&gt; &lt;video id=&quot;video1&quot; width=&quot;420&quot;&gt; &lt;source src=&quot;mov_bbb.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;mov_bbb.ogg&quot; type=&quot;video/ogg&quot;&gt; 您的浏览器不支持 HTML5 video 标签。 &lt;/video&gt;&lt;/div&gt; &lt;script&gt; var myVideo=document.getElementById(&quot;video1&quot;); function playPause()&#123; if (myVideo.paused) myVideo.play(); else myVideo.pause(); &#125; function makeBig()&#123; myVideo.width=560; &#125; function makeSmall()&#123; myVideo.width=320; &#125; function makeNormal()&#123; myVideo.width=420; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; H5新的Input类型color、data(从日期选择器中选择时间)、datetime、datetime-local、email、month、number、range（用于应该包含一定范围内数字值的输入域）、search（定义一个搜索字段）、tel、time、url（自动验证url域的值）、week、 H5新的表单元素datalist：规定输入域的选项列表，该属性规定form、input域应该拥有自动完成功能，当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项，实现一个可输入下拉框的功能。 keygen：提供一种验证用户的可靠方法，规定用于表单的密钥生成器字段；当提交表单时，会生成2个键，一个为私钥、一个为公钥，私钥存储于客户端，公钥被发送至服务器，公钥可用于之后验证用户的客户端证书。 output元素：用于不同类型的输出 12345&lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt;0&lt;input type=&quot;range&quot; id=&quot;a&quot; value=&quot;50&quot;&gt;100 +&lt;input type=&quot;number&quot; id=&quot;b&quot; value=&quot;50&quot;&gt;=&lt;output name=&quot;x&quot; for=&quot;a b&quot;&gt;&lt;/output&gt;&lt;/form&gt; H5表单属性H5的form、input标签添加了几个新属性 新属性： autocomplete novalidate 新属性： autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height 与 width list min 与 max multiple pattern (regexp) placeholder required step H5语义元素语义元素：有意义的元素：能够清楚地描述其意义给浏览器和开发者； H5提供了新的语义元素来明确一个Web页面的不同部分。 header（头部区域，定义内容的介绍展示区域）、nav(定义导航链接)、section（定义文档节，页眉、章节）、article（定义独立的内容）、aside（主区域以外的内容，如侧边栏）、figcaption、figure、footer（底部区域） H5的Web存储在本地存储用户的浏览数据，数据以键值对存在，只允许该网页访问使用。 localStorage对象：用于长久保存整个网站的数据，保存数据无过期时间； sessionStorage对象：用于临时保存同一窗口数据，在关闭窗口后会删除数据。 H5 Web SQL数据库引入了一组使用SQL操作客户端数据库的APIs，拥有三个核心方法： 1、openDatabase:使用现有的数据库创建一个数据库对象； 2、transaction：控制一个事务，以及基于这种情况执行提交或回滚； 3、executeSql：执行实际的SQL查询。 H5 Web Workersweb worker是运行在后台的JS，不会影响页面的性能，当HTML页面执行脚本时，页面的状态不可响应直至脚本完成，而Web Worker是运行在后台的JS，独立于其他脚本，不影响页面的性能，可继续做想做的事情。 HTML5 WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"自然语言处理","slug":"机器学习/自然语言处理","date":"2020-08-29T11:02:46.000Z","updated":"2020-08-29T14:17:45.884Z","comments":true,"path":"2020/08/29/机器学习/自然语言处理/","link":"","permalink":"http://yoursite.com/2020/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/","excerpt":"","text":"词嵌入one-hot词向量构造起来很容易，但并不是一个含选择，因为其并不能准确地表达不同词之间的相似度，word2vec工具提出解决了上述问题，将每个词表示成一个定长的向量，并使这些向量能较好地表达不同词之间的相似和类比关系，包括跳字模型和连续词袋模型。 跳字模型跳字模型假设：基于某个词来生成它在文本序列周围的词。 在该模型中，每个词被分为2个d维向量，用来计算条件概率，假设该词在词典索引为i，当它为中心词时向量表示为Vi，而它为背景词时向量表示为Ui。 设中心词Wc在词典中索引为c，背景词Wo在词典中索引为o，故给定中心词生成背景词的条件概率可以通过对向量内积做softmax运算而得到： 跳字模型的参数是每个词所对应的中心词向量和背景词向量，训练中一般使用最大似然函数来学习模型参数 连续词袋模型与跳字模型不同的是，连续词袋模型假设：基于某中心词在文本序列前后的背景词来生成该中心词。因为连续词袋模型的背景词有很多个，因此将这些取平均，然后使用和跳字模型一样的方法来计算条件概率。 同样，连续词袋模型的最大似然估计等价于最小化损失函数。 近似训练跳字模型的核心在于，使用softmax运算得到给定中间词Wc生成背景词Wo的条件概率，，该条件概率对应的对数损失； 由于softmax运算考虑背景词可能是词典中任一词，以上损失包含了词典大小数目的项的累加。因此每次梯度计算可能开销过大，有下面两种方法来进行近似训练。 负采样：修改了原来的目标函数，使用相互独立事件来构造损失函数，其训练中每一步梯度计算开销与采样的噪声词的个数线性相关。 层序softmax：使用了二叉树这一个数据结构，树的每个叶结点代表词典中的每个词，并根据根节点到叶节点的路径来构造损失函数，每一步的梯度计算开销与词典大小的对数相关。 word2vec的实现预处理数据集PTB是常用的语料库 1、建立词语索引：将词映射到整数索引 2、二次采样：：文本中一般会出现一些高频词，而在背景窗口中，与高频词一起出现会更有益。故训练词嵌入模型时可以对词进行二次采样，即每个索引词都有一定概率被丢弃。 3、提取中心词与背景词：我们将与中心词距离不超过背景窗口大小的词作为背景词，定义函数提取出所有中心词和它们的背景词。它每次在整数1与max_window_size之间随机均匀采样一个整数作为背景窗口大小。 负采样读取数据集使用随机小批量来读取数据集，小批量读取函数batchify，其输入data是一个长度为批量大小的列表，其中每个元素分别包含中心词center、背景词context、噪声词negativ，其返回的小批量数据符合我们需要的格式。 跳字模型嵌入层：获取词嵌入的层称为嵌入层，在Gluon中可以通过创建nn.Embedding实例得到。其权重为一个矩阵，行数为词典大小、列数为每个词向量的维度。嵌入层输入为词的索引，返回为权重矩阵的第i行作为它的词向量。 小批量乘法：batch_dot对两个小批量中的矩阵一一做乘法。 跳字模型前向计算：输入包含中心词索引center以及连结的背景词与噪声词索引contexts_and_negatives。 定义损失函数：使用Gluon的二元交叉熵函数 子词嵌入fastText英语单词通常由其内部结构和形成方式，而在word2vec中，我们并没有直接利用构词学中信息，而在fastText中，每个中心词被表示为子词的集合，利用 全局向量的词嵌入GloVe文本分类情感分析：使用循环神经网络文本分类是自然语言处理的一个常见任务，将一段不定长的文本序列变换成文本的类别。 子问题：使用文本情感分析来分析文本作者的情绪，即情感分析。 文本情感分析：使用卷积神经网络textCNN其实，我们也可以将文本看作一维图像，从而可以使用一维卷积神经网络来捕捉临近词之间的关联， 编码器-解码器Seq2seq前面都是表征并变换了不定长的输入序列，但在自然语言处理的很多应用中，输入、输出都可以是不定长序列，此时可用编码、解码器或Seq2seq模型。两个模型的本质都用到了两个循环神经网络，分别为编码器、解码器。+","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"计算机视觉","slug":"机器学习/计算机视觉","date":"2020-08-28T10:44:52.000Z","updated":"2020-08-29T11:01:56.399Z","comments":true,"path":"2020/08/28/机器学习/计算机视觉/","link":"","permalink":"http://yoursite.com/2020/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/","excerpt":"","text":"在卷积神经网络中介绍了计算机视觉领域常用的深度学习模型，并实践了简单的图像分类。先描述目标检测的流程与方法，再使用全卷积网络对图像做语义分割，之后用样式迁移技术生成图像。 图像增广1、扩大样本数据集；2、随机改变训练样本可降低模型对某些属性的依赖。两者均为了提高模型的泛化性。 常用方法：翻转和裁剪、变化颜色、叠加多个图像增广方法； 为了在预测时获得准确结果，图像增广通常仅用于训练集，而不在预测时使用含随机操作的图像增广。 Gluon数据集提供的transform模块中，transform_first函数将图像增广应用在每个训练样本（图像和标签）的第一个元素，即图像之上。 用增广后图像训练模型：1、定义try_all_gpus函数，获取所有能用的GPU； 2、定义辅助函数_get_batch将小批量数据样本batch划分，并复制到ctx变量所指定的各个显存上； 3、定义evaluate_accuracy函数来评价模型的分类准确性，该函数通过辅助函数_get_batch使用ctx变量所包含的所有GPU来评价模型； 4、定义train函数使用多GPU训练并评价模型； 5、最终定义train_with_data_aug函数，来使用图像增广来训练模型；该函数获取所有GPU，并将Adam算法作为训练优化算法，之后将图像增广应用于训练数据集上，最后调用刚定义的train函数训练并评价模型。 12345678def train_with_data_aug(train_augs, test_augs, lr = 0.001): batch_size, ctx, net = 256, try_all_gpus(), d2l.resnet18(10) net.initialize(ctx=ctx, init=init.Xavier()) trainer = gluon.Trainer(net.collect_params(), &#x27;adam&#x27;, &#123;&#x27;learning_rate&#x27;: lr&#125;) loss = gloss.SoftmaxCrossEntropyLoss() train_iter = load_cifar10(True, train_augs, batch_size) test_iter = load_cifar10(False, test_augs, batch_size) train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs=10) 图像微调由于收集数据所需要的成本较高，应用迁移学习：将从源数据集学到的知识迁移到目标数据集上。例：可从图形数据集训练的模型中抽取较通用的模型特征，边缘、纹理、形状、物体组成识别等等。 微调时常用的一种迁移学习技术，当目标数据集远小于源数据集时，微调有助于提升模型的泛化能力，步骤包括： 1、在源数据集上预训练一个神经网络模型，即源模型； 2、创建一个新的神经网络模型，即目标模型，其复制了源模型上除了输出层以外的所有模型设计与参数。假设该模型参数包含了源数据集上学习到的知识，且同样适用于目标数据集。 3、为目标模型添加一个输出大小为目标数据集类别个数的输出层，并初始化该层的模型参数。 4、在目标数据集上训练目标模型，将从头训练输出层，而其余层的参数将会基于源模型的参数微调得到。 热狗识别基于一个小数据集对在ImageNet数据集上训练好的ResNet模型进行微调。 1、获取数据集； 2、定义和初始化模型：使用在ImageNet数据集上预训练的ResNet-18作为源模型，该源模型实例含有两个成员变量，即features和output。前者包括模型输出层以外的所有层，后者为模型的输出层，这样的划分方便微调除输出层以外所有层的模型参数。 3、微调模型：先定义一个使用微调的训练函数train_fine_tuning，以便多次调用。 123456789def train_fine_tuning(net, learning_rate, batch_size=128, num_epochs=5): train_iter = gdata.DataLoader(train_imgs.transform_first(train_augs), batch_size, shuffle=True) test_iter = gdata.DataLoader(test_imgs.transform_first(test_augs), batch_size) ctx = d2l.try_all_gpus() net.collect_params().reset_ctx(ctx) net.hybridize() loss = gloss.SoftmaxCrossEntropyLoss() trainer = gluon.Trainer(net.collect_params(), &#x27;sgd&#x27;, &#123;&#x27;learning_rate&#x27;: learning_rate, &#x27;wd&#x27;: 0.001&#125;) d2l.train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs) 一般来说，微调参数会使用较小的学习率；而从头训练输出层可以使用较大学习率。 目标检测与边界框在图像分类任务里，假设只有一个主体目标；而目标检测往往是图像中有多个感兴趣的目标。 目标检测算法通常会在输入图像中采样大量的区域，，然后判断是否包含感兴趣的目标，并调整区域边缘从而更准确地预测目标的真是边界框。 锚框：以每个像素为中心生成多个大小和宽高比不同的边界框。 交并比：（若某个锚框较好地覆盖了图像的狗，那么较好该如何量化）直观的方法是，衡量锚框与真实边界框间的相似度Jaccard系数可以衡量两个集合的相似度，Jaccard系数等于二者交集大小除以二者并集大小。 在训练集中，将每一个锚框视为一个训练样本，为了训练目标检测模型，需为每个锚框标注两个标签：1、锚框所含目标的类别；2、真实边界框相对锚框的便宜量offset。 在目标检测的训练集中，每个图像已经标注了真实边界框的位置及所含目标的类别，那么生成锚框后，如何为锚框分配与其相似的真实边界框呢？ 分配真实边界框1、锚框有Na个，真实边界框有Nb个，定义矩阵为Na X Nb，其第i列第j行的元素为锚框Ai与真实边界框Bj的交并比。则通过不停找出矩阵最大元素，且每找出一个元素则丢弃该行列的元素，直至矩阵丢弃完，只剩Na - Nb个锚框。 2、遍历剩下的锚框，只有该交并比大于预先设定的阈值时，才为锚框分配真实边界框Bj。 3、如果一个锚框A被分配了真实边界框B，将A的类别设为B的类别，并根据B和A的中心坐标的相对位置以及两个框的相对大小为锚框A标注偏移量。如果一个锚框没有被分配真实边界框，需将该锚框的类别设为背景，称为负类锚框。 4、通过contrib.nd模块中的MultiBoxTarget函数来为锚框标注偏移量和类别。该函数将背景设定为0，并从令0开始的目标类别的整数索引自加1，并通过expand_dims函数为锚框和真实边界添加样本维，并构造形状为（批量大小，包括背景的类别个数，锚框数）的任意预测结果。 非极大值抑制当锚框数量较多时，同一目标可能输出较多相似的。用非极大值抑制来移除：对一个预测边界框B，模型会计算其各个类别的预测概率，其中最大概率对应的类别即B的预测类别，且在同一图像上将预测类别置信度从高到低排列，得到列表L。从L中选取置信度最高的预测边界框B1为基准，将与B1交并比大于某阈值的从L中移除，阈值为预定的超参数，此时L保留了置信度最高的边界框并移除了与之相似的其他预测边界框。 多尺度目标检测 如果以图像每个像素中心都生成锚框，很容易生成过多锚框而造成计算量过大，方法一：在输入图像中均匀采样一小部分像素，并以采样的像素为中心生成锚框。之后既然我们已经在不同尺度下生成了不同大小的锚框，相应的需要在不同尺度下检测不同大小的目标，基于卷积神经网络有如下的方法： 在某尺度下，假设我们根据Ci张形状为h X w的特征图生成h X w组不同中心的锚框，且每组锚框的个数为a。 假设这里的Ci张特征图为卷积神经网络根据输入图像做前向运算所得的中间输出，根据感受野的定义，特征图在相同位置的Ci个单元在输入图像的感受野相同且表征了同一感受野内的输入图像信息。因此我们将这Ci个单元变换为该位置为中心生成的a个锚框的类别和偏移量，故本质上使用感受野内的信息来预测锚框。 因此不同大小的感受野用于检测不同大小的目标，可通过设计网络来控制输出层感受野大小，从而分别用来检测不同大小的目标。 单发多框检测由一个基础网络块和若干多尺度特征块串联而成。其中网络块用于从原始图像中抽取特征，因此一般会选择常用的深度卷积神经网络，例如：在分类层之前截断的VGG、或者用ResNet替代。 设计基础网络，使其输出的高宽较大，这样一来基于该特征图生成的锚框数量较多，用于检测较小目标；接下来每个多尺度特征块将上一层提供的特征图的高、宽减小，使感受野变广阔，这样越靠顶部其特征图越小，生成锚框越少，适合检测尺寸大的目标。借此，单发多框检测是一个多尺度的目标检测。 类别预测层如果用全连接层作为输出，容易导致模型参数过多，故像NIN一样使用卷积层的通道进行输出类别的预测，来降低模型复杂度。即使用一个保持输入高、宽的卷积层，使输入、输出的空间坐标一一对应 边界预测层设计与类预测层类似，需要为每个锚框预测4个偏移量。 连接多尺度的预测由于每个尺度的特征图形状与锚框个数都可能不同，因此不同尺度预测输出形状可能不同。需要将他们变形成统一的格式并将多尺度的预测连结，从而让后续的计算更简单。 高、宽减半块为了能多尺度地检测目标，需要定义高宽减半块，其串联了两个填充为1的3X3卷积层和步幅为2的2X2最大池化层，卷积层不改变特征图形状，而后面池化层将特征图的高、宽减半。 基础网络块用于在原始图像中抽取特征，此处串联3个高、宽减半块，并将通道数翻倍，则当输入图像形状为256X256时，基础网络块的输出特征图的形状为32X32。 完整的模型单发多框检测一共包括5个模块，每个模块即生成锚框，又来预测锚框的类别与偏移量。第一模块为基础网络块，二至四模块为高宽减半块，第五模块使用全局最大池化层将高和宽降到1。 单发多框检测训练模型1、读取数据集并初始化；2、定义损失函数与评价函数：一、有关锚框类别的损失，图像分类问题一般使用的：交叉熵函数 二、有关正类锚框偏移量的损失：预测偏移量是一个回归问题，因此不用平方损失，而用L1范数损失，即预测值与真实值之间差的绝对值。 3、训练模型在模型的前向计算过程中生成多尺度的锚框anchors，并为每个锚框预测类别cls_preds和偏移量bbox_preds，之后根据标签信息Y为生成的每个锚框标注类别和偏移量。最后，根据这两者值来计算损失函数。 4、预测目标在预测阶段，我们读取图像并变换尺寸，转换为卷积层所需的四维格式，通过MultiBoxDetection函数根据锚框及其预测偏移量得到预测边界框，并通过非极大值抑制移除相似的预测边界框；最后，将置信度不低于0.3的边界框筛选为最终输出。 区域卷积神经网络R-CNNR-CNN首先对图像选取若干提议区域，并标注它们的类别和边界框，之后用卷积神经网络对每个提议区域做前向运算来抽取特征。 1、对输入图像进行选择性搜索，来选取多个高质量的提议区域，通常在多个尺度下选取，并标注类别与真实边界框； 2、选取一个预训练的卷积神经网络，并将其在输出层之前截断，并将每个提议区域变形为网络所需要的尺寸，并通过前向计算输出抽取的提议区域特征； 3、将每个提议区域的特征连同其标注的类别作为一个文本，训练多个支持向量机对目标进行分类，其中每个支持向量机用来判断样本是否属于一个实例； 4、将每个提议区域的特征连同其标注的边界框作为一个样本，训练线性回归模型来预测真实边界框。 FAST R-CNNR-CNN抽取的独立特征常有大量重复计算，利用FAST R-CNN进行简化， FASTER R-CNN将选择性搜索替换成区域提议网络，从而减少提议区域的生成数量，以达到较精确的目标检测结果。 Mask R-CNN当训练数据还标注了每个目标在图像上的像素级位置，那么Mask R CNN模型能有效利用这些详尽的标注信息 语义分割和数据集语义分割问题：关注如何将图像分割成属于不同语义类别的区域，且均为像素级，相比于锚框更加精确。 图像分割问题：利用像素间相关性将图像分割成若干区域，且训练时并不需要像素有关的标签信息，预测时也无法保证希望得到的语义。 实例分割问题：研究如何识别图像中各个目标实例的像素级区域，不仅要区分语义，还要区分不同目标实例，比如：区分两条同样语义的狗。 Pascal VOC2012数据集 由于语义分割的输出图像和标签在像素上一一对应，所以将图像随机裁剪成固定尺寸而不是缩放。 全卷积网络FCNFCN实现了从图像像素到像素类别的变换；FCN通过转置卷积层，将中间层特征图的高、宽变换回输入图像的尺寸，从而令预测结果与输入图像在空间维上一一对应。 转置卷积层构造模型1、先使用卷积神经网络来抽取图像特征； 2、通过1X1卷积层将通道数变换成类别个数； 3、通过转置卷积层，将特征图的高、宽变换为输入图像的尺寸，使模型输出与输入图像的高、宽相同，并在空间位置一一对应，最终输出的通道中包含了该空间位置像素级别的类别预测； 样式迁移使用卷积神经网络自动将某图像中的样式应用在另一图像上，两张输入图像：内容图像、样式图像。 具体实施 1、初始化合成图像，一般初始化成内容图像，该图像便是样式迁移过程中需要迭代的模型参数。 2、选择一个预训练的卷积网络来抽取图像的特征，其中模型参数在训练时无需更新，深度神经网络凭借多个层级逐级抽取图像的特征，可以选择其中某些层的输出作为内容特征； 3、正向传播计算样式迁移的损失函数，通过反向传播迭代模型参数，即不断更新合成图像。 预处理和后处理图像预处理：在RGB三个通道分别做标准化，将结果变换成输入形式； 后处理：将输出图像中的像素值还原回标准化之前值； 抽取特征使用基于ImageNet数据集训练的VGG-19模型来抽取图像特征； 定义损失函数内容损失：利用平方误差函数衡量合成图像与样式图像在内容上差异； 样式损失：利用平方误差函数衡量合成图像与样式图像在样式上差异； 总变差损失：用于降噪，使合成图像中噪点（特别亮或特别暗的颗粒像素）减少。 损失函数为以上三者的加权和。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"优化算法与计算性能","slug":"机器学习/机器学习优化算法","date":"2020-08-28T04:18:39.000Z","updated":"2020-08-28T10:43:40.737Z","comments":true,"path":"2020/08/28/机器学习/机器学习优化算法/","link":"","permalink":"http://yoursite.com/2020/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","excerpt":"","text":"优化与深度学习一般会预定义一个损失函数，再使用优化算法试图将其最小化，这样的损失函数通常被称为优化问题的目标函数，通常只考虑最小化目标函数。由于优化算法的目标函数通常是一个基于训练集的损失函数，故优化目的在于降低训练误差，而深度学习目的在于降低泛化误差，因此需要注意过拟合问题。 很多优化问题并不存在解析解，因此需要通过优化算法有限次迭代模型参数来尽可能降低损失函数值。 局部最小值当一个优化问题的数值解在局部最优解附近时，由于目标函数有关解的梯度接近或变成0，因此最终迭代可能只令目标函数局部最小化而非全局最小化。 鞍点在二维空间函数中，f(x,y) = x^2 - y^2，鞍点位置是x = 0处。且在图的鞍点位置，目标函数在x轴方向上是局部最小值，但在y轴方向上是局部最大值。 假设函数的输入为k维向量，输出为标量，则其海森矩阵有k个特征值；可通过该函数在对应点，其海森矩阵的特征值的正负，来判断该点为：（特征值全为负）局部最大值、（特征值全为正）局部最小值，还是（特征值有正有负）鞍点。 而通过随机矩阵理论可知：对一个大的高斯随机矩阵来说，任一特征值为正或负的概率均为0.5，故局部最小、最大值的可能性均为(0.5)^k，目标函数的鞍点比局部最值更常见。 梯度下降与随机梯度下降一维梯度下降：通过用X - nf*(x)来代替x的方法，利用该式子不断迭代x，直到达到停止条件（一般为f’(x) ^2已经足够小，或者迭代次数已到达某个值）。其中正数n通常叫做学习率，为超参数，需人工设定。学习率过小：x更新缓慢，需要更多次迭代；学习率过大：可能会导致taylor展开的不等式不一定成立，迭代x不一定减小f(x)的值。 多维梯度下降：方向导数给出了x沿所有可能方向的变化率，为了最小化f，希望能找到f能被下降最快的方向，故利用梯度下降算法不断降低f的值。 随机梯度下降：n为训练数据样本数，x为模型的参数向量。则如果使用梯度下降时，会使用各个样本的平均作为，每次自变量迭代的计算开销为O(n)，随n线性增长，因此若样本数大时，每次迭代的计算开销高。而随机梯度下降减少了计算开销，在每次迭代中随机均匀采样样本索引来计算梯度，从而减少每次迭代的开销。 小批量随机梯度下降在每次迭代，梯度下降用整个训练集来计算梯度，而小批量梯度随机下降，利用随机均匀采样一个由样本索引组成的小批量B。 且由于随机采样得到梯度的方差在迭代过程中无法减小，因此实际中，小批量随机梯度下降的学习率需要在迭代过程中自我衰减。 在Gluon中可用创建Trainer实例来调用调优算法。 动量法梯度下降又称最陡下降：自变量在当前位置下降最快的方向，在每次迭代中梯度下降根据自变量当前位置沿着梯度来更新自变量，然而，若自变量的迭代方向仅仅取决于自变量当前位置，可能会带来问题。 在二维或者多维的变量中，梯度下降往往难以同时兼顾学习率与确保f(x)下降；需要确保学习率较小，从而避免自变量在竖直方向越过函数最优解，但会因此导致向最优解移动缓慢。 动量法：设时间步t的自变量为Xt，学习率为Nt，动量法对每次迭代的步骤做出以下修改：Vt &lt;- yV(t-1)；Xt &lt;- X(t-1) - Vt。y为动量超参数，范围在[0，1） 指数加权移动平均： 由指数加权平均理解动量法： 相对于小批量随机梯度下降，动量法需要对每一个自变量维护一个同它一样形状的速度变量，且在超参数中多了动量超参数。 在Gluon中，需要在Trainer实例中通过momentum来指定动量超参数，即可使用动量法。 AdaGrad算法动量法依赖指数加权移动平均，使得自变量的更新方向更加一致，从而降低自变量在梯度较大的维度发散的可能。 而AdaGrad算法根据自变量在每个维度的梯度大小，来调整各个维度的学习率，从而避免统一的学习率难以适应所有维度的问题。 AdaGrad算法会使用一个小批量随机梯度Gt按元素平方的累加变量St： Gluon中使用名称为”adagrad”的Trainer实例来调用该算法训练模型。 RMSProp算法AdaGrad算法在迭代后期由于学习率过小，可能比较难找一个有用的解：因此用RMSProp算法改良后。 不同于AdaGrad算法里状态变量St是截至时间步t所有小批量随机梯度Gt按元素平方和。RMSProp算法将这些梯度按元素平方做指数加权移动平均，即 Gluon中使用名称为”rmsprop”的Trainer实例来调用该算法训练模型，且超参数由gammal指定。 还有AdaDelta算法、Adam算法 深度学习计算性能命令式和符号式混合编程之前一般使用Sequential类来串联多个层，先为了使用混合式编程，使用HybridSequential类来替换Sequential类。 异步运算MXNet使用异步运算来提升性能，通过前端线程与后端线程的交互进行异步运算：前端线程无需等待当前指令从后端线程返回结果就继续执行后面的指令。 但同样异步运算会占据额外的内存：由于深度学习模型往往比较大，且内存资源通常有限，因此在训练模型时通常使用同步函数，而不用异步运算。 自动并行计算MXNet后端会自动构建计算图，依据该图，系统会自动知道所有计算的依赖关系。 包括CPU与GPU的并行计算、多GPU计算、数据并行。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"C语言程序设计","slug":"C++/C语言程序设计","date":"2020-08-25T12:54:02.000Z","updated":"2020-09-08T11:32:46.451Z","comments":true,"path":"2020/08/25/C++/C语言程序设计/","link":"","permalink":"http://yoursite.com/2020/08/25/C++/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"一、基础知识在命令行中进行编译运行12345678~/project ls -l #执行命令ls，用于列出当前所在计算机存储位置中的文件和目录，并为其配置参数-l-rw-r--r-- 1 user user 112 Aug 25 20:48 main.c ~/project gcc -o program main.c #gcc为编译器名称，用该命令告诉gcc，将main.c的代码文件编译成名为program的可执行文件~/project ls -l-rw-r--r-- 1 user user 112 Aug 25 20:48 main.c -rwxrwxr-x 1 user user 8512 Aug 25 21:35 program #目录中新增了program的可执行文件./program #执行程序 变量相关变量名：由大、小写字母，下划线，数字组成；数字不能开头；不能是有特定含义的保留字。 作用域：变量声明语句之后，包裹了它声明语句的最内一层{}中，且一个变量在其作用域内仅能声明一次，但能够赋值多次，只要是在其作用域内的赋值，均起作用。 这些在结构化语句的内部的变量的作用域为结构化语句内部。注意，对于switch中在case内部定义的变量的作用域就是在当前case。我们可以简单理解为在大括号内部定义的变量，其作用域就是在当前大括号中，在当前大括号外部无效。对于循环嵌套和分支嵌套程序来说都是一样的。关于这一点不再赘述。 注意，当一个嵌套结构中出现两个不同作用域的变量时，变量的名称可以相同，在使用时以其小作用域为准。 与局部变量相对的就是全局变量，我们把定义在函数外部的变量称为全局变量，这些变量的作用域为整个程序，也就是所有的函数和结构化语句都能使用它们。 甚至多个源文件一起编译时，全局变量在其他文件中也能够生效需要用extern关键字在函数外部声明一个文件外部变量。 递归问题在头递归的实现中，我们在进行下一层的调用前，没有进行计算，只有在下一层的返回之后，我们才完成了这一层的运算。 在尾递归的实现中，我们在进行下一层的调用前，会先进行计算，而在最终一般条件满足时，会将计算的结果逐层直接返回。 声明与实现分离如果采用直接定义的方式来创造函数，则需要时刻关注它们之间依赖关系，并正确排序，不现实。需要进行声明与实现的分离，从而简化这一过程。 只需要在需要用到该函数前进行声明即可，定义可放在执行程序的后面位置，函数声明时可以不写函数参数名，只写参数类型。 变量地址做函数参数swap函数中，由于该函数定义的形式参数a,b作用域有限，因此swap函数内的交换并不会影响main函数中x，y大的值。此时，需修改成传入参数x、y的地址，直接对其地址进行操作。 123456789101112void swap(int *a, int *b);int main()&#123; int x,y; swap(&amp;x, &amp;y);&#125;void swap(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125; 函数地址做函数参数C语言中函数与变量类似，也有其自己的内存地址，但函数不能像变量一样可以进行值传递，在想要将函数作为另一个函数的参数进行传递时，需要传递它的地址。 123int g(float (*f)(int), int a)&#123; return f(a);&#125; 上面这种情况，函数g需要有一个形式参数来接收函数地址，其第一个参数需要一个返回值类型为float且有一个int类型参数的函数；第二个参数就是普通的int类型值 其实直接写f(a)和float (*f)(int)来调用其地址本质上是一样的。因此声明时需要如上所示去取函数的地址，而调用时，直接函数名与变量一起传入也是可以的。g(f(x), a)。 有关代码风格的空格哪些使用空格的地方： 1、+、-、&gt;、==、|、&amp;&amp;等双目运算符前后； 2、if、switch、for、while等关键字，函数名和之后的左小括号之间； 3、不在行尾的逗号、分号之后，例如for循环中的分号之后； 4、必须加空格的情况：如return后面不加空格就会报语法错误的情况。 数组相当于定义了一系列地址相邻的元素，与取变量地址的方式一致，可以通过&amp;radius[1]的方式取得数组radius在索引位置1元素的地址。在C语言中，对一个元素的地址加上位移值n得到的就是这个元素往后数n后所在元素的地址。 且一般来说，在地址上进行运算的方式访问数组的效率比利用索引更快，例如：你只希望访问数组中每一个元素一次时，可用while循环内使用地址上运算的方式，使用数组中每一个元素的值，而无需关心数组的索引是谁。 123int *p_radius;p_radius = &amp;radius[0];//这里*(p_radius + 1)或者（&amp;radius[0] + 1）都会得到radius[1]元素的地址。 字符串的本质是数组字符串实际上是一个元素为字符的数组，例如“Hello”由五个字母字符与一个空字符\\0组成；任何字符串的内部表示都会以空字符‘\\0’作为结尾，故可以以此方式找到字符串结尾。 同样，在C中提供字符数组初始化的简化方式： 1char string[] = &quot;Hello&quot;; 字符串更严谨应该被称为 字符串字面量，其表现为一对双引号包裹的0个或者多个字符；字面量并非仅包含字符串常量 1234int a;a = 1234;//语句中的1234其实就是一个整数型字面量，其实是将一个整数型字面量的值放入了变量中作为值。在字面量后往往需要增加一个后缀标记类型。L：长类型；U：无符号类型；F：浮点类型。//除了十进制，也可用其他进制表示字面量。 除了用字符数组存储字符串，也可声明一个用于存储字符地址的变量操作字符串 123456789101112#include &lt;stdio.h&gt;//string的地址是内存栈区的地址；string2则是直接关联到&quot;Hello&quot;字符串字面量在内存中字面量池的地址。int main() &#123; char string[] = &quot;Hello&quot;; printf(&quot;%s\\n&quot;, string); char *string2 = &quot;Hello&quot;; printf(&quot;%s\\n&quot;, string2); printf(&quot;%p\\n&quot;, &amp;string); //0x7fff09dd0480 printf(&quot;%p\\n&quot;, string2);//0x4allc4 printf(&quot;%p\\n&quot;, &amp;&quot;Hello&quot;);//0x4allc4 return 0;&#125; 按位运算结构体使用struct定义完结构体后，每当我们需要使用结构体时都需要写一次struct关键字，而其实C语言中提供了一种为某一已知类型添加别名的方式：typedef；typedef 原类型 类型别名 12345678typedef struct point Point;//完成设置别名后再进行变量声明时，可以不写struct point point1;Point point1;//也可以在定义结构体时同时在前面加上typedef，这样可以把两步合二为一typedef struct point&#123; float x; float y;&#125; Point; 函数的返回值也可以通过结构体的方式来进行返回，同样传入参数也可以以结构体的形式传入， 但若以结构体变量值的形式进行传递参数，这种传值的效率相对来说是低的（特别是结构体内成员特别多时），当vector_add函数不会改变传入参数的值时，没有必要采用会使用额外内存并需要赋值传入值到额外内存的“传值”作参数的方式，可将传入的参数改成指针的形式。 同时这样修改后调用函数参数时，也要加上取地址符号&amp;。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;math.h&gt;typedef struct point &#123; float x; float y;&#125; Vector;Vector vector_add(Vector *v1, Vector *v2) &#123; Vector v_result; v_result.x = v1-&gt;x + v2-&gt;x; v_result.y = v1-&gt;y + v2-&gt;y; return v_result;&#125;int main() &#123; Vector v1 = &#123; 2.4f, 2.5f &#125;; Vector v2 = &#123; 3.7f, 4.4f &#125;; Vector v_result; v_result = vector_add(&amp;v1, &amp;v2); printf(&quot;(%f, %f)\\n&quot;, v_result.x, v_result.y); return 0;&#125; 以后再用到(*结构体指针名).结构体成员元素名形式的代码时，都可以将其写为：结构体指针名-&gt;结构体成员元素名。 用结构体构建一个简单链表的方法如下图： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int number; struct node*next;&#125;Node;Node *create_node(int new_number)&#123; Node *temp_node; temp_node = (Node *) malloc(sizeof(Node)); temp_node-&gt;number = new_number; temp_node-&gt;next = NULL; return temp_node;&#125;int main() &#123; Node *head; head = create_node(1); head-&gt;next = create_node(2); head-&gt;next-&gt;next = create_node(3); printf(&quot;%d\\n&quot;, head-&gt;next-&gt;number); return 0;&#125; 约瑟夫环问题N个同学围成圆圈，每个人被顺序地编了一个序号，从编号为K的人开始报1，之后按顺序增长，直至报数字M的人出列，出列人的下一个人从1继续开始报数，重复该过程直至所有人均出列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node &#123; int data; struct node *next;&#125; Node;Node *circle_create(int n);void count_off(Node *head, int n, int k, int m);int main() &#123; int n, k, m; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m); Node *head = circle_create(n); count_off(head, n, k, m); return 0;&#125;Node *circle_create(int n) &#123; Node *temp, *new_node, *head; int i; // 创建第一个链表节点并加数据 temp = (Node *) malloc(sizeof(Node)); head = temp; head-&gt;data = 1; // 创建第 2 到第 n 个链表节点并加数据 for(i = 2; i &lt;= n; i++) &#123; new_node = (Node *) malloc(sizeof(Node)); new_node-&gt;data = i; temp-&gt;next = new_node; temp = new_node; &#125; // 最后一个节点指向头部构成循环链表 temp-&gt;next = head; return head;&#125;void count_off(Node *head, int n, int k, int m) &#123; int i, j; Node *newNode, *beginNode; for (i = 0; i &lt; n - 1; i++)&#123; beginNode = head-&gt;next; &#125; newNode = head-&gt;next; for (i = 0; i &lt; k - 1; i++)&#123; beginNode = head; head = newNode; newNode = head-&gt;next; &#125; for (i = 0; i &lt; n; i++)&#123; for (j = 1; j &lt; m ; j++)&#123; beginNode = head; head = newNode; newNode = head-&gt;next; &#125;if (m == 2 &amp;&amp; i == n - 1) head = newNode; printf(&quot;%d&quot;, head-&gt;data); if (i != n - 1) printf(&quot; &quot;); head = newNode; newNode = head-&gt;next; beginNode-&gt;next = head; &#125; return;&#125; 共用体结构体的特性解决了一系列不同类型变量可以怎么放在一起组织的问题，而共用体则使多种不会同时出现的变量共用一块内存成为了可能，关键字union，共用体所占用的内存空间是被公用的，可通过两种或多种不同类型描述成员进行访问，且无论通过哪种方式进行访问，访问的是同一块内存空间。共用体类型变量的成员在内存中地址相同。 枚举enumeration枚举由一系列的整数成员，表示这一数据类型的变量可以取的所有可能值，但是这些值都不直接以字面量形式存在，每个值都被单独给予一个名字，同样也可以给多个枚举成员进行显性的编号。 声明一个该枚举类型的变量时，只能取定义过的枚举类型中的成员名作为值，枚举类型的成员不能有结构体和共用体变量。 二、简单算法牛顿迭代法多数方程不存在求根方式，因此用牛顿法寻找方程的近似跟，时间复杂度为log n。 步骤：1、确定迭代变量；2、建立迭代关系式；3、对迭代过程进行控制。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define EPSILON 1e-6double f(double x) &#123; return 2 * pow(x, 3) - 4 * pow(x, 2) + 3 * x - 6;&#125;double f_prime(double x) &#123; return 6 * pow(x, 2) - 8 * x + 3;&#125;double h(double x)&#123; return pow(x,3) - 4 * pow(x,2) + 3 * x - 6;&#125;double h_prime(double x)&#123; return 3 * pow(x,2) - 8 * x + 3;&#125;double newton(double (*fp)(double), double(*fp_prime)(double)) &#123; double x = 1.5; while (fabs(fp(x)) &gt; EPSILON)&#123; x = x - fp(x) / fp_prime(x); &#125; return x;&#125;int main() &#123; printf(&quot;%g\\n&quot;, newton(f, f_prime)); printf(&quot;%g\\n&quot;, newton(h, h_prime)); return 0;&#125; 二分法二分法同样是一个求方程近似跟的方法，在使用二分法近似求解时，先设定一个迭代区间，且区间两边自变量x对应的F(X)是异号的，之后计算两端中点位置x对应的f(x)，再更新迭代区间，并确保迭代区间两端x对应的函数值还是异号，重复过程直至中点x对应的f(x)小于某个值。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define EPSILON 1e-7double bisection(int p, int q, double (*func)(int, int, double));double f(int p, int q, double x);int main() &#123; int p; int q; scanf(&quot;%d%d&quot;, &amp;p, &amp;q); printf(&quot;%.4f\\n&quot;, bisection(p, q, f)); return 0;&#125;double bisection(int p, int q, double (*func)(int, int, double)) &#123; int forward, backward; if(func(p, q, 20) &gt; 0)&#123; forward = 20; backward = -20; &#125; else&#123; forward = -20; backward = 20; &#125; int x = 0; while(fabs(f(p, q, x)) &gt; EPSILON)&#123; if(f(p, q, x) &gt; 0)&#123; forward = x; &#125; else backward = x; x = (backward + forward)/2; &#125; &#125;double f(int p, int q, double x) &#123; return p * x + q;&#125; 质数筛法与之前的对每一个数依次判断是否为质数的方式不同，筛法的思想是“标注出所有非质数，输出所有没被标记的数字”，声明了一个mark数组，用于标记所有质数。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() &#123; printf(&quot;2\\n&quot;); int digit; int divisor; for (digit = 3; digit &lt;= 15; digit += 2) &#123; for (divisor = 3; divisor &lt; sqrt(digit); divisor += 2) &#123; if (digit % divisor == 0)&#123; break; &#125; &#125; if (divisor == digit)&#123; printf(&quot;%d\\n&quot;, digit); &#125; &#125; return 0;&#125; 质数筛法的逻辑：对于n以内的筛选来说，如果n为合数，c为n的最小因数，1&lt; C*C &lt; n；故只要找到了c就可以确定n是合数，并将n进行标记，通过这样的一个个筛选，将容易得到的合数均筛选出去。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int n = 15; int mark[16] = &#123; 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;; int c; int j; for (c = 2; c * c &lt;= n; c++) &#123; if(mark[c] != 1)&#123; for(j = 2; j &lt;= n / c;j++)&#123; mark[c * j] = 1; &#125; &#125; &#125; for (c = 2; c &lt;= n; c++)&#123; if(mark[c] != 1)&#123; printf(&quot;%d\\n&quot;, c); &#125; &#125; return 0;&#125; 折半查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int BinSearch(int arr[], int len, int key)&#123; int low = 0; int high = len - 1; int mid; while(low &lt;= high)&#123; mid = (low + high) / 2; if(key == arr[mid]) return mid + 1; else if(key &gt; arr[mid]) low = mid + 1; else high = mid - 1; &#125; return 0;&#125;int main() &#123; int n; int k; int numbers[1000001]; int m; int i; int j; // 反复读入数字和查找数字的数量 while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) != EOF) &#123; // 读入给定的数字 for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;numbers[i]); &#125; for (j = 0; j &lt; k; j++) &#123; // 读入待查找的数字， scanf(&quot;%d&quot;, &amp;m); printf(&quot;%d&quot;,BinSearch(numbers, n, m)); // 请在下面完成查找读入数字的功能 if(j &lt; k-1) printf(&quot; &quot;); &#125; &#125; return 0;&#125; 递归问题有时候递归会使时间复杂度过高，是因为使用了多次的重复计算，可以用数组来存储之前计算的值，从而避免简单的运算重复进行。经典的爬楼梯问题代码如下： 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int n, a, i; scanf(&quot;%d&quot;, &amp;n); int arr[n]; arr[0] = 0;arr[1] = 0;arr[2] = 1;arr[3] = 1; for(i = 4; i &lt;= n; i++)&#123; arr[i] = arr[i-2] + arr[i-3]; &#125; printf(&quot;%d&quot;, arr[n]); return 0;&#125; 冒泡排序基本思想：将数组中每个相邻元素进行两两比较，按照较小元素在前的原则决定是否进行交换，这样每一轮执行之后，最小元素就被换至了最后一位。完成第一轮后，我们从头进行第二轮的比较，直至倒数第二位（因为最后一位是已经被排序好的），依次进行直至所有元素被排列成预期的顺序为止。 123456//当有5个数待排序时，可写出如下的程序。for (j = 0; j &lt; 5; j++)&#123; for (i = 0; i &lt; 4 - j; i++)&#123; swap(a[i], a[i+1]); &#125; &#125; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main() &#123; int n = 10; int m; int numbers[10]; int i, j; // 读入给定的数字 for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;numbers[i]); &#125; for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n - 1 - i; j++)&#123; if(numbers[j] &lt; numbers[j+1])&#123; m = numbers[j]; numbers[j] = numbers[j+1]; numbers[j+1] = m; &#125; &#125; for(i = 0; i &lt; n; i++)&#123; printf(&quot;%d&quot;, numbers[i]); if(i != n-1)&#123; printf(&quot; &quot;); &#125; &#125; return 0;&#125; 选择排序核心思想：根据从小到大的排序需求，它每一次从到排序的数据元素中选择出最小的元素，移动至序列的起始位置，然后在剩余的待排序元素中进行排序。 用两层循环来实现：1、寻找最小的元素需要一层循环；2、逐个被选出也需要一层循环。 螺旋输出矩阵对任意的给定m行、n列的矩阵，按顺时针螺旋的顺序输出矩阵中所有的元素. 找规律，由外向内一层层进行for循环打印，最外层循环控制有多少层，每层分为（上方、右侧、下方、左侧）四个递增的循环，直至最后一层打印完；如果输出N为奇数，将会有N/2 + 1层 优化后的螺旋矩阵当然它的规律很简单，直接的方法就是先申请一个矩阵，然后按螺旋方向填入相应的元素，填充完毕后再打印出来。它的时间按复杂为O(n2)，已经是最优的（为什么？）。空间复杂度也为O(n2）。似乎已经很好了。 但是还不够好。 按照矩阵规律填充元素时，我们是随机访问矩阵元素的（如果可以按顺序访问，根本不用先存起来再打印）。随机访问内存，效率当然不高。所以即使时间复杂度已为最优，但那只是理论上的最优，在实践中表现并不一定就好。 假如能根据行列号直接计算出对应的矩阵元素就好了。当n给定后，这个矩阵就已经唯一确定了，那么每一个元素也是确定的。也就是说，每一个位置放什么元素仅仅取决于n。因此我们可以找到一个函数element(i, j)，将行号i和列号j映射成对应这个行列号的元素。当然这个函数肯定不是一个简单的函数，不是一眼就可以看出来的，但也并不是不可能。 现在我们就来考查一下这个矩阵有什么特点。注意观察一下螺旋矩阵的最外层，它的左上角的元素是最小的，然后沿顺时针方向递增，就如同一个环一样（比如n为4时，1, 2, …, 12就是最外面一层环）。再注意一下里面一层，也是一样，顺时针方向递增的一个环（比如n为4时，13, 14, 15, 16就是里面一层环）。以此类推，环里面还有一层环（n为4时有2层环，n为5时有3层环，最里面一层只有一个元素25），实际上是一个圆环套圆环结构。每一圆环最关键的元素就是左上角的那一个元素。只要知道了这个元素，再加上这个正方形环的边长就可以计算出剩下的元素。设左上角元素为a，边长为l（ell），也就是边上有几个元素，并假设左上角的行号和列号均为0，其它元素的行号和列号都以它作参考，计算方法如下所示： 1、若i == 0，element(i, j) = a + j; 2、否则若j == 0，element(i, j) = a + 4(l-4) - (i-1) - 1; 3、否则若i == l-1，element(i, j) = a + 4(l-4) - (l-2) - 1 - j; 4、否则element(i, j) = a + l - 1 + i; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std; int a[10][10]; void Fun(int n)&#123; int m=1; int i,j; for(i =0;i&lt;n/2;i++)&#123; for(j=0;j&lt;n-i;j++)&#123; if(a[i][j] ==0) a[i][j] = m++; &#125; for(j=i+1;j&lt;n-i;j++)&#123; if(a[j][n-1-i] ==0) a[j][n-1-i] = m++; &#125; for(j=n-i-1;j&gt;i;j--)&#123; if(a[n-i-1][j] ==0) a[n-i-1][j] = m++; &#125; for(j=n-i-1;j&gt;i;j--)&#123; if(a[j][i] ==0) a[j][i] = m++; &#125; &#125; if(n%2==1) a[n/2][n/2]=m;&#125; int main(void)&#123; int n,i; cout&lt;&lt;&quot;请输入螺旋矩阵维数： &quot;&lt;&lt; endl; cin&gt;&gt;n; cout&lt;&lt;&quot;显示螺旋矩阵数值： &quot;&lt;&lt; endl; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; a[i][j]=0; &#125; &#125; Fun(n); for(i=0;i&lt;n;i++)&#123; for( int j=0;j&lt;n;j++)&#123; cout&lt;&lt;a[i][j]&lt;&lt; &quot;\\t&quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 螺旋队列问题描述： 设1的坐标是（0，0），x方向向右为正，y方向向下为正，例如，7的坐标为（-1，-1），2的坐标为（1，0）。编程实现输入任意一点坐标（x，y），输出所对应的数字. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#define max(a,b) ((a)&lt;(b)?(b):(a))#define abs(a) ((a)&gt;0?(a):-(a)) using namespace std; int foo(int x,int y)&#123; int t = max(abs(x),abs(y)); int u = t+t; int v = u-1; v= v*v+u; if(x == -t) v+=u+t-y; else if(y==-t) v+=3*u+x-t; else if(y ==t) v+= t-x; else v+=y-t; return v;&#125; int _tmain(int argc, _TCHAR* argv[])&#123; int x ,y; int N; cout&lt;&lt;&quot;请输入螺旋队列数字： &quot;&lt;&lt;endl; cin&gt;&gt;N; cout&lt;&lt;&quot;显示螺旋队列数值： &quot;&lt;&lt;endl; for(y=-N;y&lt;=N;y++) &#123; for(x=-N;x&lt;=N;x++) cout&lt;&lt;&quot;\\t&quot;&lt;&lt;foo(x,y); cout&lt;&lt;endl; &#125; while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y)==2) //printf(&quot;%d\\n&quot;,foo(x,y)); cout&lt;&lt;&quot;\\t&quot;&lt;&lt;foo(x,y); return 0;&#125; 双螺旋矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int main() &#123; int matrix[100][100]; int m; int i; int j; int n; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (i = 0; i &lt; m; i++)&#123; for (j = 0; j &lt; n; j++)&#123; scanf(&quot;%d&quot;, &amp;matrix[i][j]); &#125; &#125; int rowBegin = 0; int rowEnd = m - 1; int colBegin = 0; int colEnd = n - 1; while (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd)&#123; //先向右走 for (int i = colBegin; i &lt;= colEnd; i++)&#123; printf(&quot;%d&quot;, matrix[rowBegin][i]); if (rowBegin == rowEnd &amp;&amp; i == colEnd); else printf(&quot; &quot;); &#125; rowBegin++; //向下走 for (int i = rowBegin; i &lt;= rowEnd; i++)&#123; printf(&quot;%d&quot;, matrix[i][colEnd]); if (colBegin == colEnd &amp;&amp; i == rowEnd); else printf(&quot; &quot;); &#125; colEnd--; //向左走前先判定条件 if (rowBegin &lt;= rowEnd)&#123; for (int i = colEnd; i &gt;= colBegin; i--)&#123; printf(&quot;%d&quot;, matrix[rowEnd][i]); if (rowBegin == rowEnd &amp;&amp; i == colBegin); else printf(&quot; &quot;); &#125; rowEnd--; &#125; if (colBegin &lt;= colEnd)&#123; for (int i = rowEnd; i &gt;= rowBegin; i--)&#123; printf(&quot;%d&quot;, matrix[i][colBegin]); if (colBegin == colEnd &amp;&amp; i == rowBegin); else printf(&quot; &quot;); &#125; colBegin++; &#125; &#125; return 0;&#125; 三、深入探究语言逻辑动态分配内存1、栈区：C语言程序在编译时会被分配到内存上一篇有限的连续区域，这部分内存会被用于存储局部变量的值，这部分内存区域被称为栈区； 2、堆区：这部分内存是我们通过程序手动地向系统申请的，栈区内存带下编译时就已经被限制，如果使用超过限制的内存就会出现“溢出”的情况，而堆区的内存可以被一直申请使用，直至操作系统的有效内存无法再被申请位置；堆区被申请后，在使用的过程中若不释放就可能会出现内存泄漏；需要使用free(arr)； 3、全局区（静态区）：程序中的全局变量和静态变量都被存储在这块内存区域中； 如果需要使用堆上内存，需要将malloc.h，stdlib.h引入到程序中来。 12int *p;p = (int *) malloc(sizeof(int)); 声明一个整数型的指针并向系统申请堆区上sizeof(int)的一块内存空间，并将指针p赋值为这片空间所在的起始地址； malloc函数的返回值类型为void* ，这是一种特殊的指针类型，任何一个其他指针变量都可以直接被赋值给void*类型的指针，但如果反过来将无类型指针付给一个其他类型的指针变量，则必须要在前面加上被赋值指针变量的类型，如：(int *)，进行强制类型转换","categories":[{"name":"C语言入门基础","slug":"C语言入门基础","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"循环神经网络","slug":"机器学习/循环神经网络","date":"2020-08-21T14:33:17.000Z","updated":"2020-08-22T08:54:54.213Z","comments":true,"path":"2020/08/21/机器学习/循环神经网络/","link":"","permalink":"http://yoursite.com/2020/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"1、语言模型与多层感知机和能有效处理空间信息的卷积神经网络不同，循环神经网络是为了更好地处理时序信息而设计的。引入状态变量来存储过去的信息，并用其与当前的输入共同决定当前的输出。 语言模型：可将自然语言文本看作一段离散的时间序列，假设一段长度为T的文本中的词依次为W1、W2….Wt，那么在离散的时间序列中，Wt可看作在时间步t的输出或标签。给定一个长度为T的词的序列，语言模型将计算该序列概率：P(W1,W2,….,Wt)。为计算该语言模型，需要先计算词的概率，以及一个词在给定前几个词的情况下的条件概率。 N元语法：计算和存储多个词的概率复杂度会呈指数级增加，故通过马尔可夫假设简化语言模型：一个词的出现只与前面N个词相关，即N阶马尔可夫链。 故基于n-1阶马尔可夫链，可将语言模型改写为：$$P(W1,W2,…,Wt) = ∏P（Wt|Wt-(n-1),…,Wt-1）$$以上也叫做n元语法，当n较小时，n元语法往往不准确，当n较大时，n元语法需要计算并存储大量的词频和多词相邻频率。 2、循环神经网络循环神经网络：并非刚性地记忆所有固定长度的序列，而是通过隐藏状态来存储之前时间步的信息。利用之前的多层感知机，通过添加隐藏状态将其变成循环神经网络。 不含隐藏状态的多层感知机：样本数为n、输出个数为d的小批量数据样本X。设隐藏层的激活函数为f，则其输出H为：$$H = f（X Wxh + bh）$$其中隐藏层权重参数W为Rn*d，隐藏层偏差参数b为R1xh，h为隐藏单元个数。上式两者根据广播机制来相加，设输出层的输出个数为q，则输出层的输出为：$$O = HWhq +bq$$若为分类问题，可用softmax(O)来计算输出类别的概率分布。 含隐藏状态的多层感知机与上一个相区别的是，保存上一时间步的隐藏变量Ht-1，并引入一个新的权重参数Whh为Rhxh，该参数用于描述在当前时间步如何使用上一时间步的隐藏变量。$$Ht = f(Xt Wxh + Ht-1Whh +bh)$$与多层感知机相比，添加了隐藏变量来捕捉截至当前时间步的序列的历史信息，就像神经网络当前时间步的状态或记忆一样，因此也称为隐藏状态，由于在当前时间步使用了上一时间步的隐藏状态，因此计算是循环的。通过对上一次时间步的利用，其模型参数的数量不随时间步的增加而增长。将输入与前一时间步隐藏状态连结后，输入至一个激活函数为f的全连接层，该全连接层的输出就是当前时间步的隐藏状态，且模型参数为Wxh与Whh的连结，偏差为bh。 ） 3、基于字符级神经网络的语言模型 演示如何1基于当前与过去字符来预测下一个字符，训练时对每个时间步的输出层输出使用softmax运算，然后使用交叉熵损失函数来计算其与标签的误差。 处理数据集建立字符索引：将每个字符映射成一个从0开始的连续整数，又称索引以方便后续处理。为得索引，我们将数据集中所有不同字符取出来，并逐一映射到索引来构造字典。 时序数据采样：每次随机读取小批量样本和标签，样本包含连续的字符。例：时间步数为5，样本序列为5个字符：‘’想，要，有，直，升”，则其标签序列为这些字符在训练集中的下一个字符：“要，有，直，升，机”。 随机采样：每个样本为原始序列上任意截取的一段序列，相邻的两个随机小批量不一定相邻，故每次随机采样前都需要重新初始化隐藏状态。 相邻采样：令相邻的两个随机小批量在原始序列上的位置也相毗邻，此时可以用一个小批量最终时间步的隐藏状态来初始化下一个小批量的隐藏状态：如此循环造成的影响：1、训练模型时，只需在每个迭代周期开始时初始化隐藏状态；2、当多个小批量通过传递隐藏状态串联起来时，梯度计算将依赖串联起的序列，迭代次数增加，梯度开销会越来越大。 one-hot向量使用one-hot向量将词表示成向量输入到神经网络：每个字符已经同一个从0到N-1的连续整数值索引一一对应。如果一个字符的索引是i，则其向量为全0的长为N的向量，仅将位置为i的元素设为1。 12def to_one_hot(X,size): return [nd.one_hot(x,size) for x in X.T] 构建模型先初始化模型参数，将隐藏单元个数num_hiddens作为超参数， 1234567891011121314151617num_inputs, num_hiddens, num_outputs = vocab_size, 256, vocab_sizedef get_params(): def _one(shape): return nd.random.normal(scale=o.o1, shape=shape, ctx=ctx) #先定义隐藏层参数 W_xh = _one((num_inputs, num_hiddens)) W_hh = _one((num_hiddens, num_hiddens)) b_h = nd.zeros(num_hiddens, ctx=ctx) #输出层参数 W_hq = _one((num_hiddens, num_outputs)) b_q = nd.zeros(num_outputs, ctx=ctx) #附上梯度 params = [W_xh, W_hh, b_h, W_hq, b_q] for param in params: param.attach_grad() return params 定义init_rnn_state函数来返回初始化的隐藏状态，返回由一个形状为（批量大小，隐藏单元个数）的值为0的NDArray组成的元组。 12def init_rnn_state(batch_size, num_hiddens, ctx): return (nd.zeros(shape=(batch_size, num_hiddens), ctx=ctx)) 定义rnn函数来在一个时间步中计算隐藏状态与输出，激活函数使用tanh 12345678910def rnn(inputs, state, params): #inputs和outputs皆为num_steps个形状为（batch_size, vocab_size)的矩阵 W_xh, W_hh, b_h, W_hq, b_q = params H, = state outputs = [] for X in inputs: H = nd.tanh(nd.dot(X, W_xh) + nd.dot(H, W_hh) + b_h) Y = nd.dot(H, W_hq) + b_q outputs.append(Y) return outputs, (H,) 定义预测函数基于前缀prefix（含有数个字符的字符串）来预测接下来的num_chars个字符: 123456789101112131415def predict_rnn(prefix, num_chars, rnn, params, init_rnn_state, num_hiddens, vocab_size, ctx, idx_to_char, char_to_idx): state = init_rnn_state(1, num_hiddens, ctx) output = [char_to_idx[prefix[0]]] for t in range(num_chars + len(prefix) - 1): #将上一时间步的输出作为当前时间步的输入 X = to_onehot(nd.array([output[-1]], ctx=ctx), vocab_size) #计算输出和更新隐藏状态 (Y, state) = rnn(X, state, params) #下一个时间步的输入是prefix里的字符或者当前的最佳预测字符 if t &lt; len(prefix) - 1: output.append(char_to_idx[prefix[t + 1]]) else: output.append(int(Y[0].argmax(axis=1).asscalar())) return &#x27;&#x27;.join([idx_to_char[i] for i in output]) 裁剪梯度利用裁剪梯度以应对梯度爆炸，假设将所有模型参数梯度的元素拼接成一个向量g，并设裁剪的阈值为s;裁剪后的梯度的L2范数不超过s$$裁剪后的梯度为 min(s/||g|| , 1)g$$ 12345678def grad_clipping(params, theta, ctx): norm = nd.array([0], ctx) for param in params: norm += (param.grad **2).sum() norm = norm.sqrt().asscalar() if norm &gt; theta: for param in params: param.grad[:] *= theta / norm 模型训练函数困惑度用于评价语言模型的好坏，是对交叉熵损失函数做指数运算后得到的值。 与之前章节的训练函数相比，该模型训练有几点不同：1、用困惑度评价模型；2、在迭代模型参数前裁剪梯度；3、对时序数据采用不同的采样方法将导致隐藏状态初始化的不同。 使用Gluon进行模型的简洁实现Gluon的rnn模块提供了循环神经网络的实现， 时间反向传播不裁剪梯度时，模型将无法正常训练。我们将循环神经网络按时间步展开，从而得到模型变量与参数之间的依赖关系，并根据链式法则应用反向传播计算并存储梯度。 每次迭代中，我们在依次计算完以上各个梯度后，会将它们存储起来，从而避免重复计算。同时，反向传播中的梯度计算可能会依赖变量的当前值，他们正是通过正向传播计算出来的。 4、门控循环单元裁剪梯度可以应对梯度爆炸，但是没办法解决梯度衰减的问题。因此，循环神经网络在实际中很难捕捉时间序列中时间步距离较大的依赖关系。GRU门控循环神经网络通过可以学习的门来控制信息的流动。 重置门和更新门两者输入均为当前时间步输入Xt与上一时间步隐藏状态Ht-1，输出由激活函数为sigmoid函数的全连接层计算得到 候选隐藏状态GRU将计算候选隐藏状态来辅助稍后的隐藏状态计算，先将当前时间步重置门的输出与上一时间步重置门隐藏状态做按元素乘法。重置门中元素值接近0，则意味重置对应隐藏状态元素为0，则丢弃上一时间步的隐藏状态；若近似1，则保留上一时间步隐藏状态。 之后与当前时间步的输出连结，再通过含t激活函数tanh的全连接层计算候选隐藏状态，其所有元素值域为[-1,1] 隐藏状态最后，时间步的隐藏状态Ht的计算使用了当前时间步的更新门Zt来对上一时间步的隐藏状态Ht-1和当前时间步的候选隐藏状态Ht*来做组合： 在Gluon中可直接调用rnn模块中的GRU类来实现GRU门控循环。 LSTM长短期记忆LSTM引入了三个门：输入门、遗忘门、输出门 在Gluon中可调用rnn模块中的LSTM类来实现长短期记忆。 5、深度循环神经网络深度循环神经网络：目前为止介绍的循环神经网络只有一个单项的隐藏层，深度学习中通常会用到含多个隐藏层的循环神经网络，在该网络中，隐藏状态的信息不断传递至当前层的下一时间步和当前时间步的下一层。 双向循环神经网络：之前的介绍的神经网络模型都是假设当前时间步由前面的较早时间步的序列来决定，因此信息均通过隐藏状态向后传递。故双向神经网络通过增加从后往前传递信息的隐藏层来更灵活地处理这类信息。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"卷积神经网络","slug":"机器学习/卷积神经网络","date":"2020-08-20T13:42:51.000Z","updated":"2020-08-21T14:22:34.739Z","comments":true,"path":"2020/08/20/机器学习/卷积神经网络/","link":"","permalink":"http://yoursite.com/2020/08/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"1、二维卷积层二维卷积层：有高和宽两个空间维度用于处理图像数据，通常使用更直观的互相关运算来代替卷积运算。将输出与卷积核做互相关，并加上一个标量偏差来得到输出。 在训练模型时，通常先对卷积核初始化，然后不断迭代卷积核与偏差。使用corr2d函数来实现： 1234567def corr2d(X,K): h,w = K.shape Y = nd.zeros((X.shape[0] - h + 1,X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i,j] = (X[ i:i+h , j: j+w]*K).sum() return Y 在构造函数中声明了weight和bias，并在forward中利用corr2d函数来实现卷积核。 1234567def __init__(self,kernel_size,**kwargs): super(Conv2D,self).__init__(**kwargs) self.weight = self.params.get(&#x27;weight&#x27;,shape=kernel_size) self.bias = self.params.get(&#x27;bias&#x27;,shape=(1,)) def forward(self,x): return corr2d(x, self.weight.data()) + self.bias.data() 一般通过数据学习得到核数组：首先构造一个卷积层，将其卷积核初始化为随机数组，并在每一次迭代中，使用平方误差来比较输出Y和卷积层的输出，并计算梯度来更新权重。 由于核数组都是学习出来的，所以卷积层使用互相关运算还是卷积运算都不影响模型预测时的输出。 特征图：输出可看作输入在空间维度上的表征。 影响X的前向计算的所有可能输入区域，叫做X的感受野。 2、填充与步幅填充：在输入高、宽的两侧填充元素；用于增加输出的高、宽。 步幅：卷积窗口从输入窗口左上方开始，依次滑动，每次滑行的行数和列数称为步幅，用于减少输出的高、宽。 3、多输入、多输出通道1、多输入时，构造输入通道数与输入数据的通道数相同的卷积核，从而能够互相关运算，对每个通道做互相关，然后通过add_n函数来进行累加 123def corr2d_multi_in(X,K): #首先沿X和K的第0维（通道维）遍历，然后用*将结果列表变为add_n函数的位置参数（positional argument）来相加 return nd.add_n(*[d2l.corr2d(x,k) for x , k in zip(X,K)]13 2、卷积核输入、输出通道数为Ci、Co，高和宽分别为Kh和Kw。若希望有多输出时，为每个通道分别创建核数组Ci x Kh x Kw，并将其在输出通道维上连结，卷积核形状为C0 X Ci x Kh x Kw，互相关时每个输出通道结果由卷积核在该通道核数组与整个输入数组计算得来。 123def corr2d_multi_in_out(X,K): #对K的第0维遍历，每次同输入X做互相关运算，所有结果用stack函数合并在一起 return nd.stack(*[corr2d_multi_in(X,K) for k in k]) 4、1 x 1 卷积层1 X 1 卷积主要发生在通道维上,输入与输出具有相同的高宽，输出中每个元素来自输入中在高、宽上相同位置的元素在不同通道之间的按权重累加。将通道维作为特征维，将高、宽上的元素当成数据样本，则其作用与全连接层等价。 1 X 1卷积层通常用来调整网络层之间的通道数，并控制模型复杂度。 5、池化层目的：为了缓解卷积层对位置的过度敏感性。 池化层：每次对输入数据的一个固定形状窗口中的元素计算输出，直接计算池化窗口内的元素最大值或平均值，也叫最大池化或者平均池化。p X q 池化层 同样池化层也能设置填充和步幅。 12pool2d = nn.MxaPool2D(1, kernel_size=(5,3),padding=(2,1),strides=(3,4))#使用高、宽分别为5，3的卷积核；在高宽上的填充数分别为2，1；高宽上步幅分别为3，4 在处理多通道输入数据时，池化层会对每个输入通道分别池化，而不是像卷积层那样将各通道输入按通道相加。因此，池化层的输出通道数与输入通道数相等。 6、卷积神经网络单隐藏层的多层感知机分类图像：将图像像素逐行展开，得到长为28*28=784的向量，并输入进全连接层中。局限性:1、同一列像素相隔远；2、对于大尺寸图像，全连接层可能导致模型过大。 卷积层如何解决：1、保留输入形状，使像素在高、宽两个方向的相关性均能被有效识别；2、通过滑动窗口将同一卷积核与不同位置的输入重复计算，从而避免参数尺寸过大。 LeNet模型分为卷积层块与全连接层块。 卷积层基本单位：卷积层+最大池化层。卷积层用于识别图像中空间模式，最大池化层用于降低卷积层对位置的敏感性。 卷积层输出形状为（批量大小，通道，高，宽）；当其输出传入全连接层块时，全连接层会将小批量中的每个样本变平。形状将改变为二维，第一维是小批量中的样本，第二维是每个样本变平后的向量表示，且向量长度为通道*高 *宽。 AlexNet模型1、包含8层变换，其中有5层卷积和2层全连接隐藏层，全连接输出个数为4096； 2、将激活函数由sigmoid改成了更简单的Relu，在不同参数初始化方法下使模型更容易训练，且在正区间的梯度恒为1; 3、利用丢弃法来控制全连接层的模型复杂度； 4、引入大量的图像增广，从而进一步扩充数据集来缓解过拟合； 5、利用了更多的卷积层和更大的参数空间来拟合大规模数据集ImageNet，是浅层网络与深度神经网络的分界线。 VGG模型VGG提出了可以通过重复使用简单的基础块来构建深度模型的思路；其组成规律是：连续使用数个相同的填充为1、窗口形状为3X3的卷积层后接上一个步幅为2、窗口形状为2X2的最大池化层。卷积层保持输入的高、宽不变，而池化层则对其减半。使用vgg_block函数来实现基础的VGG卷积层模块，可指定卷积层数量num_convs和输出通道数num_channels。 123456def vgg_block(num_convs, num_channels): blk = nn.Sequential() for _ in range(num_convs): blk.add(nn.Conv2D(num_channels, kernel_size=3,padding=1,activation=&#x27;relu&#x27;)) blk.add(nn.MaxPool2D(pool_size=2, strides=2)) return blk VGG由卷积模块后接全连接层模块构成，卷积层串联数个vgg_block，其超参数由变量conv_arch定义，指定了VGG块中卷积层个数与输出通道数。下面构造VGG，5个卷积块，前2块用单卷积层，后3块用双卷积层。第一块输出通道为64，之后每次输出通道数翻倍，直至512。总共8个卷积，3个全连接，因此称为VGG-11。 123456789101112conv_arch = ((1,64),(1,128),(2,256),(2,512),(2,512))def vgg(conv_arch): net = nn.Sequential() #卷积层部分 for (num_convs, num_channels) in conv_arch: net.add(vgg_block(num_convs, num_channels)) #全连接层部分 net.add(nn.Dense(4096, activation=&#x27;relu&#x27;), nn.Dropout(0.5), nn.Dense(4096, activation=&#x27;relu&#x27;), nn.Dropout(0.5), nn.Dense(10)) return net NIN模型上述模型共通处均是：先以卷积层构成的模块充分抽取空间特征，再以全连接层构成的模块来输出分类结果。 NIN则提出了另外一个思路：串联多个由卷积层和全连接层构成的小网络来构建深层网络。 卷积层通常输入、输出：四维数组（样本、通道、高、宽）；全连接层输入输出：二维数组（样本、特征）。故利用1 X 1卷积层来代替全连接层，从而使空间信息自然传递至后面层。 NIN块：由一个卷积层和两个充当全连接层的1 X 1卷积层串联而来，可自由设置第一个卷积层超参数。 NIN设计:除了使用NIN块以外，NIN去掉了AlexNet最后的3个全连接层，并使用输出通道数等于标签类别数的NIN块，然后使用全局平均池化层对每个通道中所有元素求平均，并直接进行分类。NIN这个设计的好处：显著减少模型参数尺寸，从而缓解过拟合。 GoogLeNet模型GoolLeNet中的基础卷积块为Inception块，有4条并行的线路，前3条线路使用窗口分别为1X1,3X3,5X5的卷积层来抽取不同的空间尺寸下的信息，且中间2条线路会对输入先做1X1卷积来减少输入通道数，以降低模型复杂度；第四条线路则用3X3池化层后接1X1卷积层来改变通道数；且均使用了合适的填充来使输入、输出高宽一致。 GooLeNet跟VGG一样，在主体卷积部分使用5个模块，每个模块之前使用步幅为2的3 X 3最大池化层来减小输出高宽。 模块一：使用一个64通道的7X7卷积层； 模块二：使用2个卷积层，64通道的1X1卷积层，然后是将通道增大3倍的3X3卷积层，对应Inception的线路二； 模块三：串联2个完整的Inception块； 模块四：串联5个Inception块； 模块五：2个Inception块，其后紧跟输出层，故同NIN一样使用全局平均池化层来将每个通道的高、宽变成1 7、批量归一化数据标准化处理：任一特征在数据集所有样本上的均值为0、标准差为1，可以使各个特征的分布相近。对于浅层模型，数据标准化预处理已经足够了，但对于深层网络，模型参数更新仍容易造成剧烈变化。 批量归一化层（batch normalization）：为应对深层模型的挑战，在训练时，利用小批量上的均值和标准差，不断调整神经网络中间输出，从而使整个神经网络在各层的中间输出数值更稳定。 全连接层的批量归一化对于全连接层：将批量归一化层放在全连接层的仿射交换与激活函数之间。 对卷积层做批量归一化对于卷积层：批量归一化发生在卷积计算之后、应用激活函数之前。 8、残差网络ResNet实践中，添加过多层后训练误差往往不降反升，即使利用批量归一化使训练深层模型更加容易，该问题仍存在。 残差块：当理想映射f(x)极接近恒等映射时，残差映射也易于捕捉恒等映射的细微波动。 ResNet沿用了VGG全3X3卷积层的设计，残差块中首先由2个相同输出通道数的3X3卷积层，每个卷积层之后接一个批量归一化层和RELU激活函数，然后将输入跳过这2个卷积运算后再加在最后的RELU激活函数前。这样设计要求2个卷积层的输入、输出形状一样，从而可以相加。 ResNet的前两层跟GoogLeNet一样，在输出通道为64、步幅为2的7X7卷积层后接步幅为2的3X3最大池化层。 1234net = nn.Sequential()net.add(nn.Conv2D(64,kernel_size=7,strides=2,padding=3), nn.BatchNoem(),nn.Activation(&#x27;relu&#x27;), nn.MaxPool2D(pool_size=3,strides=2,padding=1)) 不同在于其每个卷积层后增加的批量归一层,GoogLeNet在后面会接4个Inception组成的模块，而ResNet则使用4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块。我们用resnet_block函数来实现： 12345678def resnet_block(num_channels, num_residuals, first_block=False): blk = nn.Sequential() for i in range(num_residuals): if i == 0 and not first_block: blk.add(Residual(num_channels, use_1x1conv=True, strides=2)) else: blk.add(Residual(num_channels)) return blk 接着使用ResNet加入所有残差块，这里每个模块使用2个残差块 1234567net.add(resnet_block(64, 2, first_block=True), resnet_block(128,2), resnet_block(256,2), resnet_block(512,2))net.add(nn.GlobalAvgPool2D(), nn.Dense(10))#加入全局平均池化层后接上全连接层输出 9、稠密连接网络DenseNet DenseNet主要构建模块时稠密块和过渡层，前者定义了输入、输出是如何连结的，后者则用来控制通道数，使之不过大。 由于每个稠密块都会带来通道数的增加，使用过多则会带来过于复杂的模型，过度层用来控制模型复杂度。它通过1X1卷积层来减少通道数，并使用步幅为2的的平均池化层减半高、宽，从而进一步降低模型复杂度。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"MXNET机器学习初见","slug":"机器学习/机器学习初见","date":"2020-08-19T15:28:46.000Z","updated":"2020-08-29T12:20:13.045Z","comments":true,"path":"2020/08/19/机器学习/机器学习初见/","link":"","permalink":"http://yoursite.com/2020/08/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E8%A7%81/","excerpt":"","text":"1、基础知识NDArray、NumPy的广播机制：数组维度不同，后缘维度的轴长（从末尾算起的维度）相同；（4，3）+（3，）；（3，4，2）+（4，2） 2、数组维度相同，其中有个轴为1；（4，3）+（4，1）：在1轴上广播扩展。 NDArray,NumPy的相互变换： 123P = np.ones((2,3))D = nd.array(P)D.asnumpy() 自动求梯度（gradient）MXNET中使用autograd模块自动求梯度： 12345x = nd.arange(4).reshape((4,1))x.attach_grad() #申请内存with autograd.record(): y = 2 * nd.dot(x.T,x) #若y为标量，贼会默认对y元素求和后，求关于X的梯度y.backward() uniform:均匀分布采样；normal:正态分布采样；poisson:泊松分布采样。 2、线性回归损失函数：平方函数，平方损失；在模型训练中，希望找到一组模型参数为w1,w2,b使得训练样本平均损失最小。 解析解：误差最小化问题的解刚好可用数学公式表达出来；大多数为数值解，只能利用优化算法有限次迭代模型参数，从而尽可能降低损失函数的值。 全连接层：又名稠密层，输出层中的神经元与输入层中的各个输入完全连接； 矢量计算比标量逐个相加更加省时间，故往往利用矢量矩阵运算来实现深度学习； 优化算法：小批量随机梯度下降：批量大小batch size,学习率 lr 均为超参数，为人为设定并非模型学习出来的， 调参：通过反复试错来寻找合适的超参数， 123def sgd(params,lr,batch_size): #sgd函数实现小批量随机梯度下降算法 for param in params: param[:] = param - lr * param.grad / batch_size 在一个迭代周期epoch中，将完整遍历一遍data_iter函数，并对训练数据集中所有样本都使用一次。 Gluon简洁实现：1、提供data包来读取数据： 2、提供大量预定义层，nn模块：neural networks： 123from mxnet.gluon import nnnet = nn.Sequential() #Sequential实例是串联各层的容器，依次添加层，每一层一次计算并作为下一层输入net.add(nn.Dense(1)) #Dense全连接层，GLUON无须指定各层形状，模型会自动推断 3、利用init模块来实现模型参数初始化的各种方法： 12from mxnet.gluon import initnet.initialize(init.Normal(sigma=0.01)) #均值为0，标准差0.01的正态分布 4、定义损失函数：利用loss模块： 12from mxnet.gluon import loss as glossloss = gloss.L2Loss() #平方损失又是L2范数损失 5、定义优化算法：创建Trainer实例，以sgd作为优化算法，用来迭代net实例所有通过add函数嵌套的层包含的全部参数，可通过collect_params函数获取。 1trainer = gluon.Trainer(net.collect_params(),&#x27;sgd&#x27;,&#123;&#x27;learning_rate&#x27;:0.03&#125;) 6、训练模型：调用Trainer实例的step函数来迭代模型参数，按sgd的定义，在step中指明批量大小，从而对样本梯度求平均。 123456789num_epochs = 3for epoch in range(1,num_epochs + 1): for X,y in data_iter: with autograd.record(): l = loss(net(X),y) l.backward() trainer.step(batch_size) l = loss(net(features), labels) print(&#x27;epoach %d,loss: %f&#x27;%(epoch,l.mean().asnumpy())) 3、softmax回归模型输出为图像类别这种离散值时，使用softmax回归，其输出单元从一个变成了多个，且引入了softmax运算使输出更加适合离散值的预测和训练。 sofemax回归模型：将输出特征与权重做线性叠加，输出值个数等于标签里的类别数。例：有4种特征（4个像素的图片）和3种输出动物类别，则权重包含12个标量（带下标w)、偏差包含3个标量（带下标b）。每个On计算都依赖所有输入，故为全连接层。 softmax计算：直接用最高On作为预测输出，有2个问题。1、输出值范围不定，难以直观判断；2、误差难以衡量。softmax运算符可以解决，即归一化,但softmax运算不改变预测类别输出。$$y1 = exp(O1)/exp(O1)+exp(O2)+exp(O3)$$交叉熵函数：使用更适合衡量分布差异的测量函数，只关心对正确类别的预测概率，$$H(yi,yi) = -Σ(yilogyi)$$交叉熵损失函数，最小化其等价于最大化训练数据集所有标签类别的联合预测概率。$$l(o) =1/n * Σ(yilogy*i)$$图像分类数据集：Fashion-MNIST Gluon的DataLoader中可用多进程来加速数据读取；通过ToTensor实例将图像数据从unit8格式变换成32位浮点数格式，并除以255使得所有像素均在0至1之间。 Gluon简洁实现1、导入模块并获取函数 123456%matplotlib inlineimport d2zlzh as d2lfrom mxnet import gluon, initfrom mxnet.gluon import loss as gloss, nnbatch_size = 256 #批量大小设置train_iter,test_iter = d2l.load_data_fashion_mnist(batch_size) 2、定义和初始化模型 添加输出为10的全连接层，并用均值为0、标准差为0.01的正态分布随机初始化模型的权重参数。 123net = nn.Sequential()net.add(nn.Dense(10))net.initialize(init.Normal(sigma=0.01)) 3、同时定义softmax和交叉熵损失函数，使数值稳定性更好，使用Gluon提供的函数。 定义优化算法：使用学习率为0.1的小批量随机梯度下降算法。 12loss = gloss.SoftmaxCrossEntropyLoss()trainer = gluon.Trainer(net.collect_params()，&#x27;sgd&#x27;,&#123;&#x27;learining_rate&#x27;:0.1&#125;) 4、使用上一节定义的训练函数来训练模型： 12num_epochs = 5d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,batch_size,None,None,trainer) 4、多层感知机深度学习主要关注多层模型，以多层感知机NLP（multilayer perceptron）为例。在单层网络的基础上引入了隐藏层hidden layer，但多个仿射线性变换叠加仍然是线性仿射，需引入非线性函数，该函数被称为激活函数 RELU函数：RELU(x) = max(x,0) sigmoid函数：sigmoid(x) = 1/[1+exp(-x)] sigmoid函数的导数：sigmoid(x)(1-sigmoid(x)) tanh（双曲正切）函数：[1- exp(-2x)]/[1+exp(-2x)] tanh函数的导数：1 - [tanh(x)]^2 Gluon的简洁实现1、导入包与模块，并定义模型,，多加一个全连接作为隐藏层，单元数为256，用RELU作为激活函数。 123456import d2zlzh as d2lfrom mxnet import gluon, initfrom mxnet.gluon import loss as gloss, nnnet = nn.Sequential()net.add(nn.Dense(256,activation = &#x27;relu&#x27;),nn.Dense(10))net.initialize(init.Normal(sigma = 0.01)) 2、使用与softmax回归几乎相同的步骤来读取数据并训练模型,学习率为0.5 123456batch_size = 256 #批量大小设置train_iter,test_iter = d2l.load_data_fashion_mnist(batch_size)oss = gloss.SoftmaxCrossEntropyLoss()trainer = gluon.Trainer(net.collect_params()，&#x27;sgd&#x27;,&#123;&#x27;learining_rate&#x27;:0.5&#125;)num_epochs = 5 #迭代周期num_epochs指的是要循环学习几次d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,batch_size,None,None,trainer) 5、模型选择与拟合问题训练误差：模型在训练集上表现出来的误差； 泛化误差：任意一个测试数据样本上表现出的误差的期望； 使用验证数据集来进行模型选择：预留一部分在训练、测试数据集之外的数据来进行模型选择。K折交叉验证：将原始数据分成K个不重合的子数据集，做K次模型训练和验证，每一次用一个子数据集来验证模型，其他用于训练模型。最后对这K次结果分别求平均。 欠拟合：模型无法得到较低的训练误差。 过拟合：模型训练误差远小于其在测试集上误差；模型越复杂、训练集越小越容易过拟合。 6、权重衰减、丢弃法来处理过拟合权重衰减：等价于L2范数正则化，通过为模型损失函数添加惩罚项，使学到的模型参数值较小。 L2惩罚项指的是：模型权重参数的每一个元素的平方和与一个正的常数的乘积。 12def l2_penalty(w): return (w**2).sum() / 2 权重衰减Gluon简洁实现：构造Trainer实例时通过wd参数来指定权重衰减超参数，默认下会对权重、偏差同时衰减。 1234#对权重参数衰减，权重名称一般以weight结尾trainer_w = gluon.Trainer(net.collect_params(&#x27;.*weight&#x27;),&#x27;sgd&#x27;,&#123;&#x27;learning_rate&#x27;:lr,&#x27;wd&#x27;:wd&#125;)#不对偏差参数衰减，偏差名称一般以bias结尾trainer_b = gluon.Trainer(net.collect_params(&#x27;.*bias&#x27;),&#x27;sgd&#x27;,&#123;&#x27;learning_rate&#x27;:lr&#125;) 丢弃法：隐藏单元有一定的概率P被丢弃掉，丢弃概率是丢弃法的超参数。具体而言，随机变量$为0和1的概率分别为P和1-P。 定义dropout函数，以drop_prob的概率丢弃NDArray输入X中的元素。 丢弃法Gluon简洁实现：1234net = nn.Sequential()net.add(nn.Dense(256,activation = &#x27;relu&#x27;),nn.Dropout(drop_prob1), #在第一个全连接层后添加丢弃层 nn.Dense(256,activation = &#x27;relu&#x27;),nn.Dropout(drop_prob2),nn.Dense(10))net.initialize(init.Normal(sigma = 0.01)) 7、反向传播反向传播：指计算神经网络梯度的方法，依据链式法则，其梯度计算可能依据各变量的当前值，而这些变量的当前值是通过正向传播计算得到的。 正向传播的计算可能依赖于模型参数的当前值，而参数是在反向传播的梯度计算后通过优化算法迭代的。 模型参数初始化完成后，交替地进行正向传播和反向传播，并根据反向传播计算的梯度迭代模型参数。 梯度衰减、爆炸：由于层数过大时，输出呈幂次爆炸增长，故梯度爆炸或梯度消失。 8、深度学习计算原理细节1、基于Block类的模型构建Block类是nn模块里提供的一个模型构造类，继承Block类来构造多层感知机，重载init函数与forward函数，分别用于创建模型参数与定义前向计算。 123456789class MLP(nn.Block): #声明带有模型参数的层，声明2个全连接层 def __init__(self, **kwargs): #调用父类构造函数来进行必要初始化。 super(MLP,self).__init__(**kwargs) self.hidden = nn.Dense(256, activation=&#x27;relu&#x27;) #隐藏层 self.output = nn.Dense(10) #输出层 def forward(self,x): #定义模型的前向计算，即如何根据输入x计算返回所需的模型输出 return self.output(self.hidden(x)) 无需定义反向传播，系统将自动求梯度而生成反向传播所需的backward函数 实例化MLP类得到net，并传入输入数据X并做一次前向计算。 1234X = nd.random.uniform(shape=(2,20))net = MLP()net.initialize()net(X) 2、构建一个继承于Block类的继承类提供add函数来逐一添加串联的Block子类实例，而模型的前向计算就是将这些实例按顺序逐一计算。 1234567891011class MySequential(nn.Block): def__init__(self,**kwargs): super(MySequential,self).__init__(**kwargs) def add(self,block): #block为Block实例，当MySequential实例调用initialize函数时，系统会自动对其所有成员初始化 self._children[block.name] = block def forward(self,x): #OrderedDict保证按添加顺序遍历成员 for block in self._children.values(): x = block(x) return x 3、自定义初始化模型参数对于Sequential类构造的神经网络，可通过方括号[]来访问网络的任一层。同时Sequential实例中含模型参数的层，可通过Block类的params属性来访问该层包含的参数。 共享模型参数：在利用Block类中的forward函数里多次调用一个层来计算。或者，在构造层时指定特定的参数，若不同层使用同一份参数，则它们会在前向、反向时均共享相同的参数。 延后初始化：只有将形状是（，）的输入X传进网络做前向计算net(X)时，系统才能推断出该层权重参数形状为（，），此时才能真正地开始初始化参数。 避免延后初始化：1、要对已初始化的模型重新初始化时，由于参数形状不会变化，能够立即重新初始化；2、创建层的时候指定了它的输入个数，故系统不需要额外信息来推测参数形状。 4、自定义层5、读取与存储将内存中训练好的模型参数存储在硬盘上，供后续读取使用。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"C++初见","slug":"C++/C-四天入门","date":"2020-08-19T10:14:31.000Z","updated":"2020-12-07T13:29:26.905Z","comments":true,"path":"2020/08/19/C++/C-四天入门/","link":"","permalink":"http://yoursite.com/2020/08/19/C++/C-%E5%9B%9B%E5%A4%A9%E5%85%A5%E9%97%A8/","excerpt":"","text":"基础架构1、数组与函数的关系数组与函数并无本质区别，均是一种映射的形式。变量函数，指针数组。 数组：展开的函数，关键在于指针变化，查询时间快。 函数：压缩的数组，关键在于值传递，用INDEX来定位，所用空间小。 算法中的时空互换逻辑，时间复杂度与空间复杂度可以一定程度互换。 2、C++的编程逻辑面向过程：自顶向下的编程，性能高，但需要处理实现性能的每一个细节，难以复用、扩展。 面向对象：抽象化事物，建立模型。 函数式编程：强调将计算过程分解成可复用的函数，MAP方法。 1auto add = [](int a,int b) -&gt; int &#123;return a+b&#125;; 泛型编程：STL，编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同；泛型：在多种数据类型上皆可操作；将算法与数据结构完全分离。 123template &lt;typename T,typename U&gt;auto add(T a, U, b) -&gt; decltype(a+b)return a + b 3、程序执行的底层C源码—编译—》对象文件—链接—》可执行程序编译时：语法检查，一个源码生成一个目标文件 对象文件：存储各种各样定义 链接：需将所有对象文件定义捏合在一起 定义：函数具体的实现过程在这（有地址空间的为定义） 声明：说有这样一个东西（无地址空间为声明），作用于编译阶段用于语法检查，在调用函数时做语法检查，仅包含函数传入参数与返回值，并不关心函数内部 nm -C main.O 查看main.O该对象文件内容，main.O中printf由系统库实现，add由自定库实现 为何要分开定义与声明？ .h头文件—》放置声明 源文件—》放置定义把定义放在头文件往往会产生bug apt-get install vim.deb; ctrl +t 打开中断 凡是未定义（undefined）、冲突（duplicate:符号定义有2个）的错误—》一般是链接阶段的错误； 4、google测试框架要实现第三方模块功能的引入—》引入头文件 .h 其定义压缩在一起生成了库文件：静态链接库： .lib IDE：集成开发环境=文本(vim,gcc) + 编译(g++) + 调试(gdb,lldb) 添加谷歌测试框架使用make命令 一般未定义、重复定义的错误：一般均出现在链接阶段的错误。 而找不到头文件的错误，一般出现在预编译阶段，需要添加上头文件的编译路径。 1234567891011121314151617181920212223using namespace std;int add(int a, int b)&#123; return a + b&#125;TEST(test, add1)&#123; EXPECT_EQ(add(3,4),7); EXPECT_NQ(add(3,4),6); EXPECT_LT(add(3,4),8); EXPECT_LE(add(3,4),7); EXPECT_GT(add(3,4),6); EXPECT_GE(add(3,4),7);&#125;TEST(test, add2)&#123; EXPECT_EQ(add(3,4),7); EXPECT_NQ(add(3,4),7); EXPECT_LT(add(3,4),7); EXPECT_LE(add(3,4),7); EXPECT_GT(add(3,4),7); EXPECT_GE(add(3,4),7);&#125; 谷歌测试框架中Run_All：1、能够输出彩色字体；2、能够动态地获取知道有多少个测试用例 使用printf输出彩色信息使用printf输出信息之前，可以在printf添加配置参数，调整输出的字体颜色。以\\033[开头，以m结尾 12printf(&quot;\\033[1;33;41madd(3,4) = %d\\n&quot;,add(3,4));printf(&quot;hello world\\n&quot;); 两行的内容均会改变颜色，因为底层的信息决定了显示的颜色，而终端的程序就是**用来显示底层信息**的。我们上述的修改是修改了自己配置颜色信息的部分，因此Terminal看到了设置背景色、前景色之后时，之后打印均按照该信息进行，直到后续碰到谷歌框架配置颜色信息的代码时，才按照该框架的配置来显示颜色。 在该配置中0为重置所有属性，故可用下列代码确保仅一行输出改变颜色,\\033[0m 12printf(&quot;\\033[1;33;41madd(3,4) = %d\\n\\033[0m&quot;,add(3,4));printf(&quot;hello world\\n&quot;); 实现调试信息log日志打印功能在大型工程中同样的调试信息输出代码很常见，故难以判断调试信息在哪输出，因此需要能输出功能更丰富的输出调试信息。 预处理命令：宏定义#define :1、定义符号常量；2、定义傻瓜表达式；3、定义代码段 宏做的事情就是最基本的替换，发生在预处理阶段 *C源码–预处理–》待编译 + 代码 –编译–目标文件–链接–》可执行文件* g++ -E :单独执行预处理阶段 最终决定程序功能的并不是C源码，而是待编译源码。因此需要经过预处理阶段之后补充代码之后，才能够正确的实现功能。 #define:宏定义，只做基础的替换，而不做语法检查，且在编译器的视角中，宏定义一定要是一行代码。 123456789101112131415161718192021222324252627282930#define s(a,b) a*bs(int, p) = &amp;n;#这句代码是正确的，因为define并不检查语法，而是只做基础替换，替换后变为： int *p = &amp;n；s(3+6,4);#预处理后成为3+6*4；因此输出为27，而不是4*9=36#define P(a)&#123;\\ printf(&quot;%d\\n&quot;, d);\\&#125;#利用反斜杠让编译器认为上面的宏定义其实是一行代码#预定义的宏#_DATE_ 日期 #_TIME_ 时间 #_LINE_ 行号 #_FILE_ 文件名 #_func_ 函数名/非标准 #_FUNC_ 函数名/标准 #_PRETTY_FUNCTION_ 更详细的函数信息这些预定义的宏信息可用于检查版本，同样也可用于调试信息log日志打印 #define log(msg) &#123;\\ printf(&quot;[%s : %s : %d] %s\\n&quot;, __FILE__, __func__, __LINE__, msg) ;\\ &#125; 故通过log能够打印出调试信息从而进行分析如何根据上述地修改下，实现任意参数的宏，变参函数、变参宏#define log(frm, args...) &#123;\\ printf(&quot;[%s : %s : %d] %s\\n&quot;, __FILE__, __func__, __LINE__, msg) ;\\ printf(frm,##args);\\ printf(&quot;\\n&quot;);\\ &#125; 这样就实现了一个外在表现像是printf函数的宏，其输出信息会更多许多 #include：将后面文件内容原封不动地拷被至该位置，故待编译源码才能完整地反映功能。 #const：分配空间 预处理命令-条件编译如何确保在发布版中没有日志信息，即需要用简单的方式对日志信息创建开关，必须以#endif 结尾 1#ifdef DEBUG //是否定义了DEBUG宏 预处理的条件编译只有一个作用：做代码剪裁，使用该命令决定留下哪些代码 实现EXCEPT系列封装将谷歌测试框架的头文件换成自己的头文件，并编写自己头文件程序完成同样代码的编译； 1、实现TEST方法；2、实现未卜先知函数RUN_ALL_TEST；3、实现相等、不等、小于等判断方法，可判断不是由函数封装出来的，而是用宏进行封装； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#ifndef _MYTEST_H#define _MYTEST_H#define EXPECT_EQ(a,b)&#123;\\ if(!((a) == (b))&#123;\\ print(&quot;error\\n&quot;);&#125;&#125;#define EXPECT_NE(a,b)&#123;\\ if(!((a) != (b))&#123;\\ print(&quot;error\\n&quot;);&#125;&#125;#define EXPECT_EQ(a,b)&#123;\\ if(!((a) &lt; (b))&#123;\\ print(&quot;error\\n&quot;);&#125;&#125;其实此处代码可以进行复用，来使代码变得简洁，用宏能做的基础替换来进行复用。#define EXPECT(a, comp, b)&#123;\\ if(!((a) comp (b))&#123;\\ print(&quot;error\\n&quot;);&#125;&#125;#define EXPECT_EQ(a, b) EXPECT(a, == ,b)#define EXPECT_NE(a, b) EXPECT(a, != ,b)#define EXPECT_LT(a, b) EXPECT(a, &lt; ,b) #define EXPECT_LE(a, b) EXPECT(a, &lt;= ,b)#define EXPECT_GT(a, b) EXPECT(a, &gt; ,b)#define EXPECT_GE(a, b) EXPECT(a, &gt;= ,b)TEST应当是宏，在预编译后应当展开为函数的头部信息#define TEST(a, b) void a##_##b()如何实现RUN_ALL_TEST未卜先知函数如何确保将测试用例函数信息写入存储区：注册函数#define TEST(a, b)\\void a##_##b();\\__attribute__((constructor))\\void reg_##a##_##b()&#123;\\ add_test_func(a##_##b, #a&#x27;.&#x27;#b);\\ return ;\\&#125; struct&#123; void(*func)(); const char *func_name;&#125; func_arr[100];//并非动态存储，而是只能存储100个，可用链表作用来动态开辟空间int_func_cont = 0;void add_test_func(void(*func)(), const *name)&#123; func_arr[func_cnt].func =func; func_Arr[func_cnt].func_name = name; func_cnt += 1; return ;&#125;int RUN_ALLO_TEST&#123;\\ //遍历每一个测试用例函数（如何遍历，指向函数的指针,有一个存储区存储所有测试函数用例的地址，使用struct结构来设计存储区 //依次每一个测试用例函数 for (int i = 0; i &lt; func_cntr; i++)&#123; print(&quot;[ RUN ]%S\\n&quot;,func_arr[i]-&gt;name); func_arr[i].func(); &#125; return 0; &#125;#endif 5、简单算法二分查找：在一个有序数组中查找一个数据是否存在；二分函数：二分查找如何处理浮点型数据，连续函数；二分答案 本质：二分查找解决的问题：求解单调函数F(x)，函数与数组关系，其实和有序数组查找值一样的方法； 应用特点：给出X很好求，但F(X)并不好求。对于F(X) = 2X,这种正反均好求时，用不着二分查找；而对于在数组中，给出数组下标容易得出值，但给出值查找下标较为困难。 简单版快速排序：核心：partation方法，分区方法， 头部指针、尾部指针：1、先尾部指针，找一个小于基准值放前面；2、再头部指针：找一个大于基准值的放后面；3、头尾指针依次进行交替，直至指针指向同一空位置； 写一个用于测试快速排序的程序：TEST.H 123456789101112131415161718192021222324252627#define TEST(func, arr, l, r)&#123; int *temp = (int*)malloc(sizeof(int) * n);//传入数组 for (int i = 0; i &lt;n; i++) temp[i] = arr[i];//将arr中函数拷贝到temp中 func(temp, 0 ,n-1); if(check(temp, 0, n-1))&#123; print(&quot;[ OK ]%s\\n&quot;, #func); &#125;else&#123; print(&quot;[ FAILED ]%s\\n&quot;, #func); &#125;&#125;int check(int *arr, int l, int r)&#123; for(int i = l + 1; i &lt;= r; i++)&#123; if(arr[i] &lt; arr[i-1]) return 0; &#125; return 1;&#125;int *getRandData(int n)&#123; int *arr = (int*)malloc(sizeof(int) * n);//分配位置 for (int i = 0; i &lt; n; i++) arr[i] = rand() % n; return arr;&#125;int main&#123; &#125; version1partation：选择待排序区间的第一个元素作为基准值，将小于基准值的元素放在前面，大于基准值的元素放在后面，前后指针重合时，再分别对前后两部分进行快速排序的操作。 1234567891011121314void quick_sort_v1(int *arr_, int l , int r)&#123; if(l &gt;= r) return; //递归过程第一步必然要进行边界判断 int x = 1; y = r; z = arr[];// Z为基准值应该在的位置 while(x &lt; y)&#123; while (x &lt; y &amp;&amp; arr[y] &gt;= z) --y; if(x &lt; y) arr[x++] = arr[y];//放至头指针指向的空位 while (x &lt; y &amp;&amp; arr[x] &lt;= z) ++x; if(x &lt; y) arr[y--] = arr[x]; &#125; arr[x] = z;//最后将基准值放回其原来应该在的位置 quick_sort_v1(arr, l, x - 1); quick_sort_va(arr, x + 1, r); return ;&#125; 算法工程师平时考虑的是时间复杂度吗？ 大环境下的共识：你和你身边的同事都是算法工程师，因此nlogn时间复杂度算法都能想到，关键在于在实现时代码实现的细节； version2：单边递归法当本层的快速排序做完partation操作时，会分别对左右两边进行递归操作，因此相当于一个二叉树的结构； 单边递归法核心思想：作为一个主管，在要被优化掉之前，做下一层的活。当前的version1函数，partation做完之后等着左右两边，可以让左半边继续递归，但右半边交给当前层程序进行执行。 12345678910111213141516void quick_sort_v2(int *arr_, int l , int r)&#123; while(l &lt; r)&#123; int x = l ; y = r; z = arr[l];// Z为基准值应该在的位置 while(x &lt; y)&#123; while (x &lt; y &amp;&amp; arr[y] &gt;= z) --y; if(x &lt; y) arr[x++] = arr[y];//放至头指针指向的空位 while (x &lt; y &amp;&amp; arr[x] &lt;= z) ++x; if(x &lt; y) arr[y--] = arr[x]; &#125; arr[x] = z;//最后将基准值放回其原来应该在的位置 quick_sort_v2(arr, l, x - 1); l = x + 1; &#125;//使用while，做完partation操作后，左半边排序通过递归来进行， //右半边的排序通过修改本层的 return ;&#125; version3：无监督优化凡是判断坐标范围超界的判断：均为监督项，无监督优化：将监督项干掉； 先以插入排序来举例子： 插入排序思想：将无序序列分成两部分，前半部分为已排序区，后半部分为未排序区，每次从未排序区的头部选择一个元素，插入至已排序区中。 12345678910void insert_sort_v1(int *arr, int l, int r)&#123; for (int i = l + 1; i &lt;= r; i++)&#123; int j = i; while(j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1])&#123; swap(arr[j], arr[j-1]); --j; &#125; &#125; return ;&#125; 无监督思想：为何需要监督项，确保指针访问不越界，那么如何才能去掉这个监督项看上述while(j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1])，只有当前插入的元素，是当前已排序区间的最小值，才会越界；因此，先做一个预处理，将该全局范围内的最小值先放置第一位，则不可能发生这种越界操作，则不再需要插入排序中的监督项。 1234567891011121314151617181920void insert_sort_v2(int *arr, int l, int r)&#123; int ind = l; for (int i = l + 1; i &lt;= r; i++)&#123; if(arr[ind] &gt; arr[i]) ind = i; &#125; //插入排序是一个稳定的排序，而直接交换两个位置的值会破坏其稳定性 //找到全局最小值位置后，应当将其依次一个个换至最前面 while (ind &gt; l)&#123; swap(arr[ind], arr[ind -1]); --ind; &#125; for (int i = l + 1; i &lt;= r; i++)&#123; int j = i; while(j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1])&#123; swap(arr[j], arr[j-1]); --j; &#125; &#125; return ;&#125; 那么如何实现无监督的快速排序呢？快速排序中的partation过程，小于基准值放在前，大于的放在后；逻辑上讲，确定基准值后，其前后元素的数量就已经定了，由于基准值前后的位置数量是固定的，则有前一个值往后移、则必然后后面一个元素向前移。 故可以头尾指针同时向中间走，且两者同时进行交换，这样就能去掉快速排序过程中其所谓的监督项了。 12345678910111213141516void quick_sort_v3(int *arr_, int l , int r)&#123; while(l &lt; r)&#123; int x = 1, y = r, z = arr[l]; do&#123; while(arr[x] &lt; z) ++x; while(arr[y] &gt; z) --y; if(x &lt;= y)&#123; swap(arr[x], arr[y]); ++x, --y; &#125; &#125;while(x &lt;= y); quick_sort_v3(arr, l, y); l = x ; &#125; return ;&#125; 无监督的算法优化思维是一种非常重要的代码优化思维。 version4：基准值选择优化核心思维：快速排序时间复杂度，T(n) = n * h，其中h为递归二叉树的树高，而递归二叉树最多为n个节点，logn &lt; h &lt; n；则nlogn &lt; T(n) &lt; n**2 如何让快排的时间复杂度稳定在nlogn：控制二叉树树高，即每一次区分左右树时，尽量让左右两边平分，即基准值能平分数组。 方法一：三点取中法，在头指针l，尾指针r，中间元素指针m，三者指向的值之间，选取中位的那个数值作为基准值。 6、虚函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class A &#123; public : void say()&#123; cout &lt;&lt; &quot;this is Class A&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123; public: void say()&#123; cout &lt;&lt; &quot;this is class B&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; B b; A &amp;a = b; A *c = &amp;b; b.say(); //会调用B类say方法 a.say();//会调用A类say方法 c-&gt;say();//会调用A类say方法 return 0;&#125;//普通的成员函数方法是跟着类走的，根据其类类别，来判断调用哪种成员方法//而虚函数的方法，其调用的方法是跟着对象走的class C &#123; public : virtual void say()&#123; //前面加virtual,使其变成虚函数 cout &lt;&lt; &quot;this is Class A&quot; &lt;&lt; endl; &#125;&#125;;class D : public C &#123; public: void say()&#123; //父类的方法定义为虚函数，则其继承的子类的对应方法也会变成虚函数 cout &lt;&lt; &quot;this is class B&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; B b; A &amp;a = b;//a虽然是A类型的引用，但它绑定的是B类型的对象 A *c = &amp;b;//间接引用C时，C虽然指针类型，但它指向的是B类的对象，因此也是调用B类方法 b.say(); //会调用B类say方法 a.say();//会调用A类say方法 c-&gt;say();//会调用A类say方法 return 0;&#125; 为什么虚函数可以跟着对象走：任何一个对象都会占据一片存储空间，当对象中存在虚函数时，其底层存储区域中的第一个位置会记录一个地址；该地址指向一张虚函数的表vtable，表中每一项都存储的是虚函数。 因此虚函数是跟着对象走的，不管是何种类型的对象，都会指向了虚函数表，从而调用了当前对象所绑定的虚函数方法。 假设虚函数类型为T类型，则虚函数表首地址为T* 类型， 则存储T*类型数据区的数据为T**类型。因此可用C语言中指针来提取虚函数。但若用此方法来提取带参数的虚函数时，可能会导致参数混乱。 this指针原因是：在成员方法中的特殊变量：this指针,在成员方法中，看着是一个参数，实则会添加一个隐藏参数：this指针。因此两个参数：一个是this指针指向的地址，一个才是真正的传递参数。 this指针其实是一个变量，是成员方法的隐藏参数。 C++基础基本语法 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 数据类型 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t endl，这将在每一行后插入一个换行符，&lt;&lt; 运算符用于向屏幕传多个值 可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： 12typedef int feet;feet distance; 枚举类型枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。建枚举，需要使用关键字 enum。枚举类型的一般形式为： 1234567891011enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量;//如果枚举没有初始化, 即省掉&quot;=整型常数&quot;时, 则从第一个标识符开始。//例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 &quot;blue&quot;。enum color &#123; red, green, blue &#125; c;c = blue; 变量类型变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 bool 存储值 true 或 false。 char 通常是一个字符（八位）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 wchar_t 宽字符类型。 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表， 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std; // 变量声明extern int a, b;extern int c;extern float f; int main ()&#123; // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c &lt;&lt; endl ; f = 70.0/3.0; cout &lt;&lt; f &lt;&lt; endl ; return 0;&#125; 同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如 1234567891011121314// 函数声明int func(); int main()&#123; // 函数调用 int i = func();&#125; // 函数定义int func()&#123; return 0;&#125; C++ 中有两种类型的表达式： 左值（lvalue）：指向内存位置、的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句： 变量作用域作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。 字面量常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 123456789101112131415161718192021//为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：#include &lt;iostream&gt;using namespace std; /* * 这个程序演示了有符号整数和无符号整数之间的差别*/int main()&#123; short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j; return 0;&#125;//输出-15536 50000//上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) auto 存储类自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 register 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置） 寄存器只用于需要快速访问的变量，比如计数器。 static 存储类static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 1234567891011121314151617181920212223#include &lt;iostream&gt; // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main()&#123; while(count--) &#123; func(); &#125; return 0;&#125;// 函数定义void func( void )&#123; static int i = 5; // 局部静态变量 i++; std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ; std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;&#125; extern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.cpp 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示 mutable 存储类mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 thread_local 存储类使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。以下演示了可以被声明为 thread_local 的变量： 1234567891011thread_local int x; // 命名空间下的全局变量class X&#123; static thread_local std::string s; // 类的static成员变量&#125;;static thread_local std::string X::s; // X::s 是需要定义的 void foo()&#123; thread_local std::vector&lt;int&gt; v; // 本地变量&#125; 运算符 算术运算符 + - * / % ++ – 关系运算符 == != &gt; &lt; &gt;= &lt;= 逻辑运算符 &amp;&amp; || ! 位运算符 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A &gt;&gt; 2 将得到 15，即为 0000 1111 赋值运算符 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 杂项运算符 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -&gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 &amp; 指针运算符 &amp; 返回变量的地址。例如 &a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 循环循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 函数调用函数创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。 向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 按引用传递值，参数引用被传递给函数，就像传递其他值给函数一样。因此相应地，在下面的函数 swap() 中，您需要声明函数参数为引用类型，该函数用于交换参数所指向的两个整数变量的值。 12345678910// 函数定义void swap(int &amp;x, int &amp;y)&#123; int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return;&#125; 引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为 这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引 用。 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。 要以引用返回函数值，则函数定义时要按以下格式： 类型标识符 &amp;函数名（形参列表及类型说明）{函数体} 说明：（1）以引用返回函数值，定义函数时需要在函数名前加&amp; （2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。 数组多维数组： 12345678910//多维数组声明的一般形式如下：type name[size1][size2]...[sizeN];//例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：int threedim[5][10][4];//多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：int a[3][4] = &#123; &#123;0, 1, 2, 3&#125; , /* 初始化索引号为 0 的行 */ &#123;4, 5, 6, 7&#125; , /* 初始化索引号为 1 的行 */ &#123;8, 9, 10, 11&#125; /* 初始化索引号为 2 的行 */&#125;; 指向数组的指针：runoobAarray 是一个指向 &amp;runoobAarray[0] 的指针，即数组 runoobAarray 的第一个元素的地址。一旦您把第一个元素的地址存储在 p 中，您就可以使用 p、(p+1)、*(p+2) 等来访问数组元素。 C++ 中您可以通过指定不带索引的数组名来传递一个指向数组的指针。C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。 如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，您也可以传递一个多维数组作为形式参数。 123456void myFunction(int *param)//param[10]//param[]&#123;...&#125; C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。 如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344int * myFunction()&#123;...&#125;//另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。//现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下：#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt; using namespace std; // 要生成和返回随机数的函数int * getRandom( )&#123; static int r[10]; // 设置种子 srand( (unsigned)time( NULL ) ); for (int i = 0; i &lt; 10; ++i) &#123; r[i] = rand(); cout &lt;&lt; r[i] &lt;&lt; endl; &#125; return r;&#125; // 要调用上面定义函数的主函数int main ()&#123; // 一个指向整数的指针 int *p; p = getRandom(); for ( int i = 0; i &lt; 10; i++ ) &#123; cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;; cout &lt;&lt; *(p + i) &lt;&lt; endl; &#125; return 0;&#125; 引用引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如： 12int&amp; r = i;double&amp; s = d; 在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; using namespace std; int main ()&#123; // 声明简单的变量 int i; double d; // 声明引用变量 int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s &lt;&lt; endl; return 0;&#125;/*结果如下：Value of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7*/","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"基于HEXO的博客搭建","slug":"机器学习/首篇博文","date":"2020-08-15T11:11:49.000Z","updated":"2020-08-19T15:26:07.429Z","comments":true,"path":"2020/08/15/机器学习/首篇博文/","link":"","permalink":"http://yoursite.com/2020/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%A6%96%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"环境准备1、Git下载并利用SSH密钥关联上GitHub账号 2、JS.node下载 3、npm、cnpm、hexo下载 创建博客并利用GitHub Pages上传网络端1、创建空文件夹，并使用hexo init 生成博客 2、利用GitHub生成新的仓库作为博客资源，在原blog文件夹下安装GIT，并部署至该仓库","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"Hello World","slug":"机器学习/hello-world","date":"2020-08-15T11:06:14.903Z","updated":"2020-08-15T11:06:14.904Z","comments":true,"path":"2020/08/15/机器学习/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"C语言入门基础","slug":"C语言入门基础","permalink":"http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"},{"name":"算法框架","slug":"算法框架","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/"},{"name":"页面设计","slug":"页面设计","permalink":"http://yoursite.com/tags/%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/"},{"name":"探究语言逻辑","slug":"探究语言逻辑","permalink":"http://yoursite.com/tags/%E6%8E%A2%E7%A9%B6%E8%AF%AD%E8%A8%80%E9%80%BB%E8%BE%91/"}]}
{"meta":{"title":"Technical blog","subtitle":"IT小白的成长之旅","description":"请乐观，请珍惜","author":"Li Yudong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"archives","date":"2020-08-16T14:58:35.000Z","updated":"2020-08-16T14:58:35.251Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"广告位招租","date":"2020-08-16T15:01:00.000Z","updated":"2020-08-16T15:02:08.971Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-16T14:45:00.000Z","updated":"2020-08-16T14:48:55.034Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-16T14:49:27.000Z","updated":"2020-08-16T14:52:47.789Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"循环神经网络","slug":"循环神经网络","date":"2020-08-21T14:33:17.000Z","updated":"2020-08-21T15:53:36.248Z","comments":true,"path":"2020/08/21/循环神经网络/","link":"","permalink":"http://yoursite.com/2020/08/21/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"1、语言模型与多层感知机和能有效处理空间信息的卷积神经网络不同，循环神经网络是为了更好地处理时序信息而设计的。引入状态变量来存储过去的信息，并用其与当前的输入共同决定当前的输出。 语言模型：可将自然语言文本看作一段离散的时间序列，假设一段长度为T的文本中的词依次为W1、W2….Wt，那么在离散的时间序列中，Wt可看作在时间步t的输出或标签。给定一个长度为T的词的序列，语言模型将计算该序列概率：P(W1,W2,….,Wt)。为计算该语言模型，需要先计算词的概率，以及一个词在给定前几个词的情况下的条件概率。 N元语法：计算和存储多个词的概率复杂度会呈指数级增加，故通过马尔可夫假设简化语言模型：一个词的出现只与前面N个词相关，即N阶马尔可夫链。 故基于n-1阶马尔可夫链，可将语言模型改写为：$$P(W1,W2,…,Wt) = ∏P（Wt|Wt-(n-1),…,Wt-1）$$以上也叫做n元语法，当n较小时，n元","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"卷积神经网络","slug":"卷积神经网络","date":"2020-08-20T13:42:51.000Z","updated":"2020-08-21T14:22:34.739Z","comments":true,"path":"2020/08/20/卷积神经网络/","link":"","permalink":"http://yoursite.com/2020/08/20/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"1、二维卷积层二维卷积层：有高和宽两个空间维度用于处理图像数据，通常使用更直观的互相关运算来代替卷积运算。将输出与卷积核做互相关，并加上一个标量偏差来得到输出。 在训练模型时，通常先对卷积核初始化，然后不断迭代卷积核与偏差。使用corr2d函数来实现： 1234567def corr2d(X,K): h,w = K.shape Y = nd.zeros((X.shape[0] - h + 1,X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i,j] = (X[ i:i+h , j: j+w]*K).sum() return Y 在构造函数中声明了weight和bias，并在forward中利用corr2d函数来实现卷积核。 1234567def __init__(self,kernel_size,**kwargs): super(Conv2D,self).__init__(**kwargs) self.weight = self.params.get(&#x27;weight&#x27;,shape=kernel_size) self.bias = self.params.get(&#x27;bias&#x27;,shape=(1,)) def forward(self,x): return corr2d(x, self.weight.data()) + self.bias.data() 一般通过数据学习得到核数组：首先构造一个卷积层，将其卷积核初始化为随机数组，并在每一次迭代中，使用平方误差来比较输出Y和卷积层的输出，并计算梯度来更新权重。 由于核数组都是学习出来的，所以卷积层使用互相关运算还是卷积运算都不影响模型预测时的输出。 特征图：输出可看作输入在空间维度上的表征。 影响X的前向计算的所有可能输入区域，叫做X的感受野。 2、填充与步幅填充：在输入高、宽的两侧填充元素；用于增加输出的高、宽。 步幅：卷积窗口从输入窗口左上方开始，依次滑动，每次滑行的行数和列数称为步幅，用于减少输出的高、宽。 3、多输入、多输出通道1、多输入时，构造输入通道数与输入数据的通道数相同的卷积核，从而能够互相关运算，对每个通道做互相关，然后通过add_n函数来进行累加 123def corr2d_multi_in(X,K): #首先沿X和K的第0维（通道维）遍历，然后用*将结果列表变为add_n函数的位置参数（positional argument）来相加 return nd.add_n(*[d2l.corr2d(x,k) for x , k in zip(X,K)]13 2、卷积核输入、输出通道数为Ci、Co，高和宽分别为Kh和Kw。若希望有多输出时，为每个通道分别创建核数组Ci x Kh x Kw，并将其在输出通道维上连结，卷积核形状为C0 X Ci x Kh x Kw，互相关时每个输出通道结果由卷积核在该通道核数组与整个输入数组计算得来。 123def corr2d_multi_in_out(X,K): #对K的第0维遍历，每次同输入X做互相关运算，所有结果用stack函数合并在一起 return nd.stack(*[corr2d_multi_in(X,K) for k in k]) 4、1 x 1 卷积层1 X 1 卷积主要发生在通道维上,输入与输出具有相同的高宽，输出中每个元素来自输入中在高、宽上相同位置的元素在不同通道之间的按权重累加。将通道维作为特征维，将高、宽上的元素当成数据样本，则其作用与全连接层等价。 1 X 1卷积层通常用来调整网络层之间的通道数，并控制模型复杂度。 5、池化层目的：为了缓解卷积层对位置的过度敏感性。 池化层：每次对输入数据的一个固定形状窗口中的元素计算输出，直接计算池化窗口内的元素最大值或平均值，也叫最大池化或者平均池化。p X q 池化层 同样池化层也能设置填充和步幅。 12pool2d = nn.MxaPool2D(1, kernel_size=(5,3),padding=(2,1),strides=(3,4))#使用高、宽分别为5，3的卷积核；在高宽上的填充数分别为2，1；高宽上步幅分别为3，4 在处理多通道输入数据时，池化层会对每个输入通道分别池化，而不是像卷积层那样将各通道输入按通道相加。因此，池化层的输出通道数与输入通道数相等。 6、卷积神经网络单隐藏层的多层感知机分类图像：将图像像素逐行展开，得到长为28*28=784的向量，并输入进全连接层中。局限性:1、同一列像素相隔远；2、对于大尺寸图像，全连接层可能导致模型过大。 卷积层如何解决：1、保留输入形状，使像素在高、宽两个方向的相关性均能被有效识别；2、通过滑动窗口将同一卷积核与不同位置的输入重复计算，从而避免参数尺寸过大。 LeNet模型分为卷积层块与全连接层块。 卷积层基本单位：卷积层+最大池化层。卷积层用于识别图像中空间模式，最大池化层用于降低卷积层对位置的敏感性。 卷积层输出形状为（批量大小，通道，高，宽）；当其输出传入全连接层块时，全连接层会将小批量中的每个样本变平。形状将改变为二维，第一维是小批量中的样本，第二维是每个样本变平后的向量表示，且向量长度为通道*高 *宽。 AlexNet模型1、包含8层变换，其中有5层卷积和2层全连接隐藏层，全连接输出个数为4096； 2、将激活函数由sigmoid改成了更简单的Relu，在不同参数初始化方法下使模型更容易训练，且在正区间的梯度恒为1; 3、利用丢弃法来控制全连接层的模型复杂度； 4、引入大量的图像增广，从而进一步扩充数据集来缓解过拟合； 5、利用了更多的卷积层和更大的参数空间来拟合大规模数据集ImageNet，是浅层网络与深度神经网络的分界线。 VGG模型VGG提出了可以通过重复使用简单的基础块来构建深度模型的思路；其组成规律是：连续使用数个相同的填充为1、窗口形状为3X3的卷积层后接上一个步幅为2、窗口形状为2X2的最大池化层。卷积层保持输入的高、宽不变，而池化层则对其减半。使用vgg_block函数来实现基础的VGG卷积层模块，可指定卷积层数量num_convs和输出通道数num_channels。 123456def vgg_block(num_convs, num_channels): blk = nn.Sequential() for _ in range(num_convs): blk.add(nn.Conv2D(num_channels, kernel_size=3,padding=1,activation=&#x27;relu&#x27;)) blk.add(nn.MaxPool2D(pool_size=2, strides=2)) return blk VGG由卷积模块后接全连接层模块构成，卷积层串联数个vgg_block，其超参数由变量conv_arch定义，指定了VGG块中卷积层个数与输出通道数。下面构造VGG，5个卷积块，前2块用单卷积层，后3块用双卷积层。第一块输出通道为64，之后每次输出通道数翻倍，直至512。总共8个卷积，3个全连接，因此称为VGG-11。 123456789101112conv_arch = ((1,64),(1,128),(2,256),(2,512),(2,512))def vgg(conv_arch): net = nn.Sequential() #卷积层部分 for (num_convs, num_channels) in conv_arch: net.add(vgg_block(num_convs, num_channels)) #全连接层部分 net.add(nn.Dense(4096, activation=&#x27;relu&#x27;), nn.Dropout(0.5), nn.Dense(4096, activation=&#x27;relu&#x27;), nn.Dropout(0.5), nn.Dense(10)) return net NIN模型上述模型共通处均是：先以卷积层构成的模块充分抽取空间特征，再以全连接层构成的模块来输出分类结果。 NIN则提出了另外一个思路：串联多个由卷积层和全连接层构成的小网络来构建深层网络。 卷积层通常输入、输出：四维数组（样本、通道、高、宽）；全连接层输入输出：二维数组（样本、特征）。故利用1 X 1卷积层来代替全连接层，从而使空间信息自然传递至后面层。 NIN块：由一个卷积层和两个充当全连接层的1 X 1卷积层串联而来，可自由设置第一个卷积层超参数。 NIN设计:除了使用NIN块以外，NIN去掉了AlexNet最后的3个全连接层，并使用输出通道数等于标签类别数的NIN块，然后使用全局平均池化层对每个通道中所有元素求平均，并直接进行分类。NIN这个设计的好处：显著减少模型参数尺寸，从而缓解过拟合。 GoogLeNet模型GoolLeNet中的基础卷积块为Inception块，有4条并行的线路，前3条线路使用窗口分别为1X1,3X3,5X5的卷积层来抽取不同的空间尺寸下的信息，且中间2条线路会对输入先做1X1卷积来减少输入通道数，以降低模型复杂度；第四条线路则用3X3池化层后接1X1卷积层来改变通道数；且均使用了合适的填充来使输入、输出高宽一致。 GooLeNet跟VGG一样，在主体卷积部分使用5个模块，每个模块之前使用步幅为2的3 X 3最大池化层来减小输出高宽。 模块一：使用一个64通道的7X7卷积层； 模块二：使用2个卷积层，64通道的1X1卷积层，然后是将通道增大3倍的3X3卷积层，对应Inception的线路二； 模块三：串联2个完整的Inception块； 模块四：串联5个Inception块； 模块五：2个Inception块，其后紧跟输出层，故同NIN一样使用全局平均池化层来将每个通道的高、宽变成1 7、批量归一化数据标准化处理：任一特征在数据集所有样本上的均值为0、标准差为1，可以使各个特征的分布相近。对于浅层模型，数据标准化预处理已经足够了，但对于深层网络，模型参数更新仍容易造成剧烈变化。 批量归一化层（batch normalization）：为应对深层模型的挑战，在训练时，利用小批量上的均值和标准差，不断调整神经网络中间输出，从而使整个神经网络在各层的中间输出数值更稳定。 全连接层的批量归一化对于全连接层：将批量归一化层放在全连接层的仿射交换与激活函数之间。 对卷积层做批量归一化对于卷积层：批量归一化发生在卷积计算之后、应用激活函数之前。 8、残差网络ResNet实践中，添加过多层后训练误差往往不降反升，即使利用批量归一化使训练深层模型更加容易，该问题仍存在。 残差块：当理想映射f(x)极接近恒等映射时，残差映射也易于捕捉恒等映射的细微波动。 ResNet沿用了VGG全3X3卷积层的设计，残差块中首先由2个相同输出通道数的3X3卷积层，每个卷积层之后接一个批量归一化层和RELU激活函数，然后将输入跳过这2个卷积运算后再加在最后的RELU激活函数前。这样设计要求2个卷积层的输入、输出形状一样，从而可以相加。 ResNet的前两层跟GoogLeNet一样，在输出通道为64、步幅为2的7X7卷积层后接步幅为2的3X3最大池化层。 1234net = nn.Sequential()net.add(nn.Conv2D(64,kernel_size=7,strides=2,padding=3), nn.BatchNoem(),nn.Activation(&#x27;relu&#x27;), nn.MaxPool2D(pool_size=3,strides=2,padding=1)) 不同在于其每个卷积层后增加的批量归一层,GoogLeNet在后面会接4个Inception组成的模块，而ResNet则使用4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块。我们用resnet_block函数来实现： 12345678def resnet_block(num_channels, num_residuals, first_block=False): blk = nn.Sequential() for i in range(num_residuals): if i == 0 and not first_block: blk.add(Residual(num_channels, use_1x1conv=True, strides=2)) else: blk.add(Residual(num_channels)) return blk 接着使用ResNet加入所有残差块，这里每个模块使用2个残差块 1234567net.add(resnet_block(64, 2, first_block=True), resnet_block(128,2), resnet_block(256,2), resnet_block(512,2))net.add(nn.GlobalAvgPool2D(), nn.Dense(10))#加入全局平均池化层后接上全连接层输出 9、稠密连接网络DenseNet DenseNet主要构建模块时稠密块和过渡层，前者定义了输入、输出是如何连结的，后者则用来控制通道数，使之不过大。 由于每个稠密块都会带来通道数的增加，使用过多则会带来过于复杂的模型，过度层用来控制模型复杂度。它通过1X1卷积层来减少通道数，并使用步幅为2的的平均池化层减半高、宽，从而进一步降低模型复杂度。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"MXNET机器学习初见","slug":"机器学习初见","date":"2020-08-19T15:28:46.000Z","updated":"2020-08-20T13:39:05.603Z","comments":true,"path":"2020/08/19/机器学习初见/","link":"","permalink":"http://yoursite.com/2020/08/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E8%A7%81/","excerpt":"","text":"1、基础知识NDArray、NumPy的广播机制：数组维度不同，后缘维度的轴长（从末尾算起的维度）相同；（4，3）+（3，）；（3，4，2）+（4，2） 2、数组维度相同，其中有个轴为1；（4，3）+（4，1）：在1轴上广播扩展。 NDArray,NumPy的相互变换： 123P = np.ones((2,3))D = nd.array(P)D.asnumpy() 自动求梯度（gradient）MXNET中使用autograd模块自动求梯度： 12345x = nd.arange(4).reshape((4,1))x.attach_grad() #申请内存with autograd.record(): y = 2 * nd.dot(x.T,x) #若y为标量，贼会默认对y元素求和后，求关于X的梯度y.backward() uniform:均匀分布采样；normal:正态分布采样；poisson:泊松分布采样。 2、线性回归损失函数：平方函数，平方损失；在模型训练中，希望找到一组模型参数为w1,w2,b使得训练样本平均损失最小。 解析解：误差最小化问题的解刚好可用数学公式表达出来；大多数为数值解，只能利用优化算法有限次迭代模型参数，从而尽可能降低损失函数的值。 全连接层：又名稠密层，输出层中的神经元与输入层中的各个输入完全连接； 矢量计算比标量逐个相加更加省时间，故往往利用矢量矩阵运算来实现深度学习； 优化算法：小批量随机梯度下降：批量大小batch size,学习率 lr 均为超参数，为人为设定并非模型学习出来的， 调参：通过反复试错来寻找合适的超参数， 123def sgd(params,lr,batch_size): #sgd函数实现小批量随机梯度下降算法 for param in params: param[:] = param - lr * param.grad / batch_size 在一个迭代周期epoch中，将完整遍历一遍data_iter函数，并对训练数据集中所有样本都使用一次。 Gluon简洁实现：1、提供data包来读取数据： 2、提供大量预定义层，nn模块：neural networks： 123from mxnet.gluon import nnnet = nn.Sequential() #Sequential实例是串联各层的容器，依次添加层，每一层一次计算并作为下一层输入net.add(nn.Dense(1)) #Dense全连接层，GLUON无须指定各层形状，模型会自动推断 3、利用init模块来实现模型参数初始化的各种方法： 12from mxnet.gluon import initnet.initialize(init.Normal(sigma=0.01)) #均值为0，标准差0.01的正态分布 4、定义损失函数：利用loss模块： 12from mxnet.gluon import loss as glossloss = gloss.L2Loss() #平方损失又是L2范数损失 5、定义优化算法：创建Trainer实例，以sgd作为优化算法，用来迭代net实例所有通过add函数嵌套的层包含的全部参数，可通过collect_params函数获取。 1trainer = gluon.Trainer(net.collect_params(),&#x27;sgd&#x27;,&#123;&#x27;learning_rate&#x27;:0.03&#125;) 6、训练模型：调用Trainer实例的step函数来迭代模型参数，按sgd的定义，在step中指明批量大小，从而对样本梯度求平均。 123456789num_epochs = 3for epoch in range(1,num_epochs + 1): for X,y in data_iter: with autograd.record(): l = loss(net(X),y) l.backward() trainer.step(batch_size) l = loss(net(features), labels) print(&#x27;epoach %d,loss: %f&#x27;%(epoch,l.mean().asnumpy())) 3、softmax回归模型输出为图像类别这种离散值时，使用softmax回归，其输出单元从一个变成了多个，且引入了softmax运算使输出更加适合离散值的预测和训练。 sofemax回归模型：将输出特征与权重做线性叠加，输出值个数等于标签里的类别数。例：有4种特征（4个像素的图片）和3种输出动物类别，则权重包含12个标量（带下标w)、偏差包含3个标量（带下标b）。每个On计算都依赖所有输入，故为全连接层。 softmax计算：直接用最高On作为预测输出，有2个问题。1、输出值范围不定，难以直观判断；2、误差难以衡量。softmax运算符可以解决，即归一化,但softmax运算不改变预测类别输出。$$y1 = exp(O1)/exp(O1)+exp(O2)+exp(O3)$$交叉熵函数：使用更适合衡量分布差异的测量函数，只关心对正确类别的预测概率，$$H(yi,yi) = -Σ(yilogyi)$$交叉熵损失函数，最小化其等价于最大化训练数据集所有标签类别的联合预测概率。$$l(o) =1/n * Σ(yilogy*i)$$图像分类数据集：Fashion-MNIST Gluon的DataLoader中可用多进程来加速数据读取；通过ToTensor实例将图像数据从unit8格式变换成32位浮点数格式，并除以255使得所有像素均在0至1之间。 Gluon简洁实现1、导入模块并获取函数 123456%matplotlib inlineimport d2zlzh as d2lfrom mxnet import gluon, initfrom mxnet.gluon import loss as gloss, nnbatch_size = 256 #批量大小设置train_iter,test_iter = d2l.load_data_fashion_mnist(batch_size) 2、定义和初始化模型 添加输出为10的全连接层，并用均值为0、标准差为0.01的正态分布随机初始化模型的权重参数。 123net = nn.Sequential()net.add(nn.Dense(10))net.initialize(init.Normal(sigma=0.01)) 3、同时定义softmax和交叉熵损失函数，使数值稳定性更好，使用Gluon提供的函数。 定义优化算法：使用学习率为0.1的小批量随机梯度下降算法。 12loss = gloss.SoftmaxCrossEntropyLoss()trainer = gluon.Trainer(net.collect_params()，&#x27;sgd&#x27;,&#123;&#x27;learining_rate&#x27;:0.1&#125;) 4、使用上一节定义的训练函数来训练模型： 12num_epochs = 5d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,batch_size,None,None,trainer) 4、多层感知机深度学习主要关注多层模型，以多层感知机NLP（multilayer perceptron）为例。在单层网络的基础上引入了隐藏层hidden layer，但多个仿射线性变换叠加仍然是线性仿射，需引入非线性函数，该函数被称为激活函数 RELU函数：RELU(x) = max(x,0) sigmoid函数：sigmoid(x) = 1/[1+exp(-x)] sigmoid函数的导数：sigmoid(x)(1-sigmoid(x)) tanh（双曲正切）函数：[1- exp(-2x)]/[1+exp(-2x)] tanh函数的导数：1 - [tanh(x)]^2 Gluon的简洁实现1、导入包与模块，并定义模型,，多加一个全连接作为隐藏层，单元数为256，用RELU作为激活函数。 123456import d2zlzh as d2lfrom mxnet import gluon, initfrom mxnet.gluon import loss as gloss, nnnet = nn.Sequential()net.add(nn.Dense(256,activation = &#x27;relu&#x27;),nn.Dense(10))net.initialize(init.Normal(sigma = 0.01)) 2、使用与softmax回归几乎相同的步骤来读取数据并训练模型,学习率为0.5 123456batch_size = 256 #批量大小设置train_iter,test_iter = d2l.load_data_fashion_mnist(batch_size)oss = gloss.SoftmaxCrossEntropyLoss()trainer = gluon.Trainer(net.collect_params()，&#x27;sgd&#x27;,&#123;&#x27;learining_rate&#x27;:0.5&#125;)num_epochs = 5 #迭代周期num_epochs指的是要循环学习几次d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,batch_size,None,None,trainer) 5、模型选择与拟合问题训练误差：模型在训练集上表现出来的误差； 泛化误差：任意一个测试数据样本上表现出的误差的期望； 使用验证数据集来进行模型选择：预留一部分在训练、测试数据集之外的数据来进行模型选择。K折交叉验证：将原始数据分成K个不重合的子数据集，做K次模型训练和验证，每一次用一个子数据集来验证模型，其他用于训练模型。最后对这K次结果分别求平均。 欠拟合：模型无法得到较低的训练误差。 过拟合：模型训练误差远小于其在测试集上误差；模型越复杂、训练集越小越容易过拟合。 6、权重衰减、丢弃法来处理过拟合权重衰减：等价于L2范数正则化，通过为模型损失函数添加惩罚项，使学到的模型参数值较小。 L2惩罚项指的是：模型权重参数的每一个元素的平方和与一个正的常数的乘积。 12def l2_penalty(w): return (w**2).sum() / 2 权重衰减Gluon简洁实现：构造Trainer实例时通过wd参数来指定权重衰减超参数，默认下会对权重、偏差同时衰减。 1234#对权重参数衰减，权重名称一般以weight结尾trainer_w = gluon.Trainer(net.collect_params(&#x27;.*weight&#x27;),&#x27;sgd&#x27;,&#123;&#x27;learning_rate&#x27;:lr,&#x27;wd&#x27;:wd&#125;)#不对偏差参数衰减，偏差名称一般以bias结尾trainer_b = gluon.Trainer(net.collect_params(&#x27;.*bias&#x27;),&#x27;sgd&#x27;,&#123;&#x27;learning_rate&#x27;:lr&#125;) 丢弃法：隐藏单元有一定的概率P被丢弃掉，丢弃概率是丢弃法的超参数。具体而言，随机变量$为0和1的概率分别为P和1-P。 定义dropout函数，以drop_prob的概率丢弃NDArray输入X中的元素。 丢弃法Gluon简洁实现：1234net = nn.Sequential()net.add(nn.Dense(256,activation = &#x27;relu&#x27;),nn.Dropout(drop_prob1), #在第一个全连接层后添加丢弃层 nn.Dense(256,activation = &#x27;relu&#x27;),nn.Dropout(drop_prob2),nn.Dense(10))net.initialize(init.Normal(sigma = 0.01)) 7、反向传播反向传播：指计算神经网络梯度的方法，依据链式法则，其梯度计算可能依据各变量的当前值，而这些变量的当前值是通过正向传播计算得到的。 正向传播的计算可能依赖于模型参数的当前值，而参数是在反向传播的梯度计算后通过优化算法迭代的。 模型参数初始化完成后，交替地进行正向传播和反向传播，并根据反向传播计算的梯度迭代模型参数。 梯度衰减、爆炸：由于层数过大时，输出呈幂次爆炸增长，故梯度爆炸或梯度消失。 8、深度学习计算原理细节1、基于Block类的模型构建Block类是nn模块里提供的一个模型构造类，继承Block类来构造多层感知机，重载init函数与forward函数，分别用于创建模型参数与定义前向计算。 123456789class MLP(nn.Block): #声明带有模型参数的层，声明2个全连接层 def __init__(self, **kwargs): #调用父类构造函数来进行必要初始化。 super(MLP,self).__init__(**kwargs) self.hidden = nn.Dense(256, activation=&#x27;relu&#x27;) #隐藏层 self.output = nn.Dense(10) #输出层 def forward(self,x): #定义模型的前向计算，即如何根据输入x计算返回所需的模型输出 return self.output(self.hidden(x)) 无需定义反向传播，系统将自动求梯度而生成反向传播所需的backward函数 实例化MLP类得到net，并传入输入数据X并做一次前向计算。 1234X = nd.random.uniform(shape=(2,20))net = MLP()net.initialize()net(X) 2、构建一个继承于Block类的继承类提供add函数来逐一添加串联的Block子类实例，而模型的前向计算就是将这些实例按顺序逐一计算。 1234567891011class MySequential(nn.Block): def__init__(self,**kwargs): super(MySequential,self).__init__(**kwargs) def add(self,block): #block为Block实例，当MySequential实例调用initialize函数时，系统会自动对其所有成员初始化 self._children[block.name] = block def forward(self,x): #OrderedDict保证按添加顺序遍历成员 for block in self._children.values(): x = block(x) return x 3、自定义初始化模型参数对于Sequential类构造的神经网络，可通过方括号[]来访问网络的任一层。同时Sequential实例中含模型参数的层，可通过Block类的params属性来访问该层包含的参数。 共享模型参数：在利用Block类中的forward函数里多次调用一个层来计算。或者，在构造层时指定特定的参数，若不同层使用同一份参数，则它们会在前向、反向时均共享相同的参数。 延后初始化：只有将形状是（，）的输入X传进网络做前向计算net(X)时，系统才能推断出该层权重参数形状为（，），此时才能真正地开始初始化参数。 避免延后初始化：1、要对已初始化的模型重新初始化时，由于参数形状不会变化，能够立即重新初始化；2、创建层的时候指定了它的输入个数，故系统不需要额外信息来推测参数形状。 4、自定义层5、读取与存储将内存中训练好的模型参数存储在硬盘上，供后续读取使用。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"C++四天入门","slug":"C-四天入门","date":"2020-08-19T10:14:31.000Z","updated":"2020-08-19T15:22:03.380Z","comments":true,"path":"2020/08/19/C-四天入门/","link":"","permalink":"http://yoursite.com/2020/08/19/C-%E5%9B%9B%E5%A4%A9%E5%85%A5%E9%97%A8/","excerpt":"","text":"Day One 基础架构1、数组与函数的关系数组与函数并无本质区别，均是一种映射的形式。变量函数，指针数组。 数组：展开的函数，关键在于指针变化，查询时间快。 函数：压缩的数组，关键在于值传递，用INDEX来定位，所用空间小。 算法中的时空互换逻辑，时间复杂度与空间复杂度可以一定程度互换。 2、C++的编程逻辑面向过程：自顶向下的编程，性能高，但需要处理实现性能的每一个细节，难以复用、扩展。 面向对象：抽象化事物，建立模型。 函数式编程：强调将计算过程分解成可复用的函数，MAP方法。 1auto add = [](int a,int b) -&gt; int &#123;return a+b&#125;; 泛型编程：STL，编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同；泛型：在多种数据类型上皆可操作；将算法与数据结构完全分离。 123template &lt;typename T,typename U&gt;auto add(T a, U, b) -&gt; decltype(a+b)return a + b 3、程序执行的底层C源码—编译—》对象文件—链接—》可执行程序 编译时：语法检查，一个源码生成一个目标文件 对象文件：存储各种各样定义 链接：需将所有对象文件定义捏合在一起 定义：函数具体的实现过程在这（有地址空间的为定义） 声明：说有这样一个东西（无地址空间为声明），作用于编译阶段用于语法检查，在调用函数时做语法检查，仅包含函数传入参数与返回值，并不关心函数内部 nm -C main.O 查看main.O该对象文件内容，main.O中printf由系统库实现，add由自定库实现 为何要分开定义与声明？ .h头文件—》放置声明 源文件—》放置定义；把定义放在头文件往往会产生bug apt-get install vim.deb; ctrl +t 打开中断 凡是未定义（undefined）、冲突（duplicate:符号定义有2个）的错误—》一般是链接阶段的错误； 4、google测试框架要实现第三方模块功能的引入—》引入头文件 .h 其定义压缩在一起生成了库文件：静态链接库： .lib IDE：集成开发环境=文本(vim,gcc) + 编译(g++) + 调试(gdb,lldb)","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"基于HEXO的博客搭建","slug":"首篇博文","date":"2020-08-15T11:11:49.000Z","updated":"2020-08-19T15:26:07.429Z","comments":true,"path":"2020/08/15/首篇博文/","link":"","permalink":"http://yoursite.com/2020/08/15/%E9%A6%96%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"环境准备1、Git下载并利用SSH密钥关联上GitHub账号 2、JS.node下载 3、npm、cnpm、hexo下载 创建博客并利用GitHub Pages上传网络端1、创建空文件夹，并使用hexo init 生成博客 2、利用GitHub生成新的仓库作为博客资源，在原blog文件夹下安装GIT，并部署至该仓库","categories":[{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-15T11:06:14.903Z","updated":"2020-08-15T11:06:14.904Z","comments":true,"path":"2020/08/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"},{"name":"前端页面","slug":"前端页面","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"初学者","slug":"初学者","permalink":"http://yoursite.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"}]}
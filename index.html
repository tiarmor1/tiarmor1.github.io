<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E6%AD%A6%E6%B1%8932x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E6%AD%A6%E6%B1%8916x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib1/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="请乐观，请珍惜">
<meta property="og:type" content="website">
<meta property="og:title" content="Technical blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Technical blog">
<meta property="og:description" content="请乐观，请珍惜">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Li Yudong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Technical blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Technical blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">IT小白的成长之旅</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">34</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tiarmor1" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/12/%E5%89%8D%E7%AB%AF/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/%E5%89%8D%E7%AB%AF/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">首屏优化实践</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              
    
              <time title="创建时间：2021-03-12 20:02:33 / 修改时间：22:51:23" itemprop="dateCreated datePublished" datetime="2021-03-12T20:02:33+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的项目在部署之后首屏加载过慢了，因此最近有想进行简单的优化一下，顺便就想以一个初学者的角度将项目优化的思路有条理的梳理一下，因为水平原因，很多方法可能只能写下思路，没办法应用在自己的项目上，而且可能很多的优化方案已经略有过时。主要还是想做一下有关优化知识的梳理吧，毕竟优化是一个永恒不变的话题。项目是基于vue框架开发的，但优化方法的思路是不拘泥于框架的。</p>
<h1 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h1><p>代码层面的优化这一部分其实比较杂乱，浅显的意思是要怎么去编写高性能点的代码？emm主要还是讲一下从一个新手的角度，避免出现一些影响性能的操作吧。</p>
<h2 id="路由、模块懒加载"><a href="#路由、模块懒加载" class="headerlink" title="路由、模块懒加载"></a>路由、模块懒加载</h2><p>很常用的懒加载代码， 不用一次加载所有的路由或者模块，到需要引用时再进行加载，用函数来代替对象进行引入模块与路由，属于用vue框架时的基本操作吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由懒加载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">      <span class="comment">// 方法一：vue异步组件实现</span></span><br><span class="line">      <span class="comment">// component: resolve =&gt; (require([&#x27;@/components/HelloWorld&#x27;], resolve))</span></span><br><span class="line">      <span class="comment">// 方法二：import方法(常用)</span></span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/HelloWorld&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//模块懒加载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">      <span class="comment">// 方法一</span></span><br><span class="line">    <span class="string">&#x27;HelloWorld&#x27;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./HelloWorld&#x27;</span>),</span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    <span class="comment">// HelloWorld&#x27;: resolve =&gt; ([&#x27;./HelloWorld&#x27;], resolve)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>图片懒加载其实通常更多地应用于图片较多的网站，我自己的项目上由于图片比较少，就没有用到复杂的长屏懒加载。只是在图片或模块的ajax请求没有返回时，使用一个loading的特效来代替图片、组件进行填充，简单地实现了基础的懒加载？思路很简单：大概就是预设一个div的z-index，让其覆盖图片、组件的上面，默认为show。同时在ajax请求的异步回调上修改其CSS，变为hidden。elementUI等开源组件库上应该有类似的loading组件。</p>
<p>对于含有多图片的长页面，在你没有滚动到图片所在位置的页面中时，是用空的div来填充代替图片位置的。一旦我们通过滚动使得这个 div 出现在了可见范围内，那么 div 元素的内容就会发生变化，呈现其中的内容，这就是图片的懒加载。</p>
<p>下面我们简单实现下懒加载：其实该功能的关键在于获取两个值：1、当前可视区域的高度，通常用window.innerHeight 属性获取。</p>
<p>2、元素距离可视区域顶部的高度，我们这里选用 getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。该方法的返回值是一个DOMRect。DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。其中top 属性代表了元素距离可视区域顶部的高度，正好用来实现功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lazy-Load<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.img</span> &#123;</span></span><br><span class="line">      width: 200px;</span><br><span class="line"><span class="css">      <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">      background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.pic</span> &#123;</span></span><br><span class="line">      // 必要的img样式</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      // 注意我们并没有为它引入真实的src</span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/3.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/4.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/5.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/6.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/7.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/8.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/9.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/10.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取所有的图片标签</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取可视区域的高度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span></span><br><span class="line"><span class="javascript">    <span class="comment">// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> num = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">let</span> i=num; i&lt;imgs.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 用可视区域高度减去元素顶部距离可视区域顶部的高度</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span></span></span><br><span class="line">            if(distance &gt;= 0 )&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 给元素写入真实的src，展示图片</span></span></span><br><span class="line"><span class="javascript">                imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出</span></span></span><br><span class="line">                num = i + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 监听Scroll事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazyload, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ajax请求"><a href="#ajax请求" class="headerlink" title="ajax请求"></a>ajax请求</h2><p>现在项目中通常都不会去手写原生的ajax，毕竟因为异步的回调地狱嘛。我自己的项目用的是axios，定义如下：<code>axios</code> 是一个轻量的 <code>HTTP客户端</code>，它基于 <code>XMLHttpRequest</code> 服务来执行 HTTP 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端。但往往我们需要封装一下axios，毕竟如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作都重写一遍就太麻烦了。这里贴一下我自己很简单的axios封装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">var</span> service = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// http://qinghai.free.idcfengye.com/</span></span><br><span class="line">    timeout:<span class="number">400000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">service.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">service.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = service;</span><br><span class="line"><span class="comment">//挂载在vue的原型上，这样你后续在vue文件中使用this.$http便可以获取到service。</span></span><br></pre></td></tr></table></figure>

<p>当然，这里ajax的优化其实并不是指简单的axios封装，毕竟这个属于常用操作。这个优化问题也是出自项目的主页，由于某些问题，主页中同一时间进行地ajax请求过多，一次跑过多的异步任务会导致页面的卡顿。开始时，我用的便是上述封装后的axios请求，为解决卡顿问题，开始时我希望能够使用fetch()来代替ajax请求，希望能达到目的；fetch()定义如下：</p>
<p>Fetch API是新的ajax解决方案 Fetch会返回Promise, fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。fetch(url, options).then()。</p>
<p>其实我感觉优点就三个：1、使用promise，这样也支持了async，编写异步时更加方便；2、可自定义是否携带cookie；3、fetch在ServiceWorker中使用。但实际项目中，ajax往往都被封装好了，例如上面的axios，这样前两项其实并没有所谓。但关键就在于第三项了。service work是基于web worker而来。</p>
<p>众所周知，javaScript 是单线程的，随着web业务的复杂化，开发者逐渐在js中做了许多耗费资源的运算过程，这使得单线程的弊端更加凹显。web worker正是基于此被创造出来，它是脱离在主线程之外的，我们可以将复杂耗费时间的事情交给web worker来做。但是web worker作为一个独立的线程，他的功能应当不仅于此。service work便是在web worker的基础上增加了离线缓存的能力。</p>
<p>特点：1、必须是https环境，本地调试localhost或者127.0.0.1环境也是可以的，2、依赖于cache api进行实现的3、依赖于h5的fetch Api；4、依赖于promise进行实现。但这里我自己并没有用这么复杂的优化方案，就不赘述了。</p>
<p>我自己运用基本的处理有：1、使用了axios对多并发请求的处理方案，当页面某个数据来源于多个互不关联的请求时，需要统一处理然后呈现。即使用axios.all(iterable)，参数：请求数组；axios.spread(callback)，参数： 对应请求返回值。API的应用实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  getAllTask() &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">&#x27;/data.json&#x27;</span>, &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        id: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getAllCity() &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">&#x27;/city.json&#x27;</span>, &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        id: <span class="number">11</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  axios.all([<span class="built_in">this</span>.getAllTask(), <span class="built_in">this</span>.getAllCity()])</span><br><span class="line">    .then(axios.spread(<span class="function"><span class="keyword">function</span>(<span class="params">allTask, allCity</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求1结果&#x27;</span>, allTask)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求2结果&#x27;</span>, allCity)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>2、尽量复用ajax请求，当不同模块间可以公用同一接口的同一信息时，不要在两个模块中分别请求两次，而是尽量利用组件间通信来实现信息的共享；</p>
<p>2、设置HTTP缓存。HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为强缓存和协商缓存。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。</p>
<p>当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。expires写的是一个绝对的时间戳，例如：xxx年x月x日。而在 Cache-Control 中，我们通过 <code>max-age</code>字段 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。max-age 是一个相对时间，这就意味着它有能力规避掉 expires 可能会带来的时差问题。同样，因此cache-control的优先级比expires更高。Cache-Control 中还有更高优先级的s-maxage：用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。（public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。）</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存依赖于服务端与浏览器之间的通信。在协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。在该服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304）。</p>
<p>实现：<strong>Last-Modified 到 Etag</strong>。Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回。随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值。服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。</p>
<p>但是可能会有一个bug：我们编辑文件，但没有修改，服务器可能会以为我们修改了；修改文件的时间过快，服务器可能会感知不到。即：服务器并没有正确感知文件的变化。这样就引出了Etag，Etag 是由服务器为每个资源生成的唯一的<strong>标识字符串</strong>，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。同样，优先级方面，Etag高于Last-Modefied。</p>
<p>HTTP缓存决策流程：当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p>
<h2 id="组件库按需引入"><a href="#组件库按需引入" class="headerlink" title="组件库按需引入"></a>组件库按需引入</h2><p>这一点其实好理解，例如当你使用elementUI或者echarts这些组件库时，通常并没有用到其提供的全部组件，因此在import的时候，不需要全部引入整体，只需要引入你所用到的部分即可。</p>
<h2 id="适用于V8引擎的JS代码"><a href="#适用于V8引擎的JS代码" class="headerlink" title="适用于V8引擎的JS代码"></a>适用于V8引擎的JS代码</h2><p>毫无疑问，就又是一个大坑了，关于对这个的理解我也是由他人的博客所看来的，不保证结论的正确性，只是记录下自己的了解。首先我们需要了解以下V8引擎底层的两个特征。</p>
<h3 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h3><p>在V8引擎中采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。每当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。乍一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息时，隐藏类可以被重用。即下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。</p>
<p>这样的话，相当于一个构造函数中的所有属性都由一个隐藏类的链将他串联在了一起，由该构造函数新建的对象就可以直接共享该隐藏类链。主要的优点有：1、属性访问时不再需要从动态字典中进行查找了；2、为V8使用经典的基于类的优化和内联缓存技术提供了条件。</p>
<p>内联缓存技术：在第一次执行到访问某个对象的属性的代码时，V8会找出该对象的隐藏类；同时，V8会假设在相同的代码片段中其他所有的对象的属性访问都通过这一隐藏类来实现。只有在预测失败时，V8才会修改内联代码并移除刚才加入的内联优化。当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，即：你基于一个构造函数，构建多个实例时，用隐藏类的方法可以加快属性访问速度。</p>
<p>由隐藏得来的V8代码编写教训：1、在构造函数里初始化所有对象的成员(所以这些实例之后不会改变其隐藏类)；2、总是以相同的次序初始化对象成员；//可以更好利用隐藏类 3、永远不要delete对象的某个属性；4、方法：重复执行相同方法的代码将比仅执行一次的多个不同方法（由于内联缓存）的代码运行得更快。5、数组：避免稀疏数组</p>
<h3 id="两次编译"><a href="#两次编译" class="headerlink" title="两次编译"></a>两次编译</h3><p>V8有两个不同的运行时编译器：1、“完全”编译器（unoptimized）。一开始，所有的V8代码都运行在unoptimized状态。它的好处是编译速度非常快，它使代码初次执行速度非常快。2、“优化”编译器（optimized）。当V8发现某段代码执行非常热时，它会根据通常的执行路径进行代码优化，生成optimized代码。优化代码的执行速度非常快。</p>
<p>编译器有可能从“优化”状态退回到“完全”状态， 这就是deoptimized。这是很不幸的过程，优化后的代码没法正确执行，不得不退回到unoptimized版本。当然最不幸的是代码不停地被optimized，然后又被deoptimized， 这会带来很大的性能损耗，例如：for…in遍历对象的属性和try…catch中的代码会让编译器无法到达optimized状态。</p>
<p>使用教训：1、把for…in 内部的代码单独提出来作为函数，这样V8引擎就能对其进行优化；2、谨慎使用try..catch</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包会使程序逻辑变复杂，有时会看不清楚是否对象内存被释放，因此要注意释放闭包中的大对象， 否则会引起内存泄露。谨慎使用闭包，有时候不当的闭包使用会造成大量的内存占用。</p>
<h1 id="存储层面的优化"><a href="#存储层面的优化" class="headerlink" title="存储层面的优化"></a>存储层面的优化</h1><p>其实关于缓存方面上面的ajax请求里已经写了好多了，嗯，感觉布局有点问题，不过并不打算改了。这里就主要说说webpack打包方面的修改吧，毕竟算存储内容的优化？不过我是用vuecli构建的项目，其实该有的优化都已经默认配好了？就像tree-shaking？</p>
<p>在你使用vue-cli构建项目时，webpack的配置会被隐藏在vuecli的框架下面，不过想要自己进行特别的webpack配置也比较容易，根据vuecli官方网站的说明：调整 webpack 配置最简单的方式就是在 <code>vue.config.js</code> 中的 <code>configureWebpack</code> 选项提供一个对象：该对象将会被 <a target="_blank" rel="noopener" href="https://github.com/survivejs/webpack-merge">webpack-merge</a> 合并入最终的 webpack 配置。如果你需要基于环境有条件地配置行为，或者想要直接修改配置，那就换成一个函数 (该函数会在环境变量被设置之后懒执行)。该方法的第一个参数会收到已经解析好的配置。在函数内，你可以直接修改配置，或者返回一个将会被合并的对象。具体的配置方案因为我自己也不太懂，就不赘述了。</p>
<h2 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h2><p>如果你是使用vue-cli3构建的项目，则直接vue-cli-service build –report就会生成一个report.html，打开这个html就能看到webpack打包之后的模块与依赖的加载状态。如果不是由vuecli构建的项目，也很简单，直接npm install 安装webpack-bundle-analyzer模块，版本号过高的话可能有意外的错误，推荐安装5.0.0。之后在vue配置中引入该包，并自定义运行命令即可，具体的可参照官网。之后你就可以看到自己项目的打包分析了，针对那些用的比较少的模块，把全局引入修改成针对性引入、使用更轻量级的组件库。总之根据该打包分析图，尽量减少项目的体积即可。</p>
<h2 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h2><p>gzip压缩可以说是为了优化首屏加载速度最常用的方法之一了。Gzip 压缩背后的原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大。反之亦然。主要的实现方法有两个：</p>
<p>1、项目正常打包部署，直接在服务端对nginx配置进行修改。这样设置时，当你请求时,服务端就会先将对应的文件压缩成.gz格式再发送给你，客户端接收到了.gz文件的格式之后再解压并执行后续操作。相当于用压缩的时间，换取了文件传输的时间，通常都会是正优化，除非项目体积过小。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启gzip</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置缓冲区大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#压缩级别官网建议是6</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#压缩的类型</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8462</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   dist;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、项目打包时对webpack进行特殊设置，安装插件（compression-webpack-plugin）；打包同时生成成两份文件，第一份为正常的文件，另一个为gz压缩后的文件，部署时将其全部部署至服务端。下面是vuecli构建项目的webpack配置参考，不用vuecli构建的，直接修改webpack配置即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports= &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">                algorithm: <span class="string">&#x27;gzip&#x27;</span>, <span class="comment">// 使用gzip压缩</span></span><br><span class="line">                test: <span class="regexp">/\.js$|\.html$|\.css$/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">                filename: <span class="string">&#x27;[path].gz[query]&#x27;</span>, <span class="comment">// 压缩后的文件名(保持原文件名，后缀加.gz)</span></span><br><span class="line">                minRatio: <span class="number">1</span>, <span class="comment">// 压缩率小于1才会压缩</span></span><br><span class="line">                threshold: <span class="number">10240</span>, <span class="comment">// 对超过10k的数据压缩</span></span><br><span class="line">                deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除未压缩的源文件，谨慎设置，如果希望提供非gzip的资源，可不设置或者设置为false（比如删除打包后的gz后还可以加载到原始资源文件）</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在nginx配置中使用：gzip_static on，该属性能够静态加载本地的gz文件，这样就完成了gzip。向较于上一种方案，这种方法虽然上传项目文件体积更大，但免去了服务端实时的压缩过程，速度会更快。</p>
<h2 id="CDN缓存优化"><a href="#CDN缓存优化" class="headerlink" title="CDN缓存优化"></a>CDN缓存优化</h2><p>定义：CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。相较于其他的缓存是为了优化网页流畅程度，CDN缓存更多的是为了优化首屏加载速度。</p>
<p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。这两个概念都非常好理解。“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p>
<p><strong>CDN 往往被用来存放静态资源</strong>。上文中我们举例所提到的“根服务器”本质上是业务服务器，它的核心任务在于<strong>生成动态页面或返回非纯静态页面</strong>，这两种过程都是需要计算的。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。</p>
<p>所谓“静态资源”，就是像 JS、CSS、图片等<strong>不需要业务服务器进行计算即得的资源</strong>。而“动态资源”，顾名思义是需要<strong>后端实时动态生成的资源</strong>，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。什么是“非纯静态资源”呢？它是指<strong>需要服务器在页面之外作额外计算的 HTML 页面</strong>。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它<strong>和业务服务器的操作耦合</strong>，我们把它丢到CDN 上显然是不合适的。</p>
<p>所以简单总结一下：静态资源走CDN便可以实现对静态资源加载的优化。同时静态资源往往并不需要 Cookie 携带什么认证信息，因此把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现。</p>
<p>理论的介绍大概就这么多了，在我自己的项目实践中，其实并没有把静态资源均部署在CDN上，毕竟技术力有限。只是将一些引入的公共框架代码，利用了<a target="_blank" rel="noopener" href="https://www.bootcdn.cn/">BootCDN</a>提供的免费资源进行取代。以本项目为例，我将vue、vuex、axios、echarts、elementUI均修改为CDN引入。主要的好处有两个：1、分离了公共库后，项目打包体积小了，打包速度提升了；2、使用CDN加载更加快速，且减轻了服务器压力。</p>
<p>具体实施步骤如下：1、在index.html中，添加CDN代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/element-ui/2.7.2/theme-chalk/index.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.cjs.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vuex/4.0.0-rc.1/vuex.cjs.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.4.8/vue-router.common.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-echarts/5.0.0-beta.0/vue-echarts.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在vue.config.js中加入webpack配置代码，关于webpack配置中的externals，请<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/externals/">参考地址</a></p>
<h1 id="渲染层面的优化"><a href="#渲染层面的优化" class="headerlink" title="渲染层面的优化"></a>渲染层面的优化</h1><h2 id="服务端渲染技术"><a href="#服务端渲染技术" class="headerlink" title="服务端渲染技术"></a>服务端渲染技术</h2><p>提到渲染层面的优化就不得不说现在特别火的SSR技术了，其实它是一个相对的概念，其对立面是客户端渲染。客户端渲染就是常用的正常情况，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁。<strong>页面上呈现的内容，你在 html 源文件里里找不到</strong>——这正是它的特点。</p>
<p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，<strong>页面上呈现的内容，我们在 html 源文件里也能找到</strong>。关于服务端渲染的实践方式，已经有nust.js这样的框架可以使用了，不过由于我自己的技术原因，并没有去实践一下这个新潮的技术。这里我就只说一下SSR的优缺点了，很多地方也都会提到这个。</p>
<p>优点：1、主要是出于效益的原因，因为SSR之后，搜索引擎以及各种爬虫才能够爬取网站的内容，这样才便于网站的推广。</p>
<p>2、服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了。</p>
<p>缺点：服务端渲染本质上是<strong>本该浏览器做的事情，分担给服务器去做</strong>。这样当资源抵达浏览器时，它呈现的速度就快了。乍一看好像很合理，但其实这样会成倍地增加服务端的压力，造成大量的成本，很有可能得不偿失。</p>
<h2 id="CSS选择器优化"><a href="#CSS选择器优化" class="headerlink" title="CSS选择器优化"></a>CSS选择器优化</h2><p>CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配，与我们正常人的书写习惯刚好相反，因此在使用选择器时如果没有意识到这一点，就写出一些高性能消耗的选择器。例如: #mylist li {}。如果像这样写的话，浏览器必须遍历页面上每个 li 元素，并且每次都要去确认这个 li 元素的父元素 id 是不是 myList，这样会消耗大量性能。可以修改为：.myList_li {}同样，CSS中的通配符#会匹配所有元素，这样你使用时会让浏览器去遍历每一个元素。</p>
<p>以下为CSS书写时的性能提升方案：1、避免使用通配符，只对需要使用到的元素进行选择；2、关注可以通过继承实现的属性，避免重复匹配、重复定义；3、少使用标签选择器，尽量多使用类选择器。4、不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。5、减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</p>
<h2 id="DOM优化"><a href="#DOM优化" class="headerlink" title="DOM优化"></a>DOM优化</h2><h3 id="减少回流与重绘"><a href="#减少回流与重绘" class="headerlink" title="减少回流与重绘"></a>减少回流与重绘</h3><p>重绘不一定导致回流，回流一定会导致重绘。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。定义如下：</p>
<p>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p>
<p>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</p>
<p>1、尽量多使用变量来进行缓存跟DOM相关的数据，避免引起DOM变化；</p>
<p>2、避免逐条改变样式，使用类名去合并样式；</p>
<p>3、将 DOM “离线”：当我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。拿掉一个元素，再将他放回去，虽然会触发一次回流，但在这期间对其做的任何操作，都不会太大影响性能。</p>
<h3 id="减少获取DOM次数"><a href="#减少获取DOM次数" class="headerlink" title="减少获取DOM次数"></a>减少获取DOM次数</h3><p>在你需要多次操作并修改某个DOM时，只执行一次获取DOM的操作并将其存在变量中，这样就能节省获取DOM的性能消耗。</p>
<h3 id="减少修改DOM的次数"><a href="#减少修改DOM的次数" class="headerlink" title="减少修改DOM的次数"></a>减少修改DOM的次数</h3><p>对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程。由于JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。这其实就是DOM Fragment](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment</a>) 的思路。</p>
<p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个DOM Fragment对象作为容器</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123;</span><br><span class="line">  <span class="comment">// span此时可以通过DOM API去创建</span></span><br><span class="line">  <span class="keyword">let</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">&quot;span&quot;</span>)</span><br><span class="line">  oSpan.innerHTML = <span class="string">&#x27;我是一个小测试&#x27;</span></span><br><span class="line">  <span class="comment">// 像操作真实DOM一样操作DOM Fragment对象</span></span><br><span class="line">  content.appendChild(oSpan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发真实DOM的更改</span></span><br><span class="line">container.appendChild(content)</span><br></pre></td></tr></table></figure>

<p>DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后全身而退，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。使用微任务队列，实现异步更新来避免过度渲染，就是用JS给DOM分压。</p>

      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/06/%E5%89%8D%E7%AB%AF/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/06/%E5%89%8D%E7%AB%AF/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">屏幕适配解决方案</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2021-03-06 21:28:16" itemprop="dateCreated datePublished" datetime="2021-03-06T21:28:16+08:00">2021-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 22:51:11" itemprop="dateModified" datetime="2021-03-12T22:51:11+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目是基于vue框架构建的，使用了elementUI组件库和echarts插件。开发过程中需要实现的一个需求是希望能够让首页实现大屏幕的适配效果。大概的完成思路借鉴了手机淘宝之前的flexible.js，就是获取不同屏幕的宽度，然后修改html根元素的字体大小；这样跟根元素字体大小绑定的rem就能够实时地监听屏幕的变化，实现不同屏幕的适配。</p>
<p>其实移动端的适配也是同理，不过好像有很多的坑，但本项目没有移动端适配的需求，因此就暂且采用了简单的rem适配的方法。由于首页中有echarts表单，需要也能够监听屏幕的变化，因此除了flexible.js以外，我们还需要自定义一个resize.js混入在首页的每个echarts上，让其也会实时跟踪监听屏幕变化，这样才能够实现首页所有元素的屏幕适配。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p>最简单最直接的方式就是直接用百分端来设置元素的尺寸；可以实现元素大小的自适应，但无法实现字体大小的自适应，而且尺寸转为百分比计算十分麻烦。其实我们需要的是一个和屏幕宽度正相关的单位，而且这个单位要和px很容易互相转化。这样我们就可以使用这种单位进行元素尺寸和字体大小的设置。</p>
<p>em单位为相对长度单位，是根据当前元素的父元素的字体大小来计算的；但父级元素改变时，则em会经常改变，因此后面推出了rem来代替em单位的功能。</p>
<p>rem单位也是一个相对长度单位，1rem等于html元素上字体设置的大小；我们只要设置html上font-size的大小就可以改变rem所代表的大小。</p>
<p>vw、vh都是viewport视窗的相对长度单位，100vw代表着viewport视窗的宽度，100vh代表着viewport视窗的高度。</p>
<p>设备像素比device pixel ratio简称dpr，即物理像素和设备独立像素的比值，设备像素比越大意味着你的手机屏幕越高清。</p>
<p>例如：电脑的dpr都为1，而iphone7的dpr为2，因此设计稿上的1px，要想让iphone7实现适配，CSS应该为0.5px。而有的浏览器在解析0.5px 的时候会把他解析成1px,所以呈现出来会变成2px。这就是经典的1px问题。</p>
<h3 id="1px问题"><a href="#1px问题" class="headerlink" title="1px问题"></a>1px问题</h3><p>解决方案：既然1个css像素代表两个物理像素，设备又不认0.5px的写法，那就画1px，然后再想尽各种办法将线宽减少一半。</p>
<p>1、图片大法及背景渐变。这两种方案原理一样,都是设置元素一半有颜色,一半透明,比如做一个<code>2px</code>高度的图片,其中<code>1px</code>是我们想要的颜色,<code>1px</code>设置为透明。</p>
<p>2、缩放大法。这也是flexible.js的解决方案，根据对应的dpr调整对应的缩放比例,从而达到适配的目的,直接缩放页面。</p>
<p>3、使用伪元素缩放。transform: scale(1, 0.5);实现缩放的功能。</p>
<h2 id="flex弹性盒子布局"><a href="#flex弹性盒子布局" class="headerlink" title="flex弹性盒子布局"></a>flex弹性盒子布局</h2><p>当我们采用flex布局时，flex会自己根据屏幕的宽度进行适配。关于flex适配的方案比较容易，通常跟rem一起来实现屏幕宽度不同时的界面适配。这里就只介绍一下flex的基础概念，具体的布局在理解定义后较为简单，就不列举实例了。</p>
<p>简要介绍下flex常用的属性：父容器：display:flex; flex-direction用于确定flex主轴布局的方向；接下来的 justify-content, align-items, align-content 用于确定 flex 项对于 flex 容器空间的空白如何处理。</p>
<p>flex容器中的子元素会成为flex项。flex属性是flex-grow, flex-shrink, flex-basis 三个属性的简写属性。grow、shrink分别代表着增长和收缩因子；basis代表着初始基准大小。默认值为：flex: 0 1 auto。flex-basis 指定固定的长度值时，其优先级高于width；flex-basis 指定百分比值时，其参考对象是 main size.所以其计算值 flex-basis: percent * mainSize px。</p>
<h2 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h2><p>原理其实前面已经讲过了，就是识别不同的屏幕长宽来设置不同的html根元素的字体大小，从而用动态的rem来实现界面的配置。关键在于如何识别不同的屏幕宽度。</p>
<p>1、利用媒体查询：@media screen and (min-width:XXX)来判断设备的尺寸，进而设置html的fontSize，比较麻烦且需要考虑较多。</p>
<p>2、利用js获取并设置fontSize，简单实例如下。以下代码是以iphone6为设计稿，结果是1rem=100px的实际像素，因为iphone6的设备像素比是2所以1rem在浏览器的预览中是50px，也就是实现了1rem和设备宽度成7.5倍的关系，设备宽度改变1rem的实际大小也会改变，</p>
<p>但我自己则是用了手机淘宝开源的flexible.js，稍微修改后便实现了需求，代码比这个实例复杂许多，具体代码会贴在文章的最后。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRem</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> htmlRem = <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">        <span class="built_in">document</span>.documentElement.style.fontSize = htmlRem/<span class="number">7.5</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">setRem()</span><br></pre></td></tr></table></figure>

<p>3、使用vm、vh：vw、vh是新的一种相对单位是把可视区域分的宽高为100份类似于百分比布局，这种方案它不用去写js，不过兼容性有点差。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10vw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="px适配"><a href="#px适配" class="headerlink" title="px适配"></a>px适配</h2><p>根据不同的屏幕宽度，计算处不同的px值,所以当我们改变苹果的大小时,网站就会刷新动态计算出对应的px值,从而达到适配的目的。具体的实施代码没有找到，但其实原理逻辑相差不大。</p>
<h1 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h1><p>项目的适配大概有2部分吧：1、使用flexible.js来实现不同屏幕的适配；在基于vue框架的项目中，这里的flexible.js直接import进main.js即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win, lib</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doc = win.document;</span><br><span class="line">  <span class="keyword">var</span> docEl = doc.documentElement;</span><br><span class="line">  <span class="keyword">var</span> metaEl = doc.querySelector(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> flexibleEl = doc.querySelector(<span class="string">&#x27;meta[name=&quot;flexible&quot;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> scale = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> tid;</span><br><span class="line">  <span class="keyword">var</span> flexible = lib.flexible || (lib.flexible = &#123;&#125;);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  获取dom树：win.document.documentElement，后续向HTML插入dpr、font-size；</span></span><br><span class="line"><span class="comment">  分别取meta标签中元素，判断用户是否曾经设置过；viewport的meta标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大</span></span><br><span class="line"><span class="comment">   设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系 = 物理像素 / 设备独立像素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEl) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&quot;将根据已有的meta标签来设置缩放比例&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> match = metaEl</span><br><span class="line">      .getAttribute(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-useless-escape</span></span><br><span class="line">      .match(<span class="regexp">/initial\-scale=([\d\.]+)/</span>);</span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      scale = <span class="built_in">parseFloat</span>(match[<span class="number">1</span>]);</span><br><span class="line">      dpr = <span class="built_in">parseInt</span>(<span class="number">1</span> / scale);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flexibleEl) &#123;</span><br><span class="line">    <span class="keyword">var</span> content = flexibleEl.getAttribute(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (content) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-useless-escape</span></span><br><span class="line">      <span class="keyword">var</span> initialDpr = content.match(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>);</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-useless-escape</span></span><br><span class="line">      <span class="keyword">var</span> maximumDpr = content.match(<span class="regexp">/maximum\-dpr=([\d\.]+)/</span>);</span><br><span class="line">      <span class="keyword">if</span> (initialDpr) &#123;</span><br><span class="line">        dpr = <span class="built_in">parseFloat</span>(initialDpr[<span class="number">1</span>]);</span><br><span class="line">        scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).toFixed(<span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maximumDpr) &#123;</span><br><span class="line">        dpr = <span class="built_in">parseFloat</span>(maximumDpr[<span class="number">1</span>]);</span><br><span class="line">        scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).toFixed(<span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   这段代码是判断你的meta标签里面是不是设置了name=viewport属性，如果你设置了viewport</span></span><br><span class="line"><span class="comment">   并且设置了initial-scale（初始屏幕的大小）我们将取到这个值作为dp</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dpr &amp;&amp; !scale) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-unused-vars</span></span><br><span class="line">    <span class="keyword">var</span> isAndroid = win.navigator.appVersion.match(<span class="regexp">/android/gi</span>);</span><br><span class="line">    <span class="keyword">var</span> isIPhone = win.navigator.appVersion.match(<span class="regexp">/iphone/gi</span>);</span><br><span class="line">    <span class="keyword">var</span> devicePixelRatio = win.devicePixelRatio;</span><br><span class="line">    <span class="keyword">if</span> (isIPhone) &#123;</span><br><span class="line">      <span class="comment">// iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案</span></span><br><span class="line">      <span class="keyword">if</span> (devicePixelRatio &gt;= <span class="number">3</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">3</span>)) &#123;</span><br><span class="line">        dpr = <span class="number">3</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (devicePixelRatio &gt;= <span class="number">2</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">2</span>)) &#123;</span><br><span class="line">        dpr = <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dpr = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他设备下，仍旧使用1倍的方案</span></span><br><span class="line">      dpr = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scale = <span class="number">1</span> / dpr;</span><br><span class="line">  &#125;</span><br><span class="line">  docEl.setAttribute(<span class="string">&quot;data-dpr&quot;</span>, dpr);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  之后如果我们动态设置了scale或者设置了meta标签里面的name＝flexible的inital-scale，</span></span><br><span class="line"><span class="comment">  那么我们就根据自己设置的dpr在判断iphone手机的retina屏幕的dpr比值判断不同型号的倍数，最后我们在html上设置了data-dpr自定义属性。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!metaEl) &#123;</span><br><span class="line">    metaEl = doc.createElement(<span class="string">&quot;meta&quot;</span>);</span><br><span class="line">    metaEl.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;viewport&quot;</span>);</span><br><span class="line">    metaEl.setAttribute(</span><br><span class="line">      <span class="string">&quot;content&quot;</span>,</span><br><span class="line">      <span class="string">&quot;initial-scale=&quot;</span> +</span><br><span class="line">        scale +</span><br><span class="line">        <span class="string">&quot;, maximum-scale=&quot;</span> +</span><br><span class="line">        scale +</span><br><span class="line">        <span class="string">&quot;, minimum-scale=&quot;</span> +</span><br><span class="line">        scale +</span><br><span class="line">        <span class="string">&quot;, user-scalable=no&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (docEl.firstElementChild) &#123;</span><br><span class="line">      docEl.firstElementChild.appendChild(metaEl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> wrap = doc.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      wrap.appendChild(metaEl);</span><br><span class="line">      doc.write(wrap.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  之后当我们之前没有设置metaEl标签的话，那么需要我们手动的去创建meta标签，实现移动端的适配</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = docEl.getBoundingClientRect().width;</span><br><span class="line">    <span class="comment">// 最小1366px，最大适配2560px</span></span><br><span class="line">    <span class="keyword">if</span> (width / dpr &lt; <span class="number">1366</span>) &#123;</span><br><span class="line">      width = <span class="number">1366</span> * dpr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (width / dpr &gt; <span class="number">2560</span>) &#123;</span><br><span class="line">      width = <span class="number">2560</span> * dpr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置成24等份，设计稿时1920px的，这样1rem就是80px</span></span><br><span class="line">    <span class="keyword">var</span> rem = width / <span class="number">24</span>;</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    flexible.rem = win.rem = rem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">      tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  win.addEventListener(</span><br><span class="line">    <span class="string">&quot;pageshow&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">        tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这段代码的目的就是监听window里面的resize和pageshow方法来实现css样式的重绘。</span></span><br><span class="line"><span class="comment">  函数里面就是实现取到当前设备的width之后根据width计算出rem的具体值，rem代表html的font-size，</span></span><br><span class="line"><span class="comment">  这里的rem代表的是一个自定义的rem，而不是rem属性！</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (doc.readyState === <span class="string">&quot;complete&quot;</span>) &#123;</span><br><span class="line">    doc.body.style.fontSize = <span class="number">12</span> * dpr + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doc.addEventListener(</span><br><span class="line">      <span class="string">&quot;DOMContentLoaded&quot;</span>,</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-unused-vars</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        doc.body.style.fontSize = <span class="number">12</span> * dpr + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  之后我们判断document对象是否处于complete状态，</span></span><br><span class="line"><span class="comment">  如果完成状态我们给body一个font-size＝12*dpr的值，否则我们判断dom加载方法来实现body中的font-size的设置。</span></span><br><span class="line"><span class="comment">  这个设置是为了页面中字体的大小，而html中的font-size是为了设置页面的height，width等属性。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  refreshRem();</span><br><span class="line"></span><br><span class="line">  flexible.dpr = win.dpr = dpr;</span><br><span class="line">  flexible.refreshRem = refreshRem;</span><br><span class="line">  flexible.rem2px = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">parseFloat</span>(d) * <span class="built_in">this</span>.rem;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> d === <span class="string">&quot;string&quot;</span> &amp;&amp; d.match(<span class="regexp">/rem$/</span>)) &#123;</span><br><span class="line">      val += <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">  flexible.px2rem = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">parseFloat</span>(d) / <span class="built_in">this</span>.rem;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> d === <span class="string">&quot;string&quot;</span> &amp;&amp; d.match(<span class="regexp">/px$/</span>)) &#123;</span><br><span class="line">      val += <span class="string">&quot;rem&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>[<span class="string">&quot;lib&quot;</span>] || (<span class="built_in">window</span>[<span class="string">&quot;lib&quot;</span>] = &#123;&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、由于首页中还有echarts组件的展示，需要自定义一个函数来监听屏幕的变化，当屏幕变化时则修改echarts组件中chart的大小；这个resize的效果需要用防抖的函数来控制resize的频率。这里我把防抖写在了一个公共库里，就能方便复用，对于resize.js，直接混入在有echarts插件的vue文件中即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 据上一次触发时间间隔</span></span><br><span class="line">    <span class="keyword">const</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>() - timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait</span></span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用</span></span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    context = <span class="built_in">this</span>;</span><br><span class="line">    timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="comment">// 如果延时不存在，重新设定延时</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = <span class="built_in">setTimeout</span>(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&#x27;@/XXX/XXXX&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> resizeChartMethod = <span class="string">&#x27;$__resizeChartMethod&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="comment">// 在组件内部将图表init的引用映射到chart属性上</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      chart: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="built_in">this</span>[resizeChartMethod], <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;reisze&#x27;</span>, <span class="built_in">this</span>[resizeChartMethod]);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 通过lodash的防抖函数来控制resize的频率</span></span><br><span class="line">    [resizeChartMethod]: debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.chart) &#123;</span><br><span class="line">        <span class="built_in">this</span>.chart.resize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/24/%E5%89%8D%E7%AB%AF/JS%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/%E5%89%8D%E7%AB%AF/JS%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">JS力扣刷题记</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2021-02-24 20:02:33" itemprop="dateCreated datePublished" datetime="2021-02-24T20:02:33+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 22:51:49" itemprop="dateModified" datetime="2021-03-12T22:51:49+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如题，打算使用JS从头开始刷leetcode，大致地记录并讲解一下自己的解题思路吧，由于自己的水平原因，所以思路与解法都会比较偏新手向吧，同时不会只关注这一个题的思路，会有一些整体的思路与延伸吧。做这个记录的原因主要是想以新手的角度讲下自己解题遇到的弯路，同时也给自己加深印象吧。开始时可能注释会有些啰嗦，后续会减少不必要的代码解释。打算先写完并理解前150题吧，也并不打算分类的，因为前百题的思路都是经典解题思路，都需要慢慢体会吧。</p>
<h2 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。你可以按任意顺序返回答案。转载自<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.set(nums[i], i);</span><br><span class="line">        <span class="comment">//很简单的题目与逻辑，用map即哈希表的方法辅助查找即可，使用map的set方法构建。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> newTarget = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.has(newTarget) &amp;&amp; (map.get(newTarget) !== i)) &#123;</span><br><span class="line">            res.push(i, map.get(newTarget));</span><br><span class="line">            <span class="comment">//使用has、get方法分别判断与获取索引</span></span><br><span class="line">            <span class="comment">//这里要注意下，不能两个相同索引相加</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h2><p>给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。转载至<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">两数之和</a></p>
<p>例：输入：l1 = [2,4,3], l2 = [5,6,4]；输出：[7,0,8]；解释：342 + 465 = 807。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义进位，</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//一般链表题目的输出，需要先新建一个空的头节点，之后以该空结点作链表处理，从而能够避免因链表长度不够导致的报错,后续返回head.next</span></span><br><span class="line">    <span class="keyword">let</span> head = sum;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="keyword">let</span> value1 = ((l1 === <span class="literal">null</span>) ? <span class="number">0</span> : l1.val);</span><br><span class="line">        <span class="comment">//其实是在往前面补0，以确保两个加数位数一致</span></span><br><span class="line">        <span class="keyword">let</span> value2 = ((l2 === <span class="literal">null</span>) ? <span class="number">0</span> : l2.val);</span><br><span class="line">        sum.next = <span class="keyword">new</span> ListNode((value1 + value2 + carry) % <span class="number">10</span>);</span><br><span class="line">        carry = ((value1 + value2 + carry) &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        sum = sum.next;</span><br><span class="line">        <span class="keyword">if</span> (l1) l1 = l1.next;</span><br><span class="line">        <span class="keyword">if</span> (l2) l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，除了用链表来存储大数以外，在JS中更常用的是用字符串来保存，因此下面我们写一个字符串类型的大数相加，基本的逻辑和链表是一样的，主要是处理的方式不同，这里我就不再赘述原理了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a.length &gt; b.length)&#123;</span><br><span class="line">    a = <span class="string">&#x27;0&#x27;</span> + a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = b.length; i &lt; a.length; i++)&#123;</span><br><span class="line">      b = <span class="string">&#x27;0&#x27;</span> + b;</span><br><span class="line">    &#125;</span><br><span class="line">    m = a.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    n = b.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    b = <span class="string">&#x27;0&#x27;</span> + b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = a.length; i &lt; b.length; i++)&#123;</span><br><span class="line">      a = <span class="string">&#x27;0&#x27;</span> + a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    b = b.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> k = (<span class="built_in">parseInt</span>(a[i]) + <span class="built_in">parseInt</span>(b[i]) + sum) % <span class="number">10</span>;</span><br><span class="line">        res.unshift(k);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">parseInt</span>(a[i]) + <span class="built_in">parseInt</span>(b[i]) + sum) &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m === n) &amp;&amp; (i = t)) &#123;</span><br><span class="line">                res.unshift(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ans = res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、无重复字符的最长子串"><a href="#3、无重复字符的最长子串" class="headerlink" title="3、无重复字符的最长子串"></a>3、无重复字符的最长子串</h2><p>题目：给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>例如：输入: s = “abcabcbb”。输出: 3 。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>思路：像这种子串的问题，最小覆盖子串、字符串的排列、找到字符串中所有字母异位词、无重复字符的最长子串。其实思路基本一致，子串的问题基本都能用滑动窗口的思想来解决。滑动窗口就是双指针的进阶版吧，即维护一个窗口，不断滑动并更新答案。</p>
<p><strong><em>1、</em></strong>我们在字符串<code>S</code>中使用双指针中的左右指针技巧，初始化<code>left = right = 0</code>，把索引左闭右开区间<code>[left, right)</code>称为一个「窗口」。</p>
<p><strong><em>2、</em></strong>我们先不断地增加<code>right</code>指针扩大窗口<code>[left, right)</code>，直到窗口中的字符串符合要求（包含了<code>T</code>中的所有字符）。</p>
<p><strong><em>3、</em></strong>此时，我们停止增加<code>right</code>，转而不断增加<code>left</code>指针缩小窗口<code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含<code>T</code>中的所有字符了）。同时，每次增加<code>left</code>，我们都要更新一轮结果。</p>
<p><strong><em>4、</em></strong>重复第 2 和第 3 步，直到<code>right</code>到达字符串<code>S</code>的尽头</p>
<p><strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。下面画图理解一下，<code>needs</code>和<code>window</code>相当于计数器，分别记录<code>T</code>中字符出现次数和「窗口」中的相应字符的出现次数。v</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">//本题的关键在于如何判断是否无重复子串，用indexOf判断新进项即可，或者直接用for循环判断</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = arr.indexOf(s[right]);</span><br><span class="line">        <span class="keyword">if</span> (index !== <span class="number">-1</span>) &#123;</span><br><span class="line">            arr.splice(<span class="number">0</span>, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将重复项之前全部删除,这里其实我们用字符串的操作来代替了滑动窗口的左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(s[right]);</span><br><span class="line">        length = <span class="built_in">Math</span>.max(length, arr.length);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4、寻找正序数组的两个中位数"><a href="#4、寻找正序数组的两个中位数" class="headerlink" title="4、寻找正序数组的两个中位数"></a>4、寻找正序数组的两个中位数</h2><p>题目：给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
<p>思路：暴力求解的话极其简单，直接for循环即可，第一时间会想到就是归并排序最后一步。按照 O(log (m+n)) 时间复杂度的话，面对有序数组的排序，首先想到二分查找，见下方，但是对于两个数组的二分查找该如何实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span>(<span class="params">arr,low, high, key</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (low &gt; high)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> mid = <span class="built_in">parseInt</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>该题的本质可扩展为寻找两个有序数组的第k小数，不一定是中位数，因此二分查找的本质是partition，每次都剔除k/2个数，且保证这些数都在第k小数左边，即都比第k小数小，然后k = k/2；递归处理后，得到第k小数。</p>
<p>二分查找，关键点在于要partition两个排好序的数组成左右两等份，partition需要满足len(Aleft)+len(Bleft)=(m+n+1)/2 - m是数组A的长度， n是数组B的长度并且partition后 A左边最大(maxLeftA), A右边最小（minRightA), B左边最大（maxLeftB), B右边最小（minRightB) 满足(maxLeftA &lt;= minRightB &amp;&amp; maxLeftB &lt;= minRightA)有了这两个条件，那么median就在这四个数中，根据奇数或者是偶数。</p>
<p>奇数：median = max(maxLeftA, maxLeftB)；偶数：median = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分解法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 确保nums1为更短的字符串</span></span><br><span class="line">  <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> m = nums1.length</span><br><span class="line">  <span class="keyword">const</span> n = nums2.length</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> high = m</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">const</span> i = low + <span class="built_in">Math</span>.floor((high - low) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor((m + n + <span class="number">1</span>) / <span class="number">2</span>) - i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxLeftA = i === <span class="number">0</span> ? -<span class="literal">Infinity</span> : nums1[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">const</span> minRightA = i === m ? <span class="literal">Infinity</span> : nums1[i]</span><br><span class="line">    <span class="keyword">const</span> maxLeftB = j === <span class="number">0</span> ? -<span class="literal">Infinity</span> : nums2[j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">const</span> minRightB = j === n ? <span class="literal">Infinity</span> : nums2[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxLeftA &lt;= minRightB &amp;&amp; minRightA &gt;= maxLeftB) &#123;</span><br><span class="line">      <span class="keyword">return</span> (m + n) % <span class="number">2</span> === <span class="number">1</span></span><br><span class="line">        ? <span class="built_in">Math</span>.max(maxLeftA, maxLeftB)</span><br><span class="line">        : (<span class="built_in">Math</span>.max(maxLeftA, maxLeftB) + <span class="built_in">Math</span>.min(minRightA, minRightB)) / <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxLeftA &gt; minRightB) &#123;</span><br><span class="line">      high = i - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = low + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串"></a>5、最长回文子串</h2><p>题目：给你一个字符串 s，找到 s中最长的回文子串。</p>
<p>思路：最长回文子串的关键，其实通过双指针法也可以来处理，根据上题所述的思路很好进行解决，关键在于如何判定是否是回文子串的函数。但回文子串以及后序的回文子序列等问题，由于前后文联系比较紧密，且多次判断是否符合时间复杂度较大，通常使用动态规划来进行求解。</p>
<p>动态转移方程：dp[i] [j] = dp[i+1] [j-1] &amp;&amp; (dp[i] === dp[j])；dp[i] [j]为true指的是：从i到j是回文串。</p>
<p>初始条件：即字符串长度仅为0、1时，必为回文子串，由于有这样的初始条件，初始项比较多，动态转移方程需要修改成:dp[i] [j] = (dp[i] === dp[j] &amp;&amp; (j - i &lt; 2 || dp[i+1] dp[j - 1]))。同样，由于初始条件必然有j &gt; i，像这种初始条件的dp，一般都会使用斜向遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(s.length), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//利用Array.from构建二维数组，或者使用for循环也可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//这里由于动态转移方程中dp[i][..]依赖于dp[i + 1][..]，因此需要倒着遍历来简化操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.length; j++) &#123;</span><br><span class="line">            <span class="comment">//同样，由于初始条件原因，j从靠近i到远离i来遍历</span></span><br><span class="line">            dp[i][j] = ((s[i] === s[j]) &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; (j - i + <span class="number">1</span> &gt; res.length)) &#123;</span><br><span class="line">                res = s.substring(i, j+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//substring截取字符串，包头不包尾</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、Z字形变换"><a href="#6、Z字形变换" class="headerlink" title="6、Z字形变换"></a>6、Z字形变换</h2><p>题目：将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。请你实现这个将字符串进行指定行数变换的函数：let convert(string s, int numRows)。</p>
<p> P     A     H     N<br>        A  P L S  I   I  G<br>        Y     I      R</p>
<p>思路：关键在于找规律，中间列每列一个，且列数为numsRows-2；因此将一个第一列与后续的中间列作为一个循环，个数为numsRows + numsRows - 2。这样一个循环就能找出来了，再根据每个字符在循环中的位置，分别将其置入不同行。其中仅循环的第一位为第一行，V形排列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(numRows).fill(<span class="string">&quot;&quot;</span>);<span class="comment">//用数组依次存储每一行的字符</span></span><br><span class="line">    <span class="keyword">let</span> circle = (<span class="number">2</span> * numRows - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = i % circle;</span><br><span class="line">        rows[<span class="built_in">Math</span>.min(x, circle - x)] += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ans = rows.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、整数反转"><a href="#7、整数反转" class="headerlink" title="7、整数反转"></a>7、整数反转</h2><p>题目：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>思路：在先判断正负号之后，用转字符串再转数组后，使用reverse()方法可以简单实现，但可以思考下用数学方法要如何处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先试一下数组反转，可以轻松解决</span></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = x.toString().split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (res[<span class="number">0</span>] == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">        res.push(<span class="string">&quot;-&quot;</span>);<span class="comment">//反转后，相当于在前面加-，后面的负号parseInt会忽略掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="built_in">parseInt</span>(res.reverse().join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (ans &gt;= <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) || ans &lt;= -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;ue</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再试一下数学方法，关键在于一位位地取余数</span></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">        result = x % <span class="number">10</span> + result * <span class="number">10</span>;</span><br><span class="line">        x = (x / <span class="number">10</span>) | <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//通过位运算符保证取整(无论正负)，同时强制转换为32位有符号整数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (result | <span class="number">0</span>) === result ? result : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//result | 0 超过32位的整数转换结果不等于自身，可用作溢出判断。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、字符串转整数"><a href="#8、字符串转整数" class="headerlink" title="8、字符串转整数"></a>8、字符串转整数</h2><p>题目：请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</p>
<p>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</p>
<p>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</p>
<p>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>注意：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像这种字符串匹配的，先想到使用正则即可，先用trim来去掉前后的空格</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^(-|\+)?\d+/</span>);</span><br><span class="line">    <span class="keyword">let</span> str = s.trim().match(re);</span><br><span class="line">    <span class="keyword">let</span> res = str ? <span class="built_in">Number</span>(str[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res &gt;= <span class="number">0</span> ? <span class="built_in">Math</span>.min(res, <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>) : <span class="built_in">Math</span>.max(res, -(<span class="number">2</span>**<span class="number">31</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9、回文数"><a href="#9、回文数" class="headerlink" title="9、回文数"></a>9、回文数</h2><p>题目：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>思路：跟前面的整数反转一样，简单的思路的话，直接变数组之后，使用reverse()方法之后判断即可；同样也有数学方法来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接用reverse()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x === <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用数学方法来一步步求余</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> value = x;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x = (x / <span class="number">10</span>) | <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value = result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、正则表达式匹配"><a href="#10、正则表达式匹配" class="headerlink" title="10、正则表达式匹配"></a>10、正则表达式匹配</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isMatch = <span class="function">(<span class="params">s, p</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">null</span> || p == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sLen = s.length, pLen = p.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(sLen + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(pLen + <span class="number">1</span>).fill(<span class="literal">false</span>); <span class="comment">// 将项默认为false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; pLen + <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&quot;*&quot;</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; pLen + <span class="number">1</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">          dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[sLen][pLen]; <span class="comment">// 长sLen的s串 是否匹配 长pLen的p串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="11、盛水最多的容器"><a href="#11、盛水最多的容器" class="headerlink" title="11、盛水最多的容器"></a>11、盛水最多的容器</h2><p>题目：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p>示例：输入：[1,8,6,2,5,4,8,3,7]；输出：49 ；解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>思路：其实是一个滑动窗口(双指针)类型的题目，暴力法：即穷举所有可能，分别计算面积并保存最大值。</p>
<p>双指针法：从左右两侧开始，将较矮柱子的指针进行移动，而先不移动高柱子的指针，原因：矮柱子选取后如果移动高柱子的话面积是一定会减小的，因为长度距离在变小的时候，此时高度只能小于或等于矮的柱子。因此只能移动矮的柱子这边才有可能使得高度比矮柱子大。所以，每次都移动的是高柱子的指针。这种方法其可以看作是暴力法的剪枝，而不是传统的滑动窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">height</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> height1 = <span class="built_in">Math</span>.min(height[left], height[right]);</span><br><span class="line">        <span class="keyword">let</span> aquare = height1 * (right - left);</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, aquare);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、整数转罗马数字"><a href="#12、整数转罗马数字" class="headerlink" title="12、整数转罗马数字"></a>12、整数转罗马数字</h2><p>思路：整数转罗马数字，比罗马数字转整数要简洁一些，同样关键在于求余的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Q = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> B = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> S = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>];</span><br><span class="line">    <span class="keyword">var</span> G = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> Q[<span class="built_in">Math</span>.floor(num/<span class="number">1000</span>)] + B[<span class="built_in">Math</span>.floor((num%<span class="number">1000</span>)/<span class="number">100</span>)] + S[<span class="built_in">Math</span>.floor((num%<span class="number">100</span>)/<span class="number">10</span>)] + G[num%<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用Math.floor来直接取整数部分，而不是四舍五入</span></span><br></pre></td></tr></table></figure>

<h2 id="13、罗马数字转整数"><a href="#13、罗马数字转整数" class="headerlink" title="13、罗马数字转整数"></a>13、罗马数字转整数</h2><p>思路：罗马数字转整数，首先将所有的组合可能性列出并添加到哈希表中</p>
<p>然后对字符串进行遍历，由于组合只有两种，一种是 1 个字符，一种是 2 个字符，其中 2 个字符优先于 1 个字符</p>
<p>先判断两个字符的组合在哈希表中是否存在，存在则将值取出加到结果 ans 中，并向后移2个字符。不存在则将判断当前 1 个字符是否存在，存在则将值取出加到结果 ans 中，并向后移 1 个字符，遍历结束返回结果 ans。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> romanToInt = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;</span><br><span class="line">        I : <span class="number">1</span>,</span><br><span class="line">        IV: <span class="number">4</span>,</span><br><span class="line">        V: <span class="number">5</span>,</span><br><span class="line">        IX: <span class="number">9</span>,</span><br><span class="line">        X: <span class="number">10</span>,</span><br><span class="line">        XL: <span class="number">40</span>,</span><br><span class="line">        L: <span class="number">50</span>,</span><br><span class="line">        XC: <span class="number">90</span>,</span><br><span class="line">        C: <span class="number">100</span>,</span><br><span class="line">        CD: <span class="number">400</span>,</span><br><span class="line">        D: <span class="number">500</span>,</span><br><span class="line">        CM: <span class="number">900</span>,</span><br><span class="line">        M: <span class="number">1000</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.length;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; s.length &amp;&amp; map[s.substring(i, i+<span class="number">2</span>)]) &#123;</span><br><span class="line">            ans += map[s.substring(i, i+<span class="number">2</span>)];</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += map[s.substring(i, i+<span class="number">1</span>)];</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="14、最长公共前缀"><a href="#14、最长公共前缀" class="headerlink" title="14、最长公共前缀"></a>14、最长公共前缀</h2><p>题目：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p>思路：很简单的题目，一个个的依次找最长公共前缀，先比较前两个，再用得出的公共前缀来匹配下一个；因此需要两层for循环，第一层，用于获取各个字符串，第二层对比每个字符串的各个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">strs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> compare = res;</span><br><span class="line">        res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//前两个先比较,每次比较前修改compare,并重置res</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; (j &lt; strs[i].length) &amp;&amp; (j &lt; compare.length); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i][j] === compare[j]) &#123;</span><br><span class="line">                res = res + compare[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//提前退出的条件，剪枝j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<p>思路：关键在于如何保证不重复，用常规思路的话，先用三层for循环，之后再用哈希表去重；换一个思路，我们保持三重循环的大框架不变，只需要保证：第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。即这样就只有一种顺序被枚举了，可以先排序，然后再查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a - b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//在算法范畴上，进行逻辑的剪枝，此时后续不可能成立</span></span><br><span class="line">        <span class="keyword">let</span> target = -nums[i];</span><br><span class="line">        <span class="keyword">if</span> ((target + nums[i - <span class="number">1</span>] == <span class="number">0</span>) &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//从左往右遍历，此时遇到重复的则直接跳过，使用continue到for的下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到一个后，后续的使用双指针来遍历查找，同时去重</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> n2 = nums[left];</span><br><span class="line">            <span class="keyword">let</span> n3 = nums[right];</span><br><span class="line">            <span class="keyword">if</span> (n2 + n3 === target) &#123;</span><br><span class="line">                res.push([nums[i], n2, n3]);</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === n2) left++;</span><br><span class="line">                <span class="comment">//去重复，后面有相同的则这里直接left++跳过去</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === n3) right++;</span><br><span class="line">                <span class="comment">//这里在去重时，不要忘记基本的left &lt; right</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n2 + n3 &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16、最接近的三数之和"><a href="#16、最接近的三数之和" class="headerlink" title="16、最接近的三数之和"></a>16、最接近的三数之和</h2><p>题目：给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>思路：同样的思路，排序加双指针的做法能够很好地判断该如何去判断怎么去移动；同样，本题中不需要去考虑重复的问题了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSumClosest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a - b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> compare = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> compare2 = target - nums[left] - nums[right] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(compare2) &lt; compare) &#123;</span><br><span class="line">                ans = nums[i] + nums[right] + nums[left];</span><br><span class="line">                compare = <span class="built_in">Math</span>.abs(compare2)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (compare2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17、电话号码的组合"><a href="#17、电话号码的组合" class="headerlink" title="17、电话号码的组合"></a>17、电话号码的组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>思路：看上去十分容易，本质是一个三叉树的遍历方法，可以用BFS或者DFS。由这个题，我们可以先引申一下深度遍历和广度遍历的思路逻辑与基本方法。</p>
<p>1、DFS回溯（回溯是一种算法思想，一般可以用递归来实现。通俗点讲回溯就是一种试探,类似于穷举,但回溯有“剪枝”功能,）</p>
<p>回溯本质是暴力搜索，在问题的解空间树中，用 DFS 的方式，从根节点出发搜索整个解空间。如果要找出所有的解，则要搜索整个子树，如果只用找出一个解，则搜到一个解就可以结束搜索。类似「找出所有可能的组合」的问题，适合回溯算法。</p>
<p>回溯类题目，有三个关键点：</p>
<p>(1).选择:决定了你每个节点有哪些分支，可以帮助你构建出解的空间树。</p>
<p>(2).约束条件:用来剪枝，剪去不满足约束条件的子树，避免无效的搜索。</p>
<p>(3).目标:决定了何时捕获解，或者剪去得不到解的子树，提前回溯。</p>
<p>回溯法实质:它的求解过程实质上是先序遍历一棵“状态树”的过程。只不过，这棵树不是遍历前预先建立的，而是隐含在遍历过程中。如果认识到这点，很多问题的递归过程设计也就迎刃而解了。【回溯与递归的区别】回溯这个算法思想可以由递归这个算法结构来实现</p>
<p>我们构建一个递归来实现DFS，。递归的关键：递归关系与递归终止条件。（其他的扔给递归）</p>
<p>1、找整个递归的终止条件：递归应该在什么时候结束？2、找返回值：应该给下一级返回什么信息？3、本级递归应该做什么：在这一级递归中，应该完成什么任务？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> letterCombinations = <span class="function">(<span class="params">digits</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>], [<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;def&#x27;</span>],[<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;ghi&#x27;</span>],[<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;jkl&#x27;</span>],[<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;mno&#x27;</span>],[<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;pqrs&#x27;</span>],[<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;tuv&#x27;</span>],[<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;wxyz&#x27;</span>]]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">curStr, i</span>) =&gt;</span> &#123;<span class="comment">//递归的传递参数包括，当前已经遍历树的结果、以及层数i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; digits.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.push(curStr);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//一个树的递归分支结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> letters = map.get(digits[i]);</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">of</span> letters) &#123;</span><br><span class="line">            <span class="comment">//for in 用于遍历对象,for of用于遍历有Iterator接口的对象,</span></span><br><span class="line">            dfs(curStr, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、BFS广度搜索的方法</p>
<p>BFS通常是维护一个队列，即一层层地进行遍历，每次将对应层数的叶子加到之前层上，这里可以使用队列先进先出来解决，先进先出，依次地每次更新对应的下一层的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> letterCombinations = <span class="function">(<span class="params">digits</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>], [<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;def&#x27;</span>],[<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;ghi&#x27;</span>],[<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;jkl&#x27;</span>],[<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;mno&#x27;</span>],[<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;pqrs&#x27;</span>],[<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;tuv&#x27;</span>],[<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;wxyz&#x27;</span>]]);</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    queue.push(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; digits.length; i++) &#123;<span class="comment">//bfs二叉树的层数，就是digits的长度</span></span><br><span class="line">        <span class="keyword">let</span> levelSize = queue.length;<span class="comment">//获取当前层的节点数，从而能逐个让当前层节点出列，更新接上对应后续节点后再依次入列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; levelSize; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> curStr = queue.shift(); <span class="comment">//模拟队列</span></span><br><span class="line">            <span class="keyword">let</span> letters = map.get(digits[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> letters) &#123;</span><br><span class="line">                queue.push(curStr + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18、四数之和"><a href="#18、四数之和" class="headerlink" title="18、四数之和"></a>18、四数之和</h2><p>题目：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组</p>
<p>思路：其实跟前面的三数之和思路一样，后面两个数可以用双指针法来进行枚举；而前面两个数只能通过两层的for循环来实现。同样，先对数组进行排序，且添加每个数时都要进行重复判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fourSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> quadruplets = [];</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y);</span><br><span class="line">    <span class="keyword">const</span> length = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//从左往右遍历，有跟上一条重复的则跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//上面两种情况都是剪枝，以减少事件复杂度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">                    quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quadruplets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19、删除链表的倒数第N个结点"><a href="#19、删除链表的倒数第N个结点" class="headerlink" title="19、删除链表的倒数第N个结点"></a>19、删除链表的倒数第N个结点</h2><p>题目:给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。进阶：你能尝试使用一趟扫描实现吗？</p>
<p>思路：不要求时间复杂度的话，先扫一遍来确定链表的长度，而后再根据长度找到倒数第N个结点；要使用一趟扫描实现的话，可以使用双指针来进行。第一个指针比第二个快n个，这样第二个指向尾节点时，则第一个指向要删除的结点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="keyword">new</span> ListNode;</span><br><span class="line">    <span class="comment">//一般先定义一个空结点放到现有的头节点前面，之后以该空结点作链表处理，从而能够避免因链表长度不够导致的报错</span></span><br><span class="line">    start.next = head;</span><br><span class="line">    <span class="keyword">let</span> left = start;</span><br><span class="line">    <span class="keyword">let</span> right = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    left.next = left.next.next;</span><br><span class="line">    <span class="keyword">return</span> start.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="20、有效的括号"><a href="#20、有效的括号" class="headerlink" title="20、有效的括号"></a>20、有效的括号</h2><p>题目：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。</p>
<p>思路：类似于栈的操作，判断很简单，这里就不赘述了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> compare = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&quot;(&quot;</span> || s[i] === <span class="string">&quot;[&quot;</span> || s[i] === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">            compare.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> a = compare.pop();</span><br><span class="line">            <span class="keyword">if</span> (a !== <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> a = compare.pop();</span><br><span class="line">            <span class="keyword">if</span> (a !== <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> a = compare.pop();</span><br><span class="line">            <span class="keyword">if</span> (a !== <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compare.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/06/%E5%89%8D%E7%AB%AF/%E6%AD%A3%E5%88%99%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/06/%E5%89%8D%E7%AB%AF/%E6%AD%A3%E5%88%99%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">正则面试题汇总</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2021-02-06 21:28:16" itemprop="dateCreated datePublished" datetime="2021-02-06T21:28:16+08:00">2021-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 22:51:31" itemprop="dateModified" datetime="2021-03-12T22:51:31+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。关于正则表达式的原理和写法，网上的文章已经特别之多了，本篇文章将不着重于原理与方法，将直接以各种题目的形式来进行正则表达式的介绍，同样，题目的难度也将由弱至强。首先附上经典的正则链接网站：<a target="_blank" rel="noopener" href="https://jex.im/regulex/#!flags=&re=%5E(%5Cd%7B3%7D-)%7B2%7D%5Cd%7B4%7D%26">regulex</a>。</p>
<h1 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h1><table>
<thead>
<tr>
<th>字符组</th>
<th>用于纵向模糊匹配，[]组内代表一个字符元素</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>在第一位放脱字符，表示求反的概念</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]，digit，表示一位数字</td>
</tr>
<tr>
<td>\D</td>
<td>[^0-9]，表示除数字外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>[0-9a-zA-Z]，word，表示数字、大小写字母和下划线等单词字母</td>
</tr>
<tr>
<td>\W</td>
<td>[^0-9a-zA-Z]，表示非单词字母</td>
</tr>
<tr>
<td>\s</td>
<td>[\t\v\n\r\f]，space，表示空白格，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符</td>
</tr>
<tr>
<td>\S</td>
<td>[^ \t\v\n\r\f]，表示非空白符</td>
</tr>
<tr>
<td>.</td>
<td>[^\n\r\u2028\u2029]，通配符，表示几乎任意字符，换行、回车、行分隔、段分隔符除外。</td>
</tr>
<tr>
<td>\1</td>
<td>反向引用，代表第一个用括号区分的分组，括号嵌套的号由开括号（来判断</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>量词</th>
<th>用于横向匹配，匹配多个字符，默认为贪婪匹配，可后加?变为惰性匹配</th>
</tr>
</thead>
<tbody><tr>
<td>{m,}</td>
<td>表示至少出现m次</td>
</tr>
<tr>
<td>？</td>
<td>等价于{0，1}，表示出现或不出现</td>
</tr>
<tr>
<td>+</td>
<td>等价于{1，}，表示出现至少一次</td>
</tr>
<tr>
<td>*</td>
<td>等价于{0，}，表示出现任意次或者不出现</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>位置特性</th>
<th>用于位置方式的匹配</th>
</tr>
</thead>
<tbody><tr>
<td>^、$</td>
<td>脱字符、美元符号分别在多行匹配中，匹配行开头与行结尾</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界，具体就是\w与\W之间的位置，也包括\w与^、$之间的</td>
</tr>
<tr>
<td>\B</td>
<td>同样，是\b的反面的意思</td>
</tr>
<tr>
<td>(?=p)</td>
<td>p为一个子模式，即匹配p前面的位置</td>
</tr>
<tr>
<td>(?!p)</td>
<td>其实就是(?=p)取反，除了p前面的位置以外的所有位置</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值与参数</th>
</tr>
</thead>
<tbody><tr>
<td>test</td>
<td>一个在字符串中测试是否匹配的RegExp方法，它返回true或false。regex.test(string)</td>
</tr>
<tr>
<td>exec</td>
<td>一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）regex.exec(string)</td>
</tr>
<tr>
<td>match</td>
<td>一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。string.match(regex)；match返回的是一个数组，包括各个括号匹配的内容</td>
</tr>
<tr>
<td>search</td>
<td>一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>
</tr>
<tr>
<td>replace</td>
<td>个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。string.replace(regex, “ ”)</td>
</tr>
<tr>
<td>split</td>
<td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。</td>
</tr>
</tbody></table>
<h1 id="简单正则匹配"><a href="#简单正则匹配" class="headerlink" title="简单正则匹配"></a>简单正则匹配</h1><h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><h3 id="16进制颜色值"><a href="#16进制颜色值" class="headerlink" title="16进制颜色值"></a>16进制颜色值</h3><p>要求匹配：#12f3a1，#ffBabd，#FFF；等颜色值字母不区分大小写，且可为3位或者六位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;#12f3a1 #ffBabd #FFF #123 #586&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br></pre></td></tr></table></figure>

<p>相当简单的正则，主要就是把基础知识运用下，只有两个分支匹配且逻辑清楚。</p>
<h3 id="24小时时间"><a href="#24小时时间" class="headerlink" title="24小时时间"></a>24小时时间</h3><p>要求匹配：23：59，04：09，8：9，19：47；这样的时间，前面的0可以省略也可带着</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/^(0?[0-9]|1[0-9]|2[0-3]):(0?[0-9]|[1-5][0-9])$/</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;23:59&quot;</span>, <span class="string">&quot;04:09&quot;</span>, <span class="string">&quot;8,9&quot;</span>, <span class="string">&quot;19:47&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (regex.test(arr[i])) &#123;</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是比较简单的正则，记得用括号将各段隔开，不然运算顺序可能不与你想的一致。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>要求匹配：192.168.225.255，156.234.156.215，1.2.3.4;类似的IP地址</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/^(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.\1\.\1\.\1$/</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;192.168.225.255&quot;</span>, <span class="string">&quot;156.234.156.215&quot;</span>, <span class="string">&quot;1.2.3.4&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (regex.test(arr[i])) &#123;</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的.字符需要转义，且利用括号分组来复用前面的正则。\1代表第一个括号引用的分组，根据第一个开括号(来确认。</p>
<h3 id="带格式日期"><a href="#带格式日期" class="headerlink" title="带格式日期"></a>带格式日期</h3><p>要求匹配：2020-09-12，2043-12-30，2018/08/09，2016.06.21；分隔符有三种可用，且要求分隔符前后使用一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;2020-09-12&quot;</span>，<span class="string">&quot;2043-12-30&quot;</span>，<span class="string">&quot;2018/08/09&quot;</span>，<span class="string">&quot;2016.06.21&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (regex.test(arr[i])) &#123;</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求分隔符前后一致，因此我们就必须用上题提过的括号分组复用，才能够实现这样的功能。我这里没有对日期的期限进行要求，直接用的数字均可，有要求的话，根据之前IP例题的逻辑，也能够很容易写出，这里就不再赘述。</p>
<p>同样，分组复用可以实现简单的替换，例如：想把yyyy-mm-dd替换成mm/dd/yyyy，以下的代码可以实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;2020-09-12&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = string.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">2</span> + <span class="string">&quot;/&quot;</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span> + <span class="string">&quot;/&quot;</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//RegExp中的$1、$2、$3代表第1、2、3个分组</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><p>实例：将”aaaaabbbbbccccc”去重返回成为”abc”。利用括号分组的同样匹配，来实现查询出重复字符的效果，由于重复字符可以出现多次，因此后面还要加上+,表示至少出现一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line"><span class="comment">//g代表全局匹配，会在一次匹配结束后继续匹配多次。而非仅匹配一次</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aaaaabbbbbddddggggggggffff&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = str.replace(regex, <span class="string">&quot;$1&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><p>要求匹配HTML标签a内容，比如”<a herf="www.baidu.com">“”<a>“，即匹配出两个&lt;&gt;之间，且第一个字符为a</a></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/&lt;a[^&gt;]+&gt;/g</span></span><br></pre></td></tr></table></figure>

<p>这里的^脱字符代表取反，即除了”&gt;”以外均匹配。</p>
<h3 id="驼峰字符串"><a href="#驼峰字符串" class="headerlink" title="驼峰字符串"></a>驼峰字符串</h3><p>要求将一个连续字符串如：get-element-by-id转化成驼峰形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toHump</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/-(\w)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span></span>))</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>将-后面是字符的-与首字符的位置均匹配到，然后将$1，即-后的字符变成大写后replace进去</p>
<h3 id="邮箱格式"><a href="#邮箱格式" class="headerlink" title="邮箱格式"></a>邮箱格式</h3><p>1.不限制长度</p>
<p>2.不限制大小写</p>
<p>3.邮箱开头必须是数字或字符串</p>
<p>4.邮箱中可以使用字母、数字、点号、下划线、减号，但是不能连写点号、下划线、减号，如 <a href="mailto:&#x61;&#98;&#x63;&#95;&#x2d;&#100;&#x65;&#64;&#x71;&#x5f;&#46;&#113;&#x2e;&#99;&#111;&#x6d;">&#x61;&#98;&#x63;&#95;&#x2d;&#100;&#x65;&#64;&#x71;&#x5f;&#46;&#113;&#x2e;&#99;&#111;&#x6d;</a></p>
<p>5.@符号前后不能为点号、下划线、减号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAvailableEmail</span>(<span class="params">sEmail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/^([\w+\._-])+@\w+[\.\w]+$/</span>;</span><br><span class="line">    <span class="keyword">return</span> reg.test(sEmail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="识别十进制整数"><a href="#识别十进制整数" class="headerlink" title="识别十进制整数"></a>识别十进制整数</h3><p>修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例。</p>
<p>eg：’12px’、’0x12’</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse2Int</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regex=<span class="regexp">/^\d+/</span>;</span><br><span class="line">    num=regex.exec(num)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//或者可以直接使用parseInt(num, 10)；这个API会自动识别非十进制的数，将其排除在外</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse2Int</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="颜色字符串转换"><a href="#颜色字符串转换" class="headerlink" title="颜色字符串转换"></a>颜色字符串转换</h3><p>考的知识点两个：</p>
<ol>
<li><p>正则表达式匹配；</p>
</li>
<li><p>toString(16)转换进制；toString()可用于转换进制、判断引用类型。</p>
</li>
</ol>
<p>做的过程中注意：</p>
<ol>
<li>数值超界（0-255）</li>
<li>不足两位补零</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2hex</span>(<span class="params">sRGB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/rgb\((\d+),\s*(\d+),\s*(\d+)\)/</span>;</span><br><span class="line">    <span class="keyword">let</span> res = sRGB.match(reg);<span class="comment">//match返回一个数组或者在未匹配到时返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        <span class="keyword">return</span> sRGB;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(res[i]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">255</span> &amp;&amp; num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                str += (num &lt; <span class="number">16</span> ? <span class="string">&#x27;0&#x27;</span> + num.toString(<span class="number">16</span>) : num.toString(<span class="number">16</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> sRGB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变为驼峰"><a href="#变为驼峰" class="headerlink" title="变为驼峰"></a>变为驼峰</h3><p>replace() 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。</p>
<p>这个用法的本质就是：对str使用RegArg做match()匹配，如果匹配到多项结果（比如使用了全局匹配g，或者分组），那么每一个匹配结果都将执行一次FuncArg函数，并且用该函数的返回值替代源字符串中的匹配项。</p>
<p>第一个参数可以是字符串或正则表达式，如果提供的是字符串，只会替换第一个子字符串。如果想替换所有子字符串，需要提供一个指定了 g 的正则表达式。</p>
<p>第二个参数可以是字符串或函数。如果是字符串，可以使用一些特殊的 <strong>字符序列</strong>：</p>
<p>如果第二个参数也可以是函数，这个函数接收多个参数：function (match[，p1, p2, …, pn], offset, string)</p>
<ul>
<li>match：匹配的子串，等同于前面提到的 $&amp;</li>
<li>p1-p2：为捕获组对应的匹配字符串（如果设置了捕获组）。</li>
<li>offset：模式匹配项位于输入字符串的位置</li>
<li>string：输入的原始字符串。</li>
<li>函数的返回值：返回值即为替换的文本。</li>
</ul>
<p>css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能</p>
<p>1、以 - 为分隔符，将第二个起的非空单词首字母转为大写</p>
<p>2、-webkit-border-image 转换后的结果为 webkitBorderImage</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cssStyle2DomStyle</span>(<span class="params">sName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line">    <span class="keyword">let</span> res = sName.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">fullMatch, g1, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span> g1;</span><br><span class="line">        <span class="comment">//当模式串匹配的为单词的首项时，证明-在最前面，此时返回小写字母，将-a替换成a。</span></span><br><span class="line">        <span class="keyword">return</span> g1.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取url中参数"><a href="#获取url中参数" class="headerlink" title="获取url中参数"></a>获取url中参数</h3><ol>
<li><p>指定参数名称，返回该参数的值 或者 空字符串</p>
</li>
<li><p>不指定参数名称，返回全部的参数对象 或者 {}</p>
</li>
<li><p>如果存在多个同名参数，则返回数组</p>
</li>
</ol>
<p>例:输入：<a target="_blank" rel="noopener" href="http://www.nowcoder.com/?key=1&amp;key=2&amp;key=3&amp;test=4#hehe">http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe</a> key；输出：[1, 2, 3]</p>
<p>方法一：使用字符串拼接来匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  获取URl中的参数</span></span><br><span class="line"><span class="comment">* @para url </span></span><br><span class="line"><span class="comment">* @para key 参数名*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">sUrl, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> left= sUrl.indexOf(<span class="string">&quot;?&quot;</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> right= sUrl.lastIndexOf(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> parasString = sUrl.slice(left, right)</span><br><span class="line">    <span class="keyword">var</span> paras = parasString.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> parasjson = &#123;&#125;</span><br><span class="line">    paras.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = value.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        parasjson[a[<span class="number">0</span>]] !== <span class="literal">undefined</span> ? parasjson[a[<span class="number">0</span>]] = [].concat(parasjson[a[<span class="number">0</span>]], a[<span class="number">1</span>]) : parasjson[a[<span class="number">0</span>]] = a[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">arguments</span>[<span class="number">1</span>] !== <span class="keyword">void</span> <span class="number">0</span> ? (parasjson[<span class="built_in">arguments</span>[<span class="number">1</span>]] || <span class="string">&#x27;&#x27;</span>) : parasjson;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用正则中的replace进行替换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam2</span>(<span class="params">sUrl, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result, Oparam = &#123;&#125;;</span><br><span class="line">    sUrl.replace(<span class="regexp">/[\?&amp;]?(\w+)=(\w+)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$<span class="number">0</span>, $<span class="number">1</span>, $<span class="number">2</span></span>) </span></span><br><span class="line"><span class="function">        <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="string">&#x27;$0:&#x27;</span> + $<span class="number">0</span> + <span class="string">&quot;     $1:&quot;</span> + $<span class="number">1</span> + <span class="string">&quot;     $2:&quot;</span> + $<span class="number">2</span></span>);</span></span><br><span class="line">        Oparam[$1] === void 0 ? Oparam[$1] = $2 : Oparam[$1] = [].concat(Oparam[$1], $2);</span><br><span class="line">    &#125;);</span><br><span class="line">    sKey === <span class="keyword">void</span> <span class="number">0</span> || sKey === <span class="string">&#x27;&#x27;</span> ? result = Oparam : result = Oparam[sKey] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：使用正则中的exec方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam3</span>(<span class="params">sUrl, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/g</span>;</span><br><span class="line">    <span class="keyword">while</span> (reg.exec(sUrl)) &#123;</span><br><span class="line">        resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>] ? resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>] = [].concat(resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>], <span class="built_in">RegExp</span>.$<span class="number">2</span>) : resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>] = <span class="built_in">RegExp</span>.$<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> (resObj[sKey] ? resObj[sKey] : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>函数parseUrl实现将一段url字段解析为Object，例如url为：”<a target="_blank" rel="noopener" href="http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title&quot;;parseUrl(url)%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BAobject%E5%A6%82%E4%B8%8B%EF%BC%9A">http://www.xiyanghui.com/product/list?id=123456&amp;sort=discount#title&quot;;parseUrl(url)返回的结果为object如下：</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    protocol:<span class="string">&quot;http&quot;</span>,</span><br><span class="line">    host:<span class="string">&quot;www.xiyanghui.com&quot;</span>,</span><br><span class="line">    path:<span class="string">&quot;product/list&quot;</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">        id:<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">        sort:<span class="string">&quot;discount&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    hash:<span class="string">&quot;title&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseUrl</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否传入参数</span></span><br><span class="line">    <span class="keyword">if</span> (str) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">        <span class="keyword">var</span> queryArr = [];</span><br><span class="line">        <span class="comment">// 正则表达式规则</span></span><br><span class="line">        <span class="keyword">var</span> re = <span class="regexp">/^(http[s]?):\/\/([0-9a-zA-Z\.]+)\/([a-zA-Z0-9\/]+)\?([a-zA-Z0-9\=\&amp;]+)#([0-9a-zA-Z\.]+)$/</span>;</span><br><span class="line">        <span class="comment">// 利用正则表达式将字符串分组</span></span><br><span class="line">        <span class="keyword">var</span> reArr = re.exec(str);</span><br><span class="line">        <span class="keyword">if</span> (reArr) &#123;</span><br><span class="line">            obj.peotocol = reArr[<span class="number">1</span>];</span><br><span class="line">            obj.host = reArr[<span class="number">2</span>];</span><br><span class="line">            obj.path = reArr[<span class="number">3</span>];</span><br><span class="line">            queryArr = reArr[<span class="number">4</span>].split(<span class="regexp">/[\&amp;\=]+/</span>);</span><br><span class="line">            obj.query = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; queryArr.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">                obj.query[queryArr[i]] = queryArr[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            obj.hash = reArr[<span class="number">5</span>]</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="千位分隔符"><a href="#千位分隔符" class="headerlink" title="千位分隔符"></a>千位分隔符</h3><p>千位分隔符的关键在于两点：1、使用量词+多次匹配d{3}；2、要求匹配的位置不能是开头，因此用(?!^)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>;<span class="comment">//先要求匹配的位置不能是开头,$代表从单词末尾开始匹配，/g代表</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = string.replace(regex, <span class="string">&#x27;,&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果还要求支持”12345783   23498237489  3219482”这样多个数字间用空格来区分的输入的话，只需要将^、$进行修改，改成\b，从而匹配多个连续字符的开头、结尾，而不是匹配整个字符串的开头、结尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(?!\b)(?=(\d&#123;3&#125;)+\b)/g</span>;</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;12345783   23498237489  3219482&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = string.replace(regex, <span class="string">&#x27;,&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="密码判断"><a href="#密码判断" class="headerlink" title="密码判断"></a>密码判断</h3><p>多种条件的密码判断往往写成多个小的正则进行判断，下面基本使用三个小的条件进行密码判断。总的要求是：密码长度6-12位，由数字、小写字符、大写字符组成，但必须至少包括2种字符，且必须包含数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、要求密码长度6-12位</span></span><br><span class="line"><span class="keyword">let</span> regex1 = <span class="regexp">/^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</span><br><span class="line"><span class="comment">//2、要求必须包含数字</span></span><br><span class="line"><span class="keyword">let</span> regex2 = <span class="regexp">/?=.*[0-9]/</span>;<span class="comment">//即任意数量任意字符的后面前一个位置，后面会接一个数字=&gt;包含一个数字</span></span><br><span class="line"><span class="comment">//3、要求同时包含两种</span></span><br><span class="line"><span class="keyword">let</span> regex3 = <span class="regexp">/(?=.*[0-9])(?=.*[a-z])/</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;192.168.225.255&quot;</span>, <span class="string">&quot;156.234.156.215&quot;</span>, <span class="string">&quot;1.2.3.4&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (regex1.test(arr[i]) &amp;&amp; regex2.test(arr[i]) &amp;&amp; regex3.test(arr[i])) &#123;</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="替代正则"><a href="#替代正则" class="headerlink" title="替代正则"></a>替代正则</h1><p>并不是所有的问题均适合使用正则解决：1、有些看似简单的问题，但正则做不到；2、有些能用字符串简单API就能解决的问题，使用正则会提高时间负杂度。</p>
<h2 id="提取年月日"><a href="#提取年月日" class="headerlink" title="提取年月日"></a>提取年月日</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;2020-09-01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">//输出为[&quot;2020-09-01&quot;, &quot;2020&quot;, &quot;09&quot;, &quot;01&quot;, index: 0, input: &quot;2020-09-01&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实，用字符串的split方法来做即可：</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;2020-09-01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> res = string.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//输出为[&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;]</span></span><br><span class="line"><span class="comment">/*split()方法用于把一个字符串分割成字符串数组。</span></span><br><span class="line"><span class="comment">separator    必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。</span></span><br><span class="line"><span class="comment">howmany    可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。*/</span></span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>需要实现的功能是类似百度搜索框的模糊查询，这里先只考虑JS代码，构建的函数传入参数有2个，分别是list存储所有关键词信息的数组、keyword模糊查询的关键词、res查询得出的结果。</p>
<h3 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h3><p>stringObject.indexOf(searchValue)该方法从头到尾检索字符串stringObject，看它是否含有子串searchValue，开始检索得位置在字符串的开头，找到searchValue时，则返回其第一次出现的位置，没有找到则返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuzzyQuery</span> (<span class="params">list, keyWord</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i].indexOf(keyWord) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            res.push(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h3><p>stringObject.split(separator)。该方法通过在separator指定的边界处将字符串stringObject分割成子串并返回子串数组。返回的数组中的字串不包括separator自身。如果stringObject中不存在separator，将返回一个只包含stringObject的数组。故可以根据返回数组的长度来判断是否存在子字符串separator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuzzyQuery</span>(<span class="params">list, keyWord</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i].split(keyWord).length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.push(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>该方法在字符串内检索指定的值，或找到一个或多个正则表达式的匹配；如果没有找到任何匹配的文本，将返回null。否则，将返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuzzyQuery</span>(<span class="params">list, keyWord</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i].match(keyWord) != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.push(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="test方法"><a href="#test方法" class="headerlink" title="test方法"></a>test方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuzzyQuery</span>(<span class="params">list, keyWord</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyWord);</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reg.test(list[i])) &#123;</span><br><span class="line">            res.push(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搜索框模糊查询实现"><a href="#搜索框模糊查询实现" class="headerlink" title="搜索框模糊查询实现"></a>搜索框模糊查询实现</h2><h3 id="简单html实现"><a href="#简单html实现" class="headerlink" title="简单html实现"></a>简单html实现</h3><p>主要关注html实现，就不用上述定义的函数了，而是用更简单的方式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//onload事件，页面在加载完成时马上执行的一组代码</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> keyWords = &#123; </span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;a&quot;</span>: [<span class="string">&quot;abada&quot;</span>, <span class="string">&quot;asdkasdfda&quot;</span>, <span class="string">&quot;askfdlf&quot;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;b&quot;</span>: [<span class="string">&quot;bfsdifdpa&quot;</span>, <span class="string">&quot;杨振宇&quot;</span>, <span class="string">&quot;杨过&quot;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;c&quot;</span>: [<span class="string">&quot;cdfdfgd&quot;</span>, <span class="string">&quot;cgfhjf&quot;</span>, <span class="string">&quot;cuyjk&quot;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;d&quot;</span>:[<span class="string">&quot;dfdgd&quot;</span>,<span class="string">&quot;dyjhfh&quot;</span>,<span class="string">&quot;dhyjgh&quot;</span>]</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (keyWords[<span class="built_in">this</span>.value]) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//判断body中是否有这个层,如果有就删掉了</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">&#x27;dv&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;dv&#x27;</span>));</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//开始创建层</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dvObj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            dvObj.id = <span class="string">&#x27;dv&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            dvObj.style.width = <span class="string">&#x27;300px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//dvObj.style.height = &#x27;200px&#x27;; //将来可以不要</span></span></span><br><span class="line"><span class="javascript">            dvObj.style.border = <span class="string">&#x27;1px solid red&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(dvObj);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//脱离文档流</span></span></span><br><span class="line"><span class="javascript">            dvObj.style.position = <span class="string">&#x27;absolute&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            dvObj.style.left = <span class="built_in">this</span>.offsetLeft + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            dvObj.style.top = <span class="built_in">this</span>.offsetHeight + <span class="built_in">this</span>.offsetTop + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//循环创建</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keyWords[<span class="built_in">this</span>.value].length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//创建一个可以存文本的标签</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> pObj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                pObj.innerText = keyWords[<span class="built_in">this</span>.value][i];</span></span><br><span class="line"><span class="javascript">                <span class="comment">//p标签要有小手，还有高亮显示</span></span></span><br><span class="line"><span class="javascript">                pObj.style.cursor = <span class="string">&#x27;pointer&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                pObj.style.margin = <span class="string">&#x27;5px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                pObj.onmouseover = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                pObj.onmouseout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                dvObj.appendChild(pObj); <span class="comment">//操作节点，把p标签加到层中</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//同样可以用insertBefore()来添加</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//创建可以显示文件的标签</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">//firefox下检测状态改变只能用oninput,且需要用addEventListener来注册事件。 </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="regexp">/msie/i</span>.test(navigator.userAgent)) <span class="comment">//ie浏览器 </span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).onpropertychange = handle</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> &#123;<span class="comment">//非ie浏览器，比如Firefox </span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).addEventListener(<span class="string">&quot;input&quot;</span>, handle, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//绑定事件对象.addEventListener(事件类型，回调函数，bool值)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果不传入bool值，或者为false；事件就会走冒泡阶段；反之，事件会走捕获阶段。</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">请输入搜索关键字</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:300px;height:30px;font-size:25px; border:1px solid green&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>/&gt;</span>百度一下</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="利用JSONP调用百度接口"><a href="#利用JSONP调用百度接口" class="headerlink" title="利用JSONP调用百度接口"></a>利用JSONP调用百度接口</h3><p>JSONP(JSONwith Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。 该代码实现搬运自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zfz5720/article/details/78044439">CSDN</a></p>
<p>实现原理：向输入框动态输入时关键词，将当前关键词作为问号参数后面的值，因为要跨域使用百度的接口，所以通过 JSONP 跨域创建 Ajax 请求。回调函数处理返回值。</p>
<p>1.使用 flex 布局实现搜索框的水平垂直居中。</p>
<p>2.先获取常用的 DOM 节点，避免后续频繁查询操作 DOM。</p>
<p>3.为了避免在输入过程中频繁发送请求(如果打字速度快),对请求函数做了函数节流，调了一下间隔 130ms 差不多正好，时间再长就会有卡顿的感觉。使用了 ES6 中的箭头函数避免了setTimeout 中 this 指向的问题。</p>
<p>4.在回调函数中：</p>
<ul>
<li>每一次执行时首先要清除建议框里的内容，不然上一次的结果还会存在建议框里！截取了结果中的前五个(如果把所有结果都展示出来感觉有点丑…百度官方是展示前四个搜索建议)</li>
<li>结果处理完毕后，执行自执行匿名函数，删除创建的 script 标签;</li>
</ul>
<p>5.由于 li 是动态创建的，点击 li 标签或者点击”搜索一下”跳转百度进行搜索时，利用事件冒泡原理，进行事件委托。这里没有考虑兼容性问题：</p>
<p>6.除了点击事件，键盘事件–回车键以及上下键都是进行事件委托进行注册的。最终能够实现键盘上下键鼠标选择，点击“搜索一下”或回车键实现跳转搜索。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 兼容性视图 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;更方便快捷搜索，从而达到事半功倍的效果&quot;</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>search you want<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html &#123;</span><br><span class="line">      height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#f0f3ef</span>;</span></span><br><span class="line">      height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      height: 100%;</span><br><span class="line">      display: flex;</span><br><span class="line">      justify-content: center;</span><br><span class="line">      align-items: center;</span><br><span class="line">      flex-direction: column;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.bgDiv</span> &#123;</span></span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">      width: 595px;</span><br><span class="line">      height: 55px;</span><br><span class="line">      position: relative;</span><br><span class="line">    /* position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%); */</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.search-input-text</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#b6b6b6</span>;</span></span><br><span class="line">      width: 495px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">      height: 33px;</span><br><span class="line">      line-height: 33px;</span><br><span class="line">      font-size: 18px;</span><br><span class="line">      padding: 3px 0 0 7px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.search-input-button</span> &#123;</span></span><br><span class="line">      width: 90px;</span><br><span class="line">      height: 38px;</span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">      font-size: 16px;</span><br><span class="line">      letter-spacing: 3px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#3385ff</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: <span class="selector-class">.5px</span> <span class="selector-tag">solid</span> <span class="selector-id">#2d78f4</span>;</span></span><br><span class="line">      margin-left: -5px;</span><br><span class="line">      vertical-align: top;</span><br><span class="line"><span class="css">      <span class="selector-tag">opacity</span>: <span class="selector-class">.9</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.search-input-button</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">      opacity: 1;</span><br><span class="line"><span class="css">      <span class="selector-tag">box-shadow</span>: 0 1<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#333</span>;</span></span><br><span class="line">      cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.suggest</span> &#123;</span></span><br><span class="line">      width: 502px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 38px;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#999</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.suggest</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">      list-style: none;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.suggest</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">      padding: 3px;</span><br><span class="line">      font-size: 17px;</span><br><span class="line">      line-height: 25px;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.suggest</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">background-color</span>: <span class="selector-id">#e5e5e5</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bgDiv&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;search-input-text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">autofocus</span> <span class="attr">placeholder</span>=<span class="string">&quot;关键词&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;搜索一下&quot;</span> <span class="attr">class</span>=<span class="string">&quot;search-input-button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;suggest&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;search-result&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> suggestContainer = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;suggest&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> searchInput = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;search-input-text&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bgDiv = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;bgDiv&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> searchResult = <span class="built_in">document</span>.getElementById(<span class="string">&quot;search-result&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 清除建议框内容</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">clearContent</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> size = searchResult.childNodes.length;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//childNodes方法返回数组，根据数组长度判断建议框的长度</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line">        searchResult.removeChild(searchResult.childNodes[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="comment">// 回调函数处理返回值</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">handleSuggestion</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 清空之前的数据！！</span></span></span><br><span class="line">      clearContent();</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result = res.s;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 截取前五个搜索建议项</span></span></span><br><span class="line">      if (result.length &gt; 4) &#123;</span><br><span class="line">        result = result.slice(0, 5)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 动态创建li标签</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> liObj = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line">        liObj.innerHTML = result[i];</span><br><span class="line">        searchResult.appendChild(liObj);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 自执行匿名函数--删除用于跨域的script标签</span></span></span><br><span class="line"><span class="javascript">      (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> s = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = s.length; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.body.removeChild(s[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jumpPage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.open(<span class="string">`https://www.baidu.com/s?word=<span class="subst">$&#123;<span class="built_in">encodeURI</span>(searchInput.value)&#125;</span>`</span>);</span></span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 注册输入框键盘抬起事件</span></span></span><br><span class="line"><span class="javascript">    searchInput.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      suggestContainer.style.display = <span class="string">&quot;block&quot;</span>;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果输入框内容为空 清除内容且无需跨域请求</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">this</span>.value.length === <span class="number">0</span>) &#123;</span></span><br><span class="line">        clearContent();</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">this</span>.timer) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span></span><br><span class="line">      &#125;</span><br><span class="line">      if (e.keyCode !== 40 &amp;&amp; e.keyCode !== 38) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 函数节流优化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 创建script标签JSONP跨域</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span></span><br><span class="line"><span class="javascript">          script.src = <span class="string">&quot;https://www.baidu.com/su?&amp;wd=&quot;</span> + <span class="built_in">encodeURI</span>(<span class="built_in">this</span>.value.trim()) +</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;&amp;p=3&amp;cb=handleSuggestion&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line">        &#125;, 130)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="comment">// 事件委托 点击li标签或者点击搜索按钮跳转到百度搜索页面</span></span></span><br><span class="line"><span class="javascript">    bgDiv.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (e.target.nodeName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> keywords = e.target.innerText;</span></span><br><span class="line">        searchInput.value = keywords;</span><br><span class="line">        jumpPage();</span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.target.id === <span class="string">&#x27;btn&#x27;</span>) &#123;</span></span><br><span class="line">        jumpPage();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> flag = <span class="number">1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 事件委托 监听键盘事件</span></span></span><br><span class="line"><span class="javascript">    bgDiv.addEventListener(<span class="string">&quot;keydown&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> size = searchResult.childNodes.length;</span></span><br><span class="line">      if (e.keyCode === 13) &#123;</span><br><span class="line">        jumpPage();</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      <span class="comment">// 键盘向下事件</span></span></span><br><span class="line">      if (e.keyCode === 40) &#123;</span><br><span class="line">        if (flag === 0) &#123;</span><br><span class="line">          i = i + 2;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = 1;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">          i = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; size) &#123;</span><br><span class="line">          searchInput.value = searchResult.childNodes[i++].innerText;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      <span class="comment">// 键盘向上事件</span></span></span><br><span class="line">      if (e.keyCode === 38) &#123;</span><br><span class="line">        if (flag === 1) &#123;</span><br><span class="line">          i = i - 2;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = 0;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        if (i &lt; 0) &#123;</span><br><span class="line">          i = size - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt; -1) &#123;</span><br><span class="line">          searchInput.value = searchResult.childNodes[i--].innerText;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击页面任何其他地方 搜索结果框消失</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.onclick = <span class="function">() =&gt;</span> clearContent()</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/09/%E5%89%8D%E7%AB%AF/DOM%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/09/%E5%89%8D%E7%AB%AF/DOM%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">DOM问题汇总</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2021-01-09 20:02:33" itemprop="dateCreated datePublished" datetime="2021-01-09T20:02:33+08:00">2021-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 22:51:37" itemprop="dateModified" datetime="2021-03-12T22:51:37+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>直接操作DOM已经很少在业务场景中用到了，但DOM始终作为前端的基础之一，在面试中往往总能够遇到。本文希望能够汇总以下简单的DOM知识点，让自己在沉迷框架构建时，不至于忽略或者忘记最基础的知识。主要分为两部分：1、常用的DOM方法的汇总；2、DOM的事件机制，主要是事件冒泡与事件捕获。</p>
<h1 id="DOM方法"><a href="#DOM方法" class="headerlink" title="DOM方法"></a>DOM方法</h1><h2 id="选取元素"><a href="#选取元素" class="headerlink" title="选取元素"></a>选取元素</h2><h3 id="名称选择"><a href="#名称选择" class="headerlink" title="名称选择"></a>名称选择</h3><p>名称选择比较简单，主要是根据ID、name属性、标签名称、类名；来选择对应的DOM节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ID选择器：基于id=&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> id =  <span class="built_in">document</span>.getElementById(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//名称选择器:基于name属性</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//标签选择器：利用HTML元素的标签名称选取指定类型的元素</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;h1&quot;</span>);</span><br><span class="line"><span class="comment">//类选择器：利用HTML的class属性值选择元素</span></span><br><span class="line"><span class="keyword">let</span> title = <span class="built_in">document</span>.getElementsByClassName(title);</span><br></pre></td></tr></table></figure>

<h3 id="CSS选择"><a href="#CSS选择" class="headerlink" title="CSS选择"></a>CSS选择</h3><p>通过CSS样式表选择器的强大语法，也可以来选择元素，返回第一个匹配的元素，或者返回元素数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#title&quot;</span>);   <span class="comment">// CSS ID选择</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="built_in">document</span>.querySelector(<span class="string">&quot;h1&quot;</span>);     <span class="comment">//选取第一个h1元素</span></span><br><span class="line"><span class="keyword">var</span> h1s = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;h1&quot;</span>);   <span class="comment">//返回所有h1标签元素</span></span><br></pre></td></tr></table></figure>

<h2 id="相近节点选取"><a href="#相近节点选取" class="headerlink" title="相近节点选取"></a>相近节点选取</h2><p>节点：页面中所有的内容都是节点（标签，属性，文本：文字，空格，换行）文档：document—-页面中的顶级对象元素：页面中所有的标签，标签–元素–对象（通过DOM的方式来获取这个标签，得到了这个对象，此时这个对象叫DOM对象）。</p>
<p>关于节点的选取有如下的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">h1.parentNode;<span class="comment">//父节点</span></span><br><span class="line">h1.childNodes;<span class="comment">//以数组形式返回子节点</span></span><br><span class="line">h1.firstChild; h1.lastChild;</span><br><span class="line">h1.nextSibling;<span class="comment">//下一个兄弟节点</span></span><br><span class="line">h1.previousSibling;<span class="comment">//前一个兄弟节点</span></span><br><span class="line">h1.nodeType;</span><br><span class="line"><span class="comment">//返回节点类型的数字表示：1-element节点；3-text节点；8-comment节点；9-document节点；11-documentFragment节点</span></span><br><span class="line">h1.nodeValue;<span class="comment">//返回Text 节点 或 Comment 节点的值</span></span><br><span class="line">h1.nodeName;<span class="comment">//返回元素的标签名，以大写形式表示</span></span><br></pre></td></tr></table></figure>

<p>元素相关的选取同样有如下的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h2.children;<span class="comment">//以数组的形式返回所有的子元素</span></span><br><span class="line">h2.firstElementChild; h2.lastElementChild;<span class="comment">//返回首子元素与尾子元素</span></span><br><span class="line">h2.nextElementSibling; h2.previousElementSibling;<span class="comment">//返回上一兄弟元素与下一兄弟元素</span></span><br><span class="line">h2.childElementCount;<span class="comment">//返回子元素数量</span></span><br></pre></td></tr></table></figure>

<h2 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h2><p>表示HTML文档元素的HTMLElement对象定义了读/写属性，它们对应于元素的HTML属性。 HTMLElement定义的通用HTML属性，包括id、lang、dir、事件处理程序onclick及表单相关属性等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">h3.getAttribute(<span class="string">&quot;width&quot;</span>);<span class="comment">//返回非标准的HTML属性的值</span></span><br><span class="line">h3.setAttribute(<span class="string">&quot;width&quot;</span>, <span class="string">&quot;150px&quot;</span>);<span class="comment">//设置非标准的HTML属性的值</span></span><br><span class="line">h3.hasAttribute(<span class="string">&quot;height&quot;</span>);<span class="comment">//判断属性是否存在</span></span><br><span class="line">h3.removeAttribute(<span class="string">&quot;width&quot;</span>);<span class="comment">//删除某一属性</span></span><br><span class="line"><span class="comment">//在HTML5文档中，任意以 data- 为前缀的小写的属性名字都是合法的。这些 “数据集属性” 定义了一种标准的、附加额外数据的方法</span></span><br><span class="line"><span class="comment">//以data-x = &quot;&quot;为例</span></span><br><span class="line">h3.dataset.x;</span><br><span class="line"><span class="comment">//Node节点定义了 attributes 属性，针对 Element 对象，attributes 是元素所有属性的类数组对象</span></span><br><span class="line"><span class="comment">//索引 attributes 对象得到的值是 Attr 对象。Attr 的 name 和 value 返回该属性的名字和值</span></span><br><span class="line"><span class="keyword">let</span> a = h3.attributes.src.value;</span><br><span class="line"></span><br><span class="line">h4.innerHTML;<span class="comment">//以字符串形式返回这个元素的内容。 也可以用来替换元素当前内容</span></span><br><span class="line">h4.outerHTML;<span class="comment">//以字符串形式返回这个元素及内容。 也可以用来替换元素当前内容</span></span><br><span class="line">h4.textContent;<span class="comment">//查询或替换纯文本元素内容的标准方法是用Node的textContent属性来实现。</span></span><br></pre></td></tr></table></figure>

<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&quot;h1&quot;</span>);<span class="comment">//使用document 对象的createElement () 方法创建新的Element节点</span></span><br><span class="line"><span class="built_in">document</span>.createTextNode(<span class="string">&quot;文本节点&quot;</span>);<span class="comment">//创建纯文本节点</span></span><br><span class="line"><span class="built_in">document</span>.createDocumentFragment();<span class="comment">//创建文档片段，往往有更好性能</span></span><br><span class="line"><span class="comment">//因为文档片段存在于内存中，并不在Dom树中，所以将子元素插入到文档片段时不会引起页面回流 （对元素位置和几何上计算）</span></span><br><span class="line"><span class="built_in">document</span>.createCmoment(<span class="string">&quot;....&quot;</span>);<span class="comment">//创建注释节点</span></span><br><span class="line">h4.cloneNode(<span class="literal">true</span>);<span class="comment">//通过复制已存在的节点来创建新的文档节点。传参数true表示深克隆，false表示浅复制</span></span><br></pre></td></tr></table></figure>

<h2 id="插入、修改节点"><a href="#插入、修改节点" class="headerlink" title="插入、修改节点"></a>插入、修改节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h5.appendChild(<span class="string">&quot;h1&quot;</span>);<span class="comment">//在指定元素上插入子节点，并使其成为该节点的最后一个子节点</span></span><br><span class="line"><span class="comment">//一般先新建子节点，再插入子节点</span></span><br><span class="line">h5.insertBefore(<span class="string">&quot;h1&quot;</span>, <span class="string">&quot;h2&quot;</span>);</span><br><span class="line"><span class="comment">//1. 在父节点上调用本方法2. 第一参数表示待插入的节点</span></span><br><span class="line"><span class="comment">//3. 第二参数是父节点中已经存在的子节点，新节点插入到该节点的前面</span></span><br><span class="line">h5.removeChild(<span class="string">&quot;h2&quot;</span>);<span class="comment">//在父节点中调用，参数是待删除的节点</span></span><br><span class="line">h5.replaceChild(<span class="string">&quot;h2,&quot;</span>, <span class="string">&quot;h2&quot;</span>);</span><br><span class="line"><span class="comment">//1. 在父节点上调用;2. 第一参数是新节点;3. 第二个参数是需要替换的节点</span></span><br></pre></td></tr></table></figure>

<h1 id="DOM事件机制"><a href="#DOM事件机制" class="headerlink" title="DOM事件机制"></a>DOM事件机制</h1><p>1、事件是在编程时系统内发生的动作或者发生的事情</p>
<p>2、事件是要绑定在元素上的。比如给一个div元素绑定一个鼠标悬浮事件，给一个ol元素绑定鼠标单击事件。</p>
<p>3、可以使用事件监听函数（也叫事件处理程序、侦听器）来监听事件，以便事件发生时执行相应的代码</p>
<p>事件发生时元素节点之间按照特定的顺序传播，这个过程即DOM事件流，描述的是从页面接收事件的顺序。</p>
<h2 id="冒泡与捕获"><a href="#冒泡与捕获" class="headerlink" title="冒泡与捕获"></a>冒泡与捕获</h2><p>首先开始事件捕获阶段：从DOM树最根部的节点<code>window</code>开始，沿着DOM树向下遍历每个元素，直到触发元素目标元素target。如果这些元素也注册了click事件（且为捕获阶段），就会执行他们相应的事件监听函数。即从上到下触发父元素对应的事件。在事件捕获这一阶段，为截获事件提供了机会。</p>
<p>当前目标阶段：实际的目标接收到，并执行对应得事件监听函数。</p>
<p>事件冒泡阶段：从触发元素目标元素target开始，向上逆着遍历DOM树，直到最根部<code>window</code>元素。如果这些元素也注册了click事件（且为冒泡阶段），就会执行他们相应的事件监听函数</p>
<p>我们在使用 addEventListener 监听事件时，addEventListener(‘click’, fn, bool)如果第三个参数 bool 不传，或者传 false, 那么我们会在冒泡阶段调用 fn如果第三个参数 Bool 传值为 true, 那么我们会在捕获阶段调用 fn。因此，默认是在冒泡阶段来监听事件的。</p>
<p>捕获不可以取消，但是冒泡可以取消，e.propagation()就可但是有一些事件不可以取消冒泡，比如 scroll 事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">e.target 用户正在操作的元素</span><br><span class="line">e.currentTarget 程序员在监听的元素</span><br><span class="line">假设我们监听的是 div, 但用户实际点击的是文字，那么e.target 就是 span 标签,e.currentTarget 就是 div 标签。</span><br></pre></td></tr></table></figure>

<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>冒泡阶段，浏览器从用户点击的内容从下往上遍历至 window，逐个触发事件处理函数，因此可以监听一个祖先节点(例如爸爸节点、爷爷节点)来同时处理多个子节点的事件。</p>
<p>主要的作用有：1、省掉监听数，节省内存；要监听多个兄弟元素时，不如只监听父元素，并在事件处理函数中，利用e.target来判断到底是哪一个子元素触发了事件，再进行对应的处理即可。</p>
<p>2、监听不存在的元素，即动态元素。</p>

      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/06/%E5%89%8D%E7%AB%AF/vue%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/%E5%89%8D%E7%AB%AF/vue%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">vue分析</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2020-12-06 21:28:16" itemprop="dateCreated datePublished" datetime="2020-12-06T21:28:16+08:00">2020-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 22:51:58" itemprop="dateModified" datetime="2021-03-12T22:51:58+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="源码思维"><a href="#源码思维" class="headerlink" title="源码思维"></a>源码思维</h1><h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p>代码在发生预期之外的错误时，其应对错误的能力：即就算出错也能够轻松定位到错误，且减少错误的影响范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、不要轻易去相信传入参数，需要判断参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b == <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、易错代码用try catch包裹起来</span></span><br><span class="line">a[<span class="number">0</span>] &amp;&amp; a[<span class="number">0</span>].data[<span class="number">0</span>];<span class="comment">//取属性之前，先判断其是否存在</span></span><br></pre></td></tr></table></figure>

<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p>主要用于vue的数据绑定，</p>
<p>使用defineProperty中的get来进行设置属性时，这个属性不能被改值，因为只写了get，只能够取到值而不能改值；要能够改值则需要写上set。其实这是一种变量权限的问题，如果该变量是某个属性的话，则可以使用defineProperty来控制其各类权限。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router = <span class="built_in">this</span>._root._router;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._root._router;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>模块支持检测：先判断当前的环境符合的哪种模块规范；cmd、amd、umd，或者CommonJS规范、import规范。</p>
<h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>通俗而讲：我去构建一个工厂方法，让使用者调用这个工厂方法去拿到他要的对象，而不是自己去构建，即不需要去new。</p>
<p>典型例子：jquery。使用jquery时是DOM时代，频繁获取并操作DOM。工厂模式直接用$()就可以拿到对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jquery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jquery.fn.init();</span><br><span class="line">    &#125;</span><br><span class="line">    jquery.fn.init.prototype = jquery.fn;</span><br><span class="line">    jquery.fn = jquery.prototype = &#123;</span><br><span class="line">        init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jquery.extend(&#123;</span><br><span class="line">        <span class="comment">//回调。给一个对象，将其添加到jquery上</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//这样去包装是为了jquery中的方法可以有多种调用方式，</span></span><br><span class="line">    <span class="comment">//但对象为引用类型，var b = &#123;&#125;, a = b, c = b,修改b时a、c均会修改，实现改一个均影响到。</span></span><br><span class="line">    <span class="built_in">window</span>.$ = <span class="built_in">window</span>.jquery = jquery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);<span class="comment">//定义一个匿名自执行函数，不污染外部全局变量，</span></span><br><span class="line"><span class="comment">//同时后面直接传参(window),减少作用链长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vue</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;));<span class="comment">//this在浏览器环境为window，在node环境为global，不会去写死</span></span><br></pre></td></tr></table></figure>

<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>在构建一个庞大的框架时，先把整个框架分开成几个模块，=》预制=》然后将各个模块融合在一起。</p>
<p>典型例子：vue-2，构建一个庞大的框架。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">        warn(<span class="string">&#x27;Vue is a constructor&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br><span class="line"><span class="comment">/*为什么非要分开开发，而不是全部放到原型链上即可。</span></span><br><span class="line"><span class="comment">1、由于是团队开发，全放在prototype，可能会收到相互之间的影响</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><p>整体的功能就是一大堆的函数，通过函数之间的相互调用来实现整体的功能。对于javaScript，函数才是一等公民：1、tree-shaking：基于文档流的原理，判断某个函数是否被调用，因此能够webpack时自动删除未被调用的函数。2、组合大于继承。因此函数式编程适用于工具库。</p>
<p>典型例子：Vue3，</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>vue-router、vuex这样的只能有一个，即典型的一个类只有一个实例化对象，即单例模式。实现很容易，就是先判断是否已经被实例化过，如果已经实例化过，就不再实例化；需要通过一个变量判断是否已经实例化过。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _vue;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">vue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (install.installed &amp;&amp; _vue == vue) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//执行安装</span></span><br><span class="line">    install.installed = <span class="literal">true</span>;</span><br><span class="line">    _vue = vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码简洁技巧：jquery中的extend({})方法，传入两个对象时，会将两个对象合并再传入。享元模式：减少重复的代码块的数量，将不同点提取出来作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> source = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</span><br><span class="line">        target = <span class="built_in">this</span>;</span><br><span class="line">        source = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> source) &#123;</span><br><span class="line">        target[item] = source[item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优雅利用原生方法：vue使用defineProperty来实现双向绑定，但只能应用于对象的属性；那么数组怎么来触发更新？将数组原生的push、pop、shift方法加上了能够触发双向绑定的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;push&quot;</span>, <span class="string">&quot;pop&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> arrayMethods = <span class="built_in">Object</span>.create(arraryProto);</span><br><span class="line"><span class="comment">//执行以下拷贝，来避免污染原生的原型链</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">methos</span>) =&gt;</span> &#123;</span><br><span class="line">    arrMethods[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> original = arrayProto[method];</span><br><span class="line">        <span class="keyword">let</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        <span class="comment">//先找到需要修改的方法，并先将原生方法的功能附加上去；</span></span><br><span class="line">        dep.noyify();<span class="comment">//触发数组更新</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//保持返回值与原方法一致</span></span><br><span class="line">        <span class="comment">//最后只替换数组中的原型链即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="应用进阶"><a href="#应用进阶" class="headerlink" title="应用进阶"></a>应用进阶</h1><h2 id="缓存架构-API"><a href="#缓存架构-API" class="headerlink" title="缓存架构-API"></a>缓存架构-API</h2><p>优化方案：快、小、省。</p>
<p>缓存：是所有优化方案里最常用、最有效、可以节省http请求，可以从内存中最快读取数据。</p>
<p>1、选择更快的API、算法，减少时间复杂度；</p>
<p>2、看到网站主要消耗的时间，更多地并不在于代码的执行速度，而在于资源加载的速度，因此文件体积小更重要。一、用webpack压缩treeshaking；二、减少代码重复；</p>
<p>vue3方面的改进：1、快：更快的API，用proxy来代替defineProperty；代理proxy不会去改变原对象；diff算法方面改进：对比新老的DOM，先分析动态DOM，只比对动态的DOM；2、小：函数式API：拥抱tree-shaking，可以很方便地将没有用到的方法取出来，并不附加在工程文件中。</p>
<p>3、省：节省http请求</p>
<p>读取数据的快慢：最慢：网络请求；其次：从硬盘中拿数据；最快：从内存中拿数据。因此请求缓存思路就是：有缓存的话，不去发送请求而是直接从缓存中拿去数据。</p>
<p>缓存架构的技巧：</p>
<p>1、缓存架构需要使用单例模式，即所有的缓存都放在一个里面。</p>
<p>2、权限问题，存缓的区域不能直接拿出去给别人操作。因此，需要隐藏起来，使用匿名自执行函数来进行；但同样，需要外界能够进行读取缓存操作，因此需要返回一个对象，在该对象内有一系列操作缓存的方法。这其实是函数闭包的应用。</p>
<p>3、缓存都会存在副作用：</p>
<p>一、更新问题：使用localstorage、session、cookies缓存时，缓存至本地，需要考虑更新问题。(1)、与后端进行websocket连接，但过于麻烦，没必要；(2)、通过定期轮询，定时器，每隔一段时间向后端发起ajax请求；经常变动的API不要用这种缓存；</p>
<p>使用内存缓存时，是不用考虑更新问题；但内存缓存同样有自己的问题，需要考虑占用内存问题，每往里面加东西，都会占用内存。javascript的内存限制较严重，因此需要做一个限制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.mycache) &#123;</span><br><span class="line">    <span class="built_in">window</span>.mycache = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">        <span class="keyword">var</span> cacheArr = [];</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span> (<span class="params">api</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//promise实现异步以及链式调用</span></span><br><span class="line">                 <span class="keyword">if</span> (cache[api])&#123;</span><br><span class="line">                    resolve(cache[api])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.set(api).then(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cacheArr.length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                            <span class="keyword">let</span> _api = cacheArr.shift();</span><br><span class="line">                            <span class="built_in">this</span>.remove(_api);</span><br><span class="line">                        &#125;</span><br><span class="line">                        cache[api] = res;</span><br><span class="line">                        cacheArr.push(api);</span><br><span class="line">                        <span class="comment">//需要确保内存限制，不要占用太多内存</span></span><br><span class="line">                        resolve(res);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> axios.get(api);</span><br><span class="line">            &#125;,</span><br><span class="line">            remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="comment">//放在匿名自执行函数里面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue插件"><a href="#vue插件" class="headerlink" title="vue插件"></a>vue插件</h2><p>关键的两个API：Vue.use；Vue.mixin。</p>
<p>Vue.use();原理：将一个方法执行一次，如果该方法中有install属性，就执行其install属性，来代替执行该方法；</p>
<p>Vue.mixin()；原理：相当于一个全局混合；(局部混合相当于在组件的export后写mixin)，可以混合方法methods、数据data、混合生命周期(生命周期的混入才是核心功能)。即，混入的生命周期操作，所有的组件在对应的生命周期均执行该操作函数。</p>
<p>打包项目=》打包体积过大，可以使用异步加载来减少体积 =》 vuex内容太大；=》vuex异步加载，根据组件来异步加载vuex，放在beforeCreated阶段，在DOM还没有加载好之前，将其之间的依赖关系读取好。 </p>
<p>插件的用途：1、提供逻辑复用；2、注入自定义操作；</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>Vue.util.defineReative：其实就是Vue自身去做响应式的方法，；一般来说只有data的数据能触发响应。这里，我们可以调用这个API，使外部数据也能触发响应。</p>
<p>用法：1、将localstorage中的数据触发响应，不需要将其取出来；2、监听window的事件，常用的是resize，实现尺寸的自适应；3、监听浏览器版本、内存；</p>
<p>本质是让外部数据也能触发响应。</p>
<p>Vue.extend：传入一个对象时，其会返回一个构造函数，直接new便可以创建实例。用于import，在使用import时，导入的是vue的选项。</p>
<p>vue单元测试=》测某个组件的方法和节点渲染结果</p>
<p>render渲染：提供函数，用JS来表达你的整个template，当页面的逻辑较为复杂时。</p>
<h1 id="API层"><a href="#API层" class="headerlink" title="API层"></a>API层</h1><h2 id="Axios源码分析"><a href="#Axios源码分析" class="headerlink" title="Axios源码分析"></a>Axios源码分析</h2><h3 id="Axios如何实现请求拦截、响应拦截"><a href="#Axios如何实现请求拦截、响应拦截" class="headerlink" title="Axios如何实现请求拦截、响应拦截"></a>Axios如何实现请求拦截、响应拦截</h3><p>1、初始化Axios，其实是调用request方法；</p>
<p>请求拦截器设置的处理——发送请求——响应拦截器设置的处理：这些一大堆方法由数组来存储；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">axios</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.interceptors = &#123;</span><br><span class="line">        request: <span class="keyword">new</span> interceptorsManner(),</span><br><span class="line">        response: <span class="keyword">new</span> interceptorsManner()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interceptorsManner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.handlers = [];</span><br><span class="line">&#125;</span><br><span class="line">interceptorsManner.prototype.use(<span class="function">(<span class="params">fullfilled, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handler.push(&#123;</span><br><span class="line">        fullfilled: fullfilled;</span><br><span class="line">        rejected: rejectes;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/06/%E5%89%8D%E7%AB%AF/vue%E7%BB%84%E4%BB%B6%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/06/%E5%89%8D%E7%AB%AF/vue%E7%BB%84%E4%BB%B6%E5%8C%96/" class="post-title-link" itemprop="url">vue组件化</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2020-11-06 21:28:16" itemprop="dateCreated datePublished" datetime="2020-11-06T21:28:16+08:00">2020-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 22:52:02" itemprop="dateModified" datetime="2021-03-12T22:52:02+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h1><p>简单地自己造一下轮子，实现一下vue的自定组件，这里主要先从form组件开始实践。</p>
<p>form组件需求分析：1、指定数据、校验规则；高内聚、低耦合；</p>
<p>2、这里为了实现form组件的输入功能，我们自定义一个input组件来实现；为保证低耦合性，仅使用并实现双向绑定基本功能。</p>
<p>3、校验的实现跟input分开，再自定义一个KFormItem组件来实现校验的功能。执行校验的组件为KFormItem组件，但通知父组件执行校验的是其子组件KINput，由于事件是谁派发谁监听，不能用this.$emit，需要用this.parent.$emit。之后，在KFormItrm组件上监听校验事件，执行具体校验。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>实现功能：维护数据；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义组件双向绑定：:value  @input --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-bind=&quot;$attrs&quot;展开$attrs </span></span><br><span class="line"><span class="comment">$attrs/$listeners包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有</span></span><br><span class="line"><span class="comment">声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">:type</span>=<span class="string">&quot;type&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    inheritAttrs: <span class="literal">false</span>, <span class="comment">// 设置为false避免设置到根元素上，</span></span></span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      type: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">&#x27;text&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onInput(e) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 派发一个input事件即可，相当于在原生input上面再封装一个实现了双向绑定的input</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, e.target.value)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 通知父级执行校验</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$parent.$emit(<span class="string">&#x27;validate&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="KFormItem"><a href="#KFormItem" class="headerlink" title="KFormItem"></a>KFormItem</h2><p>KformItem组件包裹Input组件，同时在前面添加label标签；</p>
<p>实现功能：1、执行校验2、显示错误信息</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- label --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-if</span>=<span class="string">&quot;label&quot;</span>&gt;</span>&#123;&#123;label&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 校验信息显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;error&quot;</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Asyc-validator</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Schema <span class="keyword">from</span> <span class="string">&quot;async-validator&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  inject: [<span class="string">&quot;form&quot;</span>],</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      error: <span class="string">&quot;&quot;</span> <span class="comment">// error是空说明校验通过</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    label: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    prop: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.$on(<span class="string">&quot;validate&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.validate();</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    validate() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 规则</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> rules = <span class="built_in">this</span>.form.rules[<span class="built_in">this</span>.prop];</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 当前值</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> value = <span class="built_in">this</span>.form.model[<span class="built_in">this</span>.prop];</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 校验描述对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> desc = &#123; [<span class="built_in">this</span>.prop]: rules &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 创建Schema实例</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(desc);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> schema.validate(&#123; [<span class="built_in">this</span>.prop]: value &#125;, <span class="function"><span class="params">errors</span> =&gt;</span> &#123;</span></span><br><span class="line">        if (errors) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.error = errors[<span class="number">0</span>].message;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 校验通过</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.error = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="KForm"><a href="#KForm" class="headerlink" title="KForm"></a>KForm</h2><p>一层层地往上面的层级进行靠近，在KForm的层级，除了实现slot将下面的层级包裹，同样也要接受数据并处理。</p>
<p>最终目的是在KForm上除了接受数据模型model以外，还要声明校验规则rules，因此声明数据model、rules。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  provide() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      form: <span class="built_in">this</span></span></span><br><span class="line"><span class="javascript">    &#125;;<span class="comment">//直接将组件自己传递出去，这样就能够在下面子组件拿到model、rules</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    model: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="javascript">      required: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    rules: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Object</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    validate(cb) &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 获取所有孩子KFormItem</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// [resultPromise]</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> tasks = <span class="built_in">this</span>.$children</span></span><br><span class="line"><span class="javascript">        .filter(<span class="function"><span class="params">item</span> =&gt;</span> item.prop) <span class="comment">// 过滤掉没有prop属性的Item</span></span></span><br><span class="line"><span class="javascript">        .map(<span class="function"><span class="params">item</span> =&gt;</span> item.validate());</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 统一处理所有Promise结果</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.all(tasks)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function">() =&gt;</span> cb(<span class="literal">true</span>))</span></span><br><span class="line"><span class="javascript">        .catch(<span class="function">() =&gt;</span> cb(<span class="literal">false</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>这样，在index层级里面，我们将所有的自定义组件封装起来，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;ElementTest&gt;&lt;/ElementTest&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- KForm --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">KForm</span> <span class="attr">:model</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;loginForm&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">KFormItem</span> <span class="attr">label</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">KInput</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">KInput</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">KFormItem</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">KFormItem</span> <span class="attr">label</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">KInput</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">KInput</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">KFormItem</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">KFormItem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">KFormItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">KForm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> ElementTest <span class="keyword">from</span> <span class="string">&quot;@/components/form/ElementTest.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> KInput <span class="keyword">from</span> <span class="string">&quot;@/components/form/KInput.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> KFormItem <span class="keyword">from</span> <span class="string">&quot;@/components/form/KFormItem.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> KForm <span class="keyword">from</span> <span class="string">&quot;@/components/form/KForm.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Notice <span class="keyword">from</span> <span class="string">&quot;@/components/Notice.vue&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      userInfo: &#123;</span><br><span class="line"><span class="javascript">        username: <span class="string">&quot;tom&quot;</span>,</span></span><br><span class="line"><span class="javascript">        password: <span class="string">&quot;&quot;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line"><span class="javascript">        username: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;请输入用户名称&quot;</span> &#125;],</span></span><br><span class="line"><span class="javascript">        password: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;请输入密码&quot;</span> &#125;]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ElementTest,</span><br><span class="line">    KInput,</span><br><span class="line">    KFormItem,</span><br><span class="line">    KForm</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs[<span class="string">&quot;loginForm&quot;</span>].validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> notice = <span class="built_in">this</span>.$create(Notice, &#123;</span></span><br><span class="line"><span class="javascript">          title: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">          message: valid ? <span class="string">&quot;请求登录!&quot;</span> : <span class="string">&quot;校验失败!&quot;</span>,</span></span><br><span class="line">          duration: 2000</span><br><span class="line">        &#125;);</span><br><span class="line">        notice.show();</span><br><span class="line"><span class="javascript">        <span class="comment">// if (valid) &#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   alert(&quot;submit&quot;);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125; else &#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   console.log(&quot;error submit!&quot;);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   return false;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>1、作为一个插件存在：实现VueRouter类和install方法</p>
<p>2、实现两个全局组件：router-view用于显示匹配组件内容，router-link用于跳转</p>
<p>3、监控url变化：监听hashchange或popstate事件</p>
<p>4、响应最新url：创建一个响应式的属性current，当它改变时获取对应组件并显示</p>
<h2 id="实现VueRouter插件"><a href="#实现VueRouter插件" class="headerlink" title="实现VueRouter插件"></a>实现VueRouter插件</h2><p>在toyRouter.js里面，我们需要实现一个插件，先创建VueRouter类，并且实现其install方法，该方法会在当前的Vue原型链上挂载$router。使用vue.mixin来混入生命周期中，保证每个vue均能实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KVueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$options);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">KVueRouter.install = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存构造函数，在KVueRouter里面使用</span></span><br><span class="line">  Vue = _Vue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载$router</span></span><br><span class="line">  <span class="comment">// 怎么获取根实例中的router选项,混入生命周期钩子即可，该生命周期钩子会在所有组件都执行一遍</span></span><br><span class="line">  <span class="comment">//为什么要用混入方式写？主要原因是Vue.use(VueRouter)代码在前，Router实例创建在后，而install逻辑又需要用到该实例</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="comment">// 确保根实例的时候才执行，只有根实例有router选项</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">        Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> KVueRouter</span><br></pre></td></tr></table></figure>

<h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><p>为实现功能，将其写成独立的组件，并在vueRouter的install方法中再将其引入。</p>
<p>router-link实现的功能是：解析用户输入的路由值，并重新渲染一个输入路由值对应的a标签。且在纯运行时的环境，不能使用template而需要用render函数来渲染页面，这里我们需要渲染一个a标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    to: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="comment">// &lt;a href=&quot;#/about&quot;&gt;abc&lt;/a&gt;</span></span><br><span class="line">    <span class="comment">// &lt;router-link to=&quot;/about&quot;&gt;xxx&lt;/router-link&gt;，值是用户通过props传进来的，因此直接用this.to，前面拼上#为了使用方便</span></span><br><span class="line">    <span class="comment">// h(tag, data, children)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$slots);</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#&#x27;</span> + <span class="built_in">this</span>.to &#125; &#125;, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">    <span class="comment">// return &lt;a href=&#123;&#x27;#&#x27; + this.to&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h2><p>router-view实现的功能基本上是：根据当前的路由值，获取对应的component并渲染在当前位置。</p>
<p>1、需要监控路由的变化，且为了实现路由改变时，便实时刷新页面，因此需要设置当前路由值为响应式数据。</p>
<p>2、为了确保查找的快速，在新建VueRouter时就应该以用户输入路由配置，初始化一个hash表，这样每次获取当前路由值的component时，只用O(1)时间即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述两点应该在VueRouter类中实现，因此VueRouter更新为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KVueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$options);</span><br><span class="line">    <span class="comment">// 需要创建响应式的current属性，当当前路由路径发生变化时，则页面就会重新渲染，这就是响应式</span></span><br><span class="line">    <span class="comment">// 利用Vue提供的defineReactive做响应化</span></span><br><span class="line">    <span class="comment">// 这样将来current变化的时候，依赖的组件会重新render</span></span><br><span class="line">    Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.app = new Vue(&#123;</span></span><br><span class="line">    <span class="comment">//   data() &#123;</span></span><br><span class="line">    <span class="comment">//     return &#123;</span></span><br><span class="line">    <span class="comment">//       current: &#x27;/&#x27;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监控url变化，利用bind锁定this，避免你使用的onHashChange函数的this变成后面的window</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))<span class="comment">//除了路由修改以外，用户刷新页面也要有重新渲染</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个路由映射表</span></span><br><span class="line">    <span class="built_in">this</span>.routeMap = &#123;&#125;</span><br><span class="line">    options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routeMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.location.hash);</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>);<span class="comment">//由于前面还有#号，因此需要slice切割一下</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在router-view页面要实现的功能就要简单些了，主要是从路由映射hsahMap中获取对应组件，这里同样要用render函数来渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="comment">//获取path对应的component</span></span><br><span class="line">    <span class="keyword">const</span> &#123;routeMap, current&#125; = <span class="built_in">this</span>.$router;<span class="comment">//从路由映射中找到对应的路由，用hash表来查找，快速找到结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(routeMap,current);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> component = routeMap[current].component || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> h(component)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>目的：集中管理数据、可预测的改变数据；类似于整个项目数据的大管家，确保整个程序的状态、数据能够保持同步的状态，维持稳定。</p>
<h2 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h2><p>1、实现一个插件：声明Store类，挂载$store</p>
<p>2、：创建响应式的state，保存mutations、actions和getters</p>
<p>3、实现commit根据用户传入type执行对应mutation</p>
<p>4、实现dispatch根据用户传入type执行对应action，同时传递上下文</p>
<p>5、实现getters，按照getters定义对state做派生</p>
<h2 id="实现store插件"><a href="#实现store插件" class="headerlink" title="实现store插件"></a>实现store插件</h2><p>声明Store、install方法，并创建一个响应式的state。同时利用存取器，避免用户直接去取state</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存构造函数引用，避免import</span></span><br><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// this.$options = options;</span></span><br><span class="line">    <span class="built_in">this</span>._mutations = options.mutations;</span><br><span class="line">    <span class="built_in">this</span>._actions = options.actions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应化处理state</span></span><br><span class="line">    <span class="comment">// this.state = new Vue(&#123;</span></span><br><span class="line">    <span class="comment">//   data: options.state</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="built_in">this</span>._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        <span class="comment">// 加两个$，Vue不做代理，因此对外部是隐藏的，不能直接去访问。</span></span><br><span class="line">        $$state: options.state</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定commit、dispatch的上下文问store实例</span></span><br><span class="line">    <span class="built_in">this</span>.commit = <span class="built_in">this</span>.commit.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.dispatch = <span class="built_in">this</span>.dispatch.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存取器， 用户通过store.state的方式来访问，这样避免用户直接修改state。</span></span><br><span class="line">    <span class="comment">//官方的实现是：使用一个watch去监听任何修改，一旦用户尝试修改，则直接报错。</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">state</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>._vm);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._vm._data.$$state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">state</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;无法修改！&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$options.store) &#123;</span><br><span class="line">        Vue.prototype.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vuex</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现commit、dispatch方法"><a href="#实现commit、dispatch方法" class="headerlink" title="实现commit、dispatch方法"></a>实现commit、dispatch方法</h2><p>在写方法之前需要将this.commit、this.dispatch绑定为该store实例，在构造函数上加上：this.commit = this.commit.bind(this)；this.dispatch = this.dispatch.bind(this)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在写方法之前需要将this.commit、this.dispatch绑定为该store实例，在构造函数上加上：</span></span><br><span class="line"><span class="comment">    this.commit = this.commit.bind(this);</span></span><br><span class="line"><span class="comment">    this.dispatch = this.dispatch.bind(this);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// store.commit(&#x27;add&#x27;, 1)</span></span><br><span class="line">  <span class="comment">// type: mutation的类型</span></span><br><span class="line">  <span class="comment">// payload：载荷，是参数</span></span><br><span class="line">  commit(type, payload) &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">    <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">      entry(<span class="built_in">this</span>.state, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(type, payload) &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._actions[type]</span><br><span class="line">    <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">      entry(<span class="built_in">this</span>, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现getters"><a href="#实现getters" class="headerlink" title="实现getters"></a>实现getters</h2>
      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/08/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/08/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构算法</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2020-10-08 19:42:38" itemprop="dateCreated datePublished" datetime="2020-10-08T19:42:38+08:00">2020-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-09 15:06:55" itemprop="dateModified" datetime="2020-10-09T15:06:55+08:00">2020-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="二叉搜索树的操作集锦"><a href="#二叉搜索树的操作集锦" class="headerlink" title="二叉搜索树的操作集锦"></a>二叉搜索树的操作集锦</h1><h2 id="总路线"><a href="#总路线" class="headerlink" title="总路线"></a>总路线</h2><p>⼆叉树算法的设计的总路线：明确⼀个节点要做的事情，然后剩下的事抛给 框架。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。 </span></span><br><span class="line">    <span class="comment">// 其他的不⽤ root 操⼼，抛给框架 </span></span><br><span class="line">    traverse(root.left); </span><br><span class="line">    traverse(root.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何把⼆叉树所有的节点中的值加⼀？"><a href="#如何把⼆叉树所有的节点中的值加⼀？" class="headerlink" title="如何把⼆叉树所有的节点中的值加⼀？"></a><strong>如何把⼆叉树所有的节点中的值加⼀？</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusOne</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>; </span><br><span class="line">    root.val += <span class="number">1</span>; </span><br><span class="line">    plusOne(root.left); </span><br><span class="line">    plusOne(root.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何判断两棵⼆叉树是否完全相同？"><a href="#如何判断两棵⼆叉树是否完全相同？" class="headerlink" title="如何判断两棵⼆叉树是否完全相同？"></a><strong>如何判断两棵⼆叉树是否完全相同？</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 都为空的话，显然相同 </span></span><br><span class="line">    <span class="keyword">if</span> (root1 == null &amp;&amp; root2 == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// ⼀个为空，⼀个⾮空，显然不同 </span></span><br><span class="line">    <span class="keyword">if</span> (root1 == null || root2 == null) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// 两个都⾮空，但 val 不⼀样也不⾏ </span></span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// root1 和 root2 该⽐的都⽐完了 </span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root1.left, root2.left) </span><br><span class="line">        &amp;&amp; isSameTree(root1.right, root2.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助框架可以理解上述两个例子，那么就能解决所有二叉树算法。</p>
<p>二叉搜索树BST是一种很常用的二叉树，定义为：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树所有节点的值。</p>
<p>基础操作有：判断合法性、增、删、查。</p>
<h2 id="判断BST的合法性"><a href="#判断BST的合法性" class="headerlink" title="判断BST的合法性"></a>判断BST的合法性</h2><p>这⾥是有坑的哦，我们按照刚才的思路，每个节点⾃⼰要做的事不就是⽐较 ⾃⼰和左右孩⼦吗？看起来应该这样写代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (root.left != null &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (root.right != null &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left) </span><br><span class="line">        &amp;&amp; isValidBST(root.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个算法出现了错误，BST 的每个节点应该要⼩于右边⼦树的所有节 点，下⾯这个⼆叉树显然不是 BST，但是我们的算法会把它判定为 BST。出现错误，不要慌张，框架没有错，⼀定是某个细节问题没注意到。我们重 新看⼀下 BST 的定义，root 需要做的不只是和左右⼦节点⽐较，⽽是要整 个左⼦树和右⼦树所有节点⽐较。怎么办，鞭⻓莫及啊！</p>
<p>这种情况，我们可以使⽤辅助函数，增加函数参数列表，在参数中携带额外 信息，请看正确的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, null, null); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode <span class="built_in">min</span>, TreeNode <span class="built_in">max</span>)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span> != null &amp;&amp; root.val &lt;= <span class="built_in">min</span>.val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> != null &amp;&amp; root.val &gt;= <span class="built_in">max</span>.val) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, <span class="built_in">min</span>, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, <span class="built_in">max</span>); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在BST中查找一个数是否存在"><a href="#在BST中查找一个数是否存在" class="headerlink" title="在BST中查找一个数是否存在"></a>在BST中查找一个数是否存在</h2><p>根据我们的指导思想，可以这样写代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isInBST(root.left, target) || </span><br><span class="line">        isInBST(root.right, target); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑⼀ 点细节问题了：如何充分利⽤信息，把 BST 这个“左⼩右⼤”的特性⽤上？ 很简单，其实不需要递归地搜索两边，类似⼆分查找思想，根据 target 和 root.val 的⼤⼩⽐较，就能排除⼀边。我们把上⾯的思路稍稍改动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (root.val == target) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target) </span><br><span class="line">        <span class="keyword">return</span> isInBST(root.left, target); </span><br><span class="line">    <span class="comment">// root 该做的事做完了，顺带把框架也完成了，妙 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，我们对原始框架进⾏改造，抽象出⼀套<strong>针对</strong> <strong>BST</strong> <strong>的遍历框架</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root.val == target) </span><br><span class="line">        <span class="comment">// 找到⽬标，做点什么 </span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">            BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target) </span><br><span class="line">            BST(root.left, target); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-BST-中插⼊⼀个数"><a href="#在-BST-中插⼊⼀个数" class="headerlink" title="在 BST 中插⼊⼀个数"></a><strong>在</strong> <strong>BST</strong> <strong>中插⼊⼀个数</strong></h2><p>对数据结构的操作⽆⾮遍历 + 访问，遍历就是“找”，访问就是“改”。具体到 这个问题，插⼊⼀个数，就是先找到插⼊位置，然后进⾏插⼊操作。 </p>
<p>上⼀个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框 架，加上“改”的操作即可。⼀旦涉及“改”，函数就要返回 TreeNode 类型， 并且对递归调⽤的返回值进⾏接收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 找到空位置插⼊新节点 </span></span><br><span class="line">    <span class="keyword">if</span> (root == null) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val); </span><br><span class="line">    <span class="comment">// if (root.val == val) </span></span><br><span class="line">    <span class="comment">// BST 中⼀般不会插⼊已存在元素 </span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val); </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val); </span><br><span class="line">    <span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-BST-中删除⼀个数"><a href="#在-BST-中删除⼀个数" class="headerlink" title="在 BST 中删除⼀个数"></a><strong>在</strong> <strong>BST</strong> <strong>中删除⼀个数</strong></h2><p>这个问题稍微复杂，不过你有框架指导，难不住你。跟插⼊操作类似， 先“找”再“改”，先把框架写出来再说： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123; </span><br><span class="line">        <span class="comment">// 找到啦，进⾏删除 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123; </span><br><span class="line">        root.left = deleteNode(root.left, key); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123; </span><br><span class="line">        root.right = deleteNode(root.right, key); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到⽬标节点了，⽐⽅说是节点 A，如何删除这个节点，这是难点。因为删 除节点的同时不能破坏 BST 的性质。有三种情况，⽤图⽚来说明。 </p>
<p>情况 1：A 恰好是末端节点，两个⼦节点都为空，那么它可以当场去世了。 </p>
<p>情况 2：A 只有⼀个⾮空⼦节点，那么它要让这个孩⼦接替⾃⼰的位置。</p>
<p>情况 3：A 有两个⼦节点，⿇烦了，为了不破坏 BST 的性质，A 必须找到 左⼦树中最⼤的那个节点，或者右⼦树中最⼩的那个节点来接替⾃⼰。我们 以第⼆种⽅式讲解。 </p>
<p>三种情况分析完毕，填⼊框架，简化⼀下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null; </span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123; </span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了 </span></span><br><span class="line">        <span class="keyword">if</span> (root.left == null) <span class="keyword">return</span> root.right; </span><br><span class="line">        <span class="keyword">if</span> (root.right == null) <span class="keyword">return</span> root.left; </span><br><span class="line">        <span class="comment">// 处理情况 3 </span></span><br><span class="line">        TreeNode minNode = getMin(root.right); </span><br><span class="line">        root.val = minNode.val; </span><br><span class="line">        root.right = deleteNode(root.right, minNode.val); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123; </span><br><span class="line">        root.left = deleteNode(root.left, key); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123; </span><br><span class="line">        root.right = deleteNode(root.right, key); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// BST 最左边的就是最⼩的 </span></span><br><span class="line">    <span class="keyword">while</span> (node.left != null) node = node.left; </span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除操作就完成了。注意⼀下，这个删除操作并不完美，因为我们⼀般不会 通过 root.val = minNode.val 修改节点内部的值来交换节点，⽽是通过⼀系列 略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应⽤中，val 域可能会很⼤，修改起来很耗时，⽽链表操作⽆⾮改⼀改指针，⽽不会去碰 内部数据。 </p>
<p>但这⾥忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层 细化问题的思维⽅式。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇⽂章，你学会了如下⼏个技巧： </p>
<p>1、⼆叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归 </p>
<p>框架，不⽤当前节点操⼼。 </p>
<p>2、如果当前节点会对下⾯的⼦节点有整体影响，可以通过辅助函数增⻓参 </p>
<p>数列表，借助参数传递信息。 </p>
<p>3、在⼆叉树框架之上，扩展出⼀套 BST 遍历框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root.val == target) ;</span><br><span class="line">        <span class="comment">// 找到⽬标，做点什么 </span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">            BST(root.right, target); </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target) </span><br><span class="line">        BST(root.left, target); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、掌握了 BST 的基本操作。</p>
<h1 id="快速计算完全⼆叉树的节点"><a href="#快速计算完全⼆叉树的节点" class="headerlink" title="快速计算完全⼆叉树的节点"></a>快速计算完全⼆叉树的节点</h1><p>如果让你数⼀下⼀棵普通⼆叉树有多少个节点，这很简单，只要在⼆叉树的 遍历框架上加⼀点代码就⾏了。 </p>
<p>但是，如果给你⼀棵完全⼆叉树，让你计算它的节点个数，你会不会？算法 的时间复杂度是多少？这个算法的时间复杂度应该是 O(logN*logN)，如果 你⼼中的算法没有达到⾼效，那么本⽂就是给你写的。 </p>
<p>⾸先要明确⼀下两个关于⼆叉树的名词「完全⼆叉树」和「满⼆叉树」。 我们说的<strong>完全⼆叉树</strong>如下图，每⼀层都是紧凑靠左排列的： 我们说的<strong>满⼆叉树</strong>如下图，是⼀种特殊的完全⼆叉树，每层都是是满的，像 ⼀个稳定的三⾓形： </p>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>如果是一个<strong>普通</strong>二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果是一棵<strong>满</strong>二叉树，节点总数就和树的高度呈指数关系，时间复杂度 O(logN)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != null) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点总数就是 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完全</strong>二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode l = root, r = root;</span><br><span class="line">    <span class="comment">// 记录左、右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hl = <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != null) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != null) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合刚才针对满二叉树和普通二叉树的算法，上面这段代码应该不难理解，就是一个结合版，但是<strong>其中降低时间复杂度的技巧是非常微妙的</strong>。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>开头说了，这个算法的时间复杂度是 O(logN<em>logN)，这是怎么算出来的呢？直觉感觉好像最坏情况下是 O(N</em>logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br></pre></td></tr></table></figure>

<p><strong>关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发<code>hl == hr</code>而立即返回，不会递归下去</strong>。</p>
<p>为什么呢？原因如下：</p>
<p><strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong>：</p>
<p>看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发<code>hl == hr</code>，只消耗 O(logN) 的复杂度而不会继续递归。</p>
<p>综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。</p>
<h1 id="如何使用单调栈解题"><a href="#如何使用单调栈解题" class="headerlink" title="如何使用单调栈解题"></a>如何使用单调栈解题</h1><p>单调栈实际上就是栈，只是利⽤了⼀些巧妙的逻辑，使得每次新元素⼊栈 后，栈内的元素都保持有序（单调递增或单调递减）。听起来有点像堆（heap）？不是的，单调栈⽤途不太⼴泛，只处理⼀种典型 的问题，叫做 Next Greater Element。本⽂⽤讲解单调队列的算法模版解决 这类问题，并且探讨处理「循环数组」的策略。 </p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>⾸先，讲解 Next Greater Number 的原始问题：给你⼀个数组，返回⼀个等 ⻓的数组，对应索引存储着下⼀个更⼤元素，如果没有更⼤的元素，就存 -1。不好⽤语⾔解释清楚，直接上⼀个例⼦： </p>
<p>给你⼀个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。 </p>
<p>解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯ ⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4 ⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。这道题的暴⼒解法很好想到，就是对每个元素后⾯都进⾏扫描，找到第⼀个 更⼤的元素就⾏了。但是暴⼒解法的时间复杂度是 O(n^2)。 </p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这个问题可以这样抽象思考：把数组的元素想象成并列站⽴的⼈，元素⼤⼩ 想象成⼈的⾝⾼。这些⼈⾯对你站成⼀列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后⾯可⻅的第⼀个 ⼈就是「2」的 Next Greater Number，因为⽐「2」⼩的元素⾝⾼不够，都被「2」挡住了，第⼀个露出来的就是答案。 </p>
<p>这个情景很好理解吧？带着这个抽象的情景，先来看下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>; </span><br><span class="line">    <span class="comment">// 存放答案的数组 </span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="comment">// 倒着往栈⾥放 </span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; </span><br><span class="line">            <span class="comment">// 判定个⼦⾼矮 </span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。 </span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素⾝后的第⼀个⾼个 </span></span><br><span class="line">        s.push(nums[i]); </span><br><span class="line">        <span class="comment">// 进队，接受之后的⾝⾼判定吧！ </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们 借助的是栈的结构，倒着⼊栈，其实是正着出栈。while 循环是把两个“⾼ 个”元素之间的元素排除，因为他们的存在没有意义，前⾯挡着个“更⾼”的 元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。 这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循 环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂 度只有 O(n)</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push ⼊栈了⼀次，⽽最多会被 pop ⼀次，没有任何冗余操作。所以总的计 算规模是和元素规模 n 成正⽐的，也就是 O(n) 的复杂度。 </p>
<p>给你⼀个数组 T = [73, 74, 75, 71, 69, 72, 76, 73]，这个数组存放的是近⼏天 的天⽓⽓温（这⽓温是铁板烧？不是的，这⾥⽤的华⽒度）。你返回⼀个数 组，计算：对于每⼀天，你还要⾄少等多少天才能等到⼀个更暖和的⽓温； 如果等不到那⼀天，填 0 。</p>
<p>举例：给你 T = [73, 74, 75, 71, 69, 72, 76, 73]，你返回 [1, 1, 4, 2, 1, 1, 0, 0]。 </p>
<p>解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天， 只要等⼀天就能等到⼀个更暖和的⽓温。后⾯的同理。 你已经对 Next Greater Number 类型问题有些敏感了，这个问题本质上也是 找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多 少，⽽是问你当前距离 Next Greater Number 的距离⽽已。 相同类型的问题，相同的思路，直接调⽤单调栈的算法模板，稍作改动就可 以啦，直接上代码把</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(T.<span class="built_in">size</span>())</span></span>; </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这⾥放元素索引，⽽不是元素 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123; </span><br><span class="line">            s.pop(); </span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">0</span> : (s.top() - i); </span><br><span class="line">        <span class="comment">// 得到索引间距 </span></span><br><span class="line">        s.push(i); </span><br><span class="line">        <span class="comment">// 加⼊索引，⽽不是元素 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展问题：循环数组"><a href="#扩展问题：循环数组" class="headerlink" title="扩展问题：循环数组"></a>扩展问题：循环数组</h2><p>单调栈讲解完毕。下⾯开始另⼀个重点：如何处理「循环数组」。 </p>
<p>同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？ </p>
<p>给你⼀个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后 ⼀个元素 3 绕了⼀圈后找到了⽐⾃⼰⼤的元素 4 。 </p>
<p>⾸先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可 以模拟出环形数组的效果，⼀般是通过 % 运算符求模（余数），获得环形特效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> n = arr.length, index = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="built_in">print</span>(arr[index % n]); </span><br><span class="line">    index++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于： </p>
<p>这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左 边（如上例）。 </p>
<p>明确问题，问题就已经解决了⼀半了。我们可以考虑这样的思路：将原始数 组“翻倍”，就是在后⾯再接⼀个原始数组，这样的话，按照之前“⽐⾝⾼”的 流程，每个元素不仅可以⽐较⾃⼰右边的元素，⽽且也可以和左边的元素⽐ 较了</p>
<p>怎么实现呢？你当然可以把这个双倍⻓度的数组构造出来，然后套⽤算法模 板。但是，我们可以不⽤构造新数组，⽽是利⽤循环数组的技巧来模拟。直 接看代码吧： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>; </span><br><span class="line">    <span class="comment">// 存放结果 </span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line">    <span class="comment">// 假装这个数组⻓度翻倍了 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) </span><br><span class="line">            s.pop(); </span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top(); </span><br><span class="line">        s.push(nums[i % n]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="利用单调队列解题"><a href="#利用单调队列解题" class="headerlink" title="利用单调队列解题"></a>利用单调队列解题</h1><p>前⽂讲了⼀种特殊的数据结构「单调栈」monotonic stack，解决了⼀类问题 「Next Greater Number」，本⽂写⼀个类似的数据结构「单调队列」。 也许这种数据结构的名字你没听过，其实没啥难的，就是⼀个「队列」，只 是使⽤了⼀点巧妙的⽅法，使得队列中的元素单调递增（或递减）。这个数 据结构有什么⽤？可以解决滑动窗⼝的⼀系列问题</p>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧；你只可以看到在滑动窗口k内的数字，滑动窗口每次只向右移动一位，返回滑动窗口最大值。</p>
<h1 id="二叉堆详解"><a href="#二叉堆详解" class="headerlink" title="二叉堆详解"></a>二叉堆详解</h1><p>⼆叉堆（Binary Heap）没什么神秘，性质⽐⼆叉搜索树 BST 还简单。其主 要操作就两个， sink （下沉）和 swim （上浮），⽤以维护⼆叉堆的性 质。其主要应⽤有两个，⾸先是⼀种排序⽅法「堆排序」，第⼆是⼀种很有 ⽤的数据结构「优先级队列」。 </p>
<p>本⽂就以实现优先级队列（Priority Queue）为例，通过图⽚和⼈类的语⾔来 描述⼀下⼆叉堆怎么运作的</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>⼆叉堆其实就是⼀种特殊的⼆叉树（完全⼆叉树），只不过存储在数 组⾥。⼀般的链表⼆叉树，我们操作节点的指针，⽽在数组⾥，我们把数组 索引作为指针： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⽗节点的索引 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩⼦的索引 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩⼦的索引 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画个图你⽴即就能理解了，注意数组的第⼀个索引 0 空着不⽤，<img src="/2020/10/08/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86.png" alt="二叉堆"></p>
<p>PS：因为数组索引是数组，为了⽅便区分，将字符作为数组元素。 </p>
<p>你看到了，把 arr[1] 作为整棵树的根的话，每个节点的⽗节点和左右孩⼦的 索引都可以通过简单的运算得到，这就是⼆叉堆设计的⼀个巧妙之处。为了 ⽅便讲解，下⾯都会画的图都是⼆叉树结构，相信你能把树和数组对应起 来</p>
<p>⼆叉堆还分为最⼤堆和最⼩堆。<strong>最⼤堆的性质是：每个节点都⼤于等于它的</strong> <strong>两个⼦节点。</strong>类似的，最⼩堆的性质是：每个节点都⼩于等于它的⼦节点。 两种堆核⼼思路都是⼀样的，本⽂以最⼤堆为例讲解。 对于⼀个最⼤堆，根据其性质，显然堆顶，也就是 arr[1] ⼀定是所有元素中 最⼤的元素。 </p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列这种数据结构有⼀个很有⽤的功能，你插⼊或者删除元素的时 候，元素会⾃动排序，这底层的原理就是⼆叉堆的操作。 </p>
<p>数据结构的功能⽆⾮增删查该，优先级队列有两个主要 API，分别是 insert 插⼊⼀个元素和 delMax 删除最⼤元素（如果底层⽤最⼩堆，那么 就是 delMin ）。 </p>
<p>下⾯我们实现⼀个简化的优先级队列，先看下代码框架： PS：为了清晰起⻅，这⾥⽤到 Java 的泛型， Key 可以是任何⼀种可⽐较⼤ ⼩的数据类型，你可以认为它是 int、char 等。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span> </span></span><br><span class="line"><span class="class">    &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123; </span><br><span class="line">    <span class="comment">// 存储元素的数组 </span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq; </span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>; <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 索引 0 不⽤，所以多分配⼀个空间 </span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Comparable[cap + <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回当前队列中最⼤元素 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 插⼊元素 e */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key e)</span> </span>&#123;...&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最⼤元素 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;...&#125; </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 上浮第 k 个元素，以维护最⼤堆性质 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;...&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 下沉第 k 个元素，以维护最⼤堆性质 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">        Key temp = pq[i]; </span><br><span class="line">        pq[i] = pq[j]; </span><br><span class="line">        pq[j] = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* pq[i] 是否⽐ pq[j] ⼩？ */</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 还有 left, right, parent 三个⽅法 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空出来的四个⽅法是⼆叉堆和优先级队列的奥妙所在，下⾯⽤图⽂来逐个理解</p>
<h2 id="swim和sink"><a href="#swim和sink" class="headerlink" title="swim和sink"></a>swim和sink</h2><p>为什么要有上浮 swim 和下沉 sink 的操作呢？为了维护堆结构。 我们要讲的是最⼤堆，每个节点都⽐它的两个⼦节点⼤，但是在插⼊元素和 删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<p>对于最⼤堆，会破坏堆性质的有有两种情况： </p>
<p>1、 如果某个节点 A ⽐它的⼦节点（中的⼀个）⼩，那么 A 就不配做⽗节点，应该下去，下⾯那个更⼤的节点上来做⽗节点，这就是对 A 进⾏ <strong>下沉</strong>。 </p>
<p>2、 如果某个节点 A ⽐它的⽗节点⼤，那么 A 不应该做⼦节点，应该把⽗ 节点换下来，⾃⼰去做⽗节点，这就是对 A 的<strong>上浮</strong>。 </p>
<p>当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位 置，恢复堆的性质。所以代码中肯定有⼀个 while 循环。 </p>
<p>细⼼的读者也许会问，这两个操作不是互逆吗，所以上浮的操作⼀定能⽤下 沉来完成，为什么我还要费劲写两个⽅法？ 是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进⾏（等 会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要 下沉</p>
<p><strong>上浮的代码实现：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 如果浮到堆顶，就不能再上浮了 </span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(parent(k), k)) &#123; </span><br><span class="line">        <span class="comment">// 如果第 k 个元素⽐上层⼤ </span></span><br><span class="line">        <span class="comment">// 将 k 换上去 </span></span><br><span class="line">        exch(parent(k), k); </span><br><span class="line">        k = parent(k); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下沉的代码实现：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 如果沉到堆底，就沉不下去了 </span></span><br><span class="line">    <span class="keyword">while</span> (left(k) &lt;= N) &#123; </span><br><span class="line">        <span class="comment">// 先假设左边节点较⼤ </span></span><br><span class="line">        <span class="keyword">int</span> older = left(k); </span><br><span class="line">        <span class="comment">// 如果右边节点存在，⽐⼀下⼤⼩ </span></span><br><span class="line">        <span class="keyword">if</span> (right(k) &lt;= N &amp;&amp; less(older, right(k))) </span><br><span class="line">            older = right(k); </span><br><span class="line">        <span class="comment">// 结点 k ⽐俩孩⼦都⼤，就不必下沉了 </span></span><br><span class="line">        <span class="keyword">if</span> (less(older, k)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则，不符合最⼤堆的结构，下沉 k 结点 </span></span><br><span class="line">        exch(k, older); </span><br><span class="line">        k = older; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⾄此，⼆叉堆的主要操作就讲完了，⼀点都不难吧，代码加起来也就⼗⾏。 明⽩了 sink 和 swim 的⾏为，下⾯就可以实现优先级队列了</p>
<h2 id="实现-delMax-和-insert"><a href="#实现-delMax-和-insert" class="headerlink" title="实现 delMax 和 insert"></a><strong>实现</strong> <strong>delMax</strong> <strong>和</strong> <strong>insert</strong></h2><p>这两个⽅法就是建⽴在 swim 和 sink 上的。 <strong>insert</strong> <strong>⽅法先把要插⼊的元素添加到堆底的最后，然后让其上浮到正确位</strong> <strong>置。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key e)</span> </span>&#123; </span><br><span class="line">    N++; </span><br><span class="line">    <span class="comment">// 先把新元素加到最后 </span></span><br><span class="line">    pq[N] = e; </span><br><span class="line">    <span class="comment">// 然后让它上浮到正确的位置 </span></span><br><span class="line">    swim(N); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>delMax</strong> <strong>⽅法先把堆顶元素</strong> <strong>A</strong> <strong>和堆底最后的元素</strong> <strong>B</strong> <strong>对调，然后删除</strong> <strong>A**</strong>，最** <strong>后让</strong> <strong>B</strong> <strong>下沉到正确位置。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 最⼤堆的堆顶就是最⼤元素 </span></span><br><span class="line">    Key <span class="built_in">max</span> = pq[<span class="number">1</span>]; </span><br><span class="line">    <span class="comment">// 把这个最⼤元素换到最后，删除之 </span></span><br><span class="line">    exch(<span class="number">1</span>, N);</span><br><span class="line">    pq[N] = null; </span><br><span class="line">    N--; </span><br><span class="line">    <span class="comment">// 让 pq[1] 下沉到正确位置 </span></span><br><span class="line">    sink(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⾄此，⼀个优先级队列就实现了，插⼊和删除元素的时间复杂度为 O(logK) ， K 为当前⼆叉堆（优先级队列）中的元素总数。因为我们时间 复杂度主要花费在 sink 或者 swim 上，⽽不管上浮还是下沉，最多也就 树（堆）的⾼度，也就是 log 级别</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>⼆叉堆就是⼀种完全⼆叉树，所以适合存储在数组中，⽽且⼆叉堆拥有⼀些 特殊性质。 </p>
<p>⼆叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序）， 核⼼代码也就⼗⾏。 </p>
<p>优先级队列是基于⼆叉堆实现的，主要操作是插⼊和删除。插⼊是先插到最 后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位 置。核⼼代码也就⼗⾏。 </p>
<p>也许这就是数据结构的威⼒，简单的操作就能实现巧妙的功能，真⼼佩服发明⼆叉堆算法的⼈！ </p>
<h1 id><a href="#" class="headerlink" title></a></h1>
      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/29/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/29/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">双指针查找与常用算法框架</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2020-09-29 17:30:23" itemprop="dateCreated datePublished" datetime="2020-09-29T17:30:23+08:00">2020-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-15 00:22:36" itemprop="dateModified" datetime="2021-01-15T00:22:36+08:00">2021-01-15</time>
              </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="双指针技巧详解"><a href="#双指针技巧详解" class="headerlink" title="双指针技巧详解"></a>双指针技巧详解</h1><p>主要分为两类：1、快慢指针；2、左右指针；前者主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或字符串）中的问题，比如：二分查找。</p>
<p>链表、子串、数组的题目，一般都需要用到双指针技巧。</p>
<p>链表指针数组题，用双指针别犹豫。</p>
<p>双指针家三兄弟，各个都是万人迷。</p>
<p>快慢指针最神奇，链表操作无压力。</p>
<p>归并排序找中点，链表成环搞判定。</p>
<p>左右指针最常见，左右两端相向行。</p>
<p>反转数组要靠它，二分搜索是弟弟。</p>
<p>滑动窗口老猛男，子串问题全靠它。</p>
<p>左右指针滑窗口，一前一后齐头进。</p>
<h2 id="快慢指针的用法"><a href="#快慢指针的用法" class="headerlink" title="快慢指针的用法"></a>快慢指针的用法</h2><p>快慢指针一般都初始化指向链表的头节点head，前进时快指针fast在前，慢指针slow在后，从而巧妙解决链表中问题。</p>
<h3 id="判定链表中是否有环"><a href="#判定链表中是否有环" class="headerlink" title="判定链表中是否有环"></a>判定链表中是否有环</h3><p>单链表的特点是每个节点只知道下⼀个节点，所以⼀个指针的话⽆法判断链 表中是否含有环的。 如果链表中不含环，那么这个指针最终会遇到空指针 null 表⽰链表到头 了，这还好说，可以判断该链表不含环。但是如果链表中含有环，那么这个指针就会陷⼊死循环，因为环形数组中没 有 null 指针作为尾部节点。 </p>
<p>经典解法就是⽤两个指针，⼀个跑得快，⼀个跑得慢。如果不含有环，跑得 快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终 会超慢指针⼀圈，和慢指针相遇，说明链表含有环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123; </span><br><span class="line">    ListNode fast, slow; </span><br><span class="line">    fast = slow = head; </span><br><span class="line">    <span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123; </span><br><span class="line">        fast = fast.next.next; </span><br><span class="line">        slow = slow.next; </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知链表中有环，返回其起始位置"><a href="#已知链表中有环，返回其起始位置" class="headerlink" title="已知链表中有环，返回其起始位置"></a>已知链表中有环，返回其起始位置</h3><p>可以看到，当快慢指针相遇时，让其中任⼀个指针指向头节点，然后让它俩 以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
<p>第⼀次相遇时，假设慢指针 slow ⾛了 k 步，那么快指针 fast ⼀定⾛了 2k 步，也就是说⽐ slow 多⾛了 k 步（也就是环的⻓度）。设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。 巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。 所以，只要我们把快慢指针中的任⼀个重新指向 head，然后两个指针同速 前进，k - m 步后就会相遇，相遇之处就是环的起点了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123; </span><br><span class="line">    ListNode fast, slow; </span><br><span class="line">    fast = slow = head; </span><br><span class="line">    <span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123; </span><br><span class="line">        fast = fast.next.next; </span><br><span class="line">        slow = slow.next; </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;<span class="comment">// 上⾯的代码类似 hasCycle 函数</span></span><br><span class="line">        slow = head; </span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123; </span><br><span class="line">        fast = fast.next; </span><br><span class="line">        slow = slow.next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找链表的中点"><a href="#寻找链表的中点" class="headerlink" title="寻找链表的中点"></a>寻找链表的中点</h3><p>类似上⾯的思路，我们还可以让快指针⼀次前进两步，慢指针⼀次前进⼀ 步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的⻓度是奇数时，slow 恰巧停在中点位置；如果⻓度是偶数，slow 最终的位置是中间偏右。</p>
<p>寻找链表中点的⼀个重要作⽤是对链表进⾏归并排序。 回想数组的归并排序：求中点索引递归地把数组⼆分，最后合并两个有序数 组。对于链表，合并两个有序链表是很简单的，难点就在于⼆分。 但是现在你学会了找到链表的中点，就能实现链表的⼆分了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123; </span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next; </span><br><span class="line">&#125;<span class="comment">// slow 就在中间位置 </span></span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>

<h3 id="寻找链表的倒数第k个元素"><a href="#寻找链表的倒数第k个元素" class="headerlink" title="寻找链表的倒数第k个元素"></a>寻找链表的倒数第k个元素</h3><p>我们的思路还是使⽤快慢指针，让快指针先⾛ k 步，然后快慢指针开始同速 前进。这样当快指针⾛到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode slow, fast; </span><br><span class="line">slow = fast = head; </span><br><span class="line"><span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) </span><br><span class="line">    fast = fast.next; </span><br><span class="line"><span class="keyword">while</span> (fast != null) &#123; </span><br><span class="line">    slow = slow.next; </span><br><span class="line">    fast = fast.next; &#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="左右指针的常见用法"><a href="#左右指针的常见用法" class="headerlink" title="左右指针的常见用法"></a>左右指针的常见用法</h2><p>左右指针在数组中实际是指两个索引值，⼀般初始化为 left = 0, right = nums.length - 1 。 </p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二数之和"><a href="#二数之和" class="headerlink" title="二数之和"></a>二数之和</h3><p>给定一个已经按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回两个下标值index1和index2。</p>
<p>只要数组有序就应该想到双指针用法，解法类似于二分查找，通过调节left和right来调整sum的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right]; </span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123; <span class="comment">// 题⽬要求的索引是从 1 开始的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123; </span><br><span class="line">            left++; </span><br><span class="line">            <span class="comment">// 让 sum ⼤⼀点 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123; </span><br><span class="line">            right--; </span><br><span class="line">            <span class="comment">// 让 sum ⼩⼀点 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="comment">// swap(nums[left], nums[right]) </span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[left]; </span><br><span class="line">        nums[left] = nums[right]; </span><br><span class="line">        nums[right] = temp; </span><br><span class="line">        left++; </span><br><span class="line">        right--; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>滑动窗口是双指针技巧的最高境界，可以解决一大类子字符串匹配的问题，比如：最小覆盖子串、字符串的排列、找到字符串中所有字母异位词、无重复字符的最长子串。其实算法的技巧思路特别简单，即维护一个窗口，不断滑动并更新答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增⼤窗⼝ </span></span><br><span class="line">    window.add(s[right]); </span><br><span class="line">    right++; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123; </span><br><span class="line">        <span class="comment">// 缩⼩窗⼝ </span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]); </span><br><span class="line">        left++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法技巧的时间复杂度是 O(N)，⽐字符串暴⼒算法要⾼效得多。 其实困扰⼤家的，不是算法的思路，⽽是各种细节问题。⽐如说如何向窗⼝ 中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果。即便你明 ⽩了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让⼈⼼烦 的。</p>
<p><strong>所以今天我就写⼀套滑动窗⼝算法的代码框架，我连再哪⾥做输出</strong> <strong>debug</strong> <strong>都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地</strong> <strong>⽅就⾏，还不会出</strong> <strong>bug</strong>： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且，这两个<code>...</code>处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：</p>
<p><code>unordered_map</code>就是哈希表（字典），它的一个方法<code>count(key)</code>相当于 Java 的<code>containsKey(key)</code>可以判断键 key 是否存在。可以使用方括号访问键对应的值<code>map[key]</code>。需要注意的是，如果该<code>key</code>不存在，C++ 会自动创建这个 key，并把<code>map[key]</code>赋值为 0。所以代码中多次出现的<code>map[key]++</code>相当于 Java 的<code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p>
<h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h3><p>题目：给你一个字符串S、字符串T，请在字符串S中找出：包含T所有字母的最小子串。</p>
<p>就是说要在<code>S</code>(source) 中找到包含<code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++)</span><br><span class="line">        <span class="keyword">if</span> s[i:j] 包含 t 的所有字母:</span><br><span class="line">            更新答案</span><br></pre></td></tr></table></figure>

<p>而滑动窗口的思路是这样的：</p>
<p><strong><em>1、</em></strong>我们在字符串<code>S</code>中使用双指针中的左右指针技巧，初始化<code>left = right = 0</code>，把索引左闭右开区间<code>[left, right)</code>称为一个「窗口」。</p>
<p><strong><em>2、</em></strong>我们先不断地增加<code>right</code>指针扩大窗口<code>[left, right)</code>，直到窗口中的字符串符合要求（包含了<code>T</code>中的所有字符）。</p>
<p><strong><em>3、</em></strong>此时，我们停止增加<code>right</code>，转而不断增加<code>left</code>指针缩小窗口<code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含<code>T</code>中的所有字符了）。同时，每次增加<code>left</code>，我们都要更新一轮结果。</p>
<p><strong><em>4、</em></strong>重复第 2 和第 3 步，直到<code>right</code>到达字符串<code>S</code>的尽头</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。下面画图理解一下，<code>needs</code>和<code>window</code>相当于计数器，分别记录<code>T</code>中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先，初始化window和need两个哈希表，记录窗口中的字符和需要凑齐的字符：</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;<span class="comment">//为每个键值赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后，使用left和right变量初始化窗口的两端，不要忘了，区间[left, right)是左闭右开的，所以初始情况下窗口没有包含任何元素：</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中valid变量表示窗口中满足need条件的字符个数，如果valid和need.size的大小相同，则说明窗口已满足条件，已经完全覆盖了串T。</span></span><br><span class="line"><span class="comment">//现在开始套模板，只需要思考以下四个问题：</span></span><br><span class="line"><span class="comment">//1、当移动right扩大窗口，即加入字符时，应该更新哪些数据？</span></span><br><span class="line"><span class="comment">//2、什么条件下，窗口应该暂停扩大，开始移动left缩小窗口？</span></span><br><span class="line"><span class="comment">//3、当移动left缩小窗口，即移出字符时，应该更新哪些数据？</span></span><br><span class="line"><span class="comment">//4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个字符进入窗口，应该增加window计数器；如果一个字符将移出窗口的时候，应该减少window计数器；当valid满足need时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ?</span><br><span class="line">        <span class="string">&quot;&quot;</span> : s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当我们发现某个字符在<code>window</code>的数量满足了<code>need</code>的需要，就要更新<code>valid</code>，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p>
<p>当<code>valid == need.size()</code>时，说明<code>T</code>中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。移动<code>left</code>收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p>
<p>至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。<strong>以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿</strong>。</p>
<h3 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h3><p>题目：给定两个字符串S1、S2，写一个函数来判断S2是否包含S1的序列；即第一个字符串的排列之一是第二个字符串的子串</p>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个<code>S</code>和一个<code>T</code>，请问你<code>S</code>中是否存在一个子串，包含<code>T</code>中所有字符且不包含其他字符</strong>？首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 s 中是否存在 t 的排列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> t, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到符合条件的子串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p><strong>1、</strong>本题移动<code>left</code>缩小窗口的时机是窗口大小大于<code>t.size()</code>时，因为排列嘛，显然长度应该是一样的。</p>
<p><strong>2、</strong>当发现<code>valid == need.size()</code>时，就说明窗口中就是一个合法的排列，所以立即返回<code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="找所有字母异位词"><a href="#找所有字母异位词" class="headerlink" title="找所有字母异位词"></a>找所有字母异位词</h3><p>给定一个字符串s和非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。（字母异位词指字母相同，但排列不同的字符串；不考虑答案输出的顺序）</p>
<p>呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？<strong>相当于，输入一个串<code>S</code>，一个串<code>T</code>，找到<code>S</code>中所有<code>T</code>的排列，返回它们的起始索引</strong>。直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.count(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt;= t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 当窗口符合条件时，把起始索引加入 res</span></span><br><span class="line">            <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>())</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入<code>res</code>即可</p>
<h3 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h3><p>题目：给定一个字符串，找出其中不含有重复重复字符的的最长子串的长度。 </p>
<p>这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这里更新答案</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是变简单了，连<code>need</code>和<code>valid</code>都不需要，而且更新窗口内数据也只需要简单的更新计数器<code>window</code>即可。</p>
<p>当<code>window[c]</code>值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动<code>left</code>缩小窗口了嘛。唯一需要注意的是，在哪里更新结果<code>res</code>呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p>
<p>这里和之前不一样，**要在收缩窗口完成后更新<code>res</code>**，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p>
<h1 id="twoSum问题的核心思想"><a href="#twoSum问题的核心思想" class="headerlink" title="twoSum问题的核心思想"></a>twoSum问题的核心思想</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>这个问题的<strong>最基本形式</strong>是这样：给你⼀个数组和⼀个整数 target ，可以保 证数组中<strong>存在</strong>两个数的和为 target ，请你返回这两个数的索引。这个问题如何解决呢？⾸先最简单粗暴的办法当然是穷举了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) </span><br><span class="line">            <span class="keyword">if</span> (nums[j] == target - nums[i]) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;; </span><br><span class="line">    <span class="comment">// 不存在这么两个数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法⾮常直接，时间复杂度 O(N^2)，空间复杂度 O(1)。 可以通过⼀个哈希表减少时间复杂度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123; </span><br><span class="line">    <span class="keyword">int</span> n = nums.length; </span><br><span class="line">    index&lt;Integer, Integer&gt; </span><br><span class="line">        index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 构造⼀个哈希表：元素映射到相应的索引 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        index.<span class="built_in">put</span>(nums[i], i); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        <span class="keyword">int</span> other = target - nums[i]; </span><br><span class="line">        <span class="comment">// 如果 other 存在且不是 nums[i] 本⾝ </span></span><br><span class="line">        <span class="keyword">if</span> (index.containsKey(other) &amp;&amp; index.<span class="built_in">get</span>(other) != i) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, index.<span class="built_in">get</span>(other)&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，由于哈希表的查询时间为 O(1)，算法的时间复杂度降低到 O(N)，但 是需要 O(N) 的空间复杂度来存储哈希表。不过综合来看，是要⽐暴⼒解法 ⾼效的。 </p>
<p><strong>我觉得</strong> <strong>Two Sum</strong> <strong>系列问题就是想教我们如何使⽤哈希表处理问题</strong>。我们接 着往后看。 </p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>这⾥我们稍微修改⼀下上⾯的问题。我们设计⼀个类，拥有两个 API： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span> </span><br><span class="line">    <span class="comment">// 向数据结构中添加⼀个数 number </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span>; </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实现这两个 API 呢，我们可以仿照上⼀道题⽬，使⽤⼀个哈希表辅助 find ⽅法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span> </span><br><span class="line">    Map&lt;Integer, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 记录 number 出现的次数 </span></span><br><span class="line">        freq.<span class="built_in">put</span>(number, freq.getOrDefault(number, <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (Integer key : freq.keySet()) &#123; </span><br><span class="line">            <span class="keyword">int</span> other = value - key; </span><br><span class="line">            <span class="comment">// 情况⼀ </span></span><br><span class="line">            <span class="keyword">if</span> (other == key &amp;&amp; freq.<span class="built_in">get</span>(key) &gt; <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 情况⼆ </span></span><br><span class="line">            <span class="keyword">if</span> (other != key &amp;&amp; freq.containsKey(other)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进⾏ find 的时候有两种情况，举个例⼦： </p>
<p>情况⼀： add 了 [3,3,2,5] 之后，执⾏ find(6) ，由于 3 出现了两次，3 + 3 = 6，所以返回 true。 </p>
<p>情况⼆： add 了 [3,3,2,5] 之后，执⾏ find(7) ，那么 key 为 2， other 为 5 时算法可以返回 true。 </p>
<p>除了上述两种情况外， find 只能返回 false 了。 </p>
<p>对于这个解法的时间复杂度呢， add ⽅法是 O(1)， find ⽅法是 O(N)，空 间复杂度为 O(N)，和上⼀道题⽬⽐较类似。<strong>但是对于</strong> <strong>API</strong> <strong>的设计，是需要考虑现实情况的</strong>。⽐如说，我们设计的这个 类，使⽤ find ⽅法⾮常频繁，那么每次都要 O(N) 的时间，岂不是很浪费 费时间吗？对于这种情况，我们是否可以做些优化呢？ </p>
<p>是的，对于频繁使⽤ find ⽅法的场景，我们可以进⾏优化。我们可以参 考上⼀道题⽬的暴⼒解法，借助<strong>哈希集合</strong>来针对性优化 find ⽅法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line">    Set&lt;Integer&gt; sum = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 记录所有可能组成的和 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) </span><br><span class="line">            sum.add(n + number); </span><br><span class="line">        nums.add(number); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sum.contains(value); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 sum 中就储存了所有加⼊数字可能组成的和，每次 find 只要花费 O(1) 的时间在集合中判断⼀下是否存在就⾏了，显然⾮常适合频繁使⽤ find 的场景。</p>
<p>对于 TwoSum 问题，⼀个难点就是给的数组<strong>⽆序</strong>。对于⼀个⽆序的数组， 我们似乎什么技巧也没有，只能暴⼒穷举所有可能。 </p>
<p><strong>⼀般情况下，我们会⾸先把数组排序再考虑双指针技巧</strong>。TwoSum 启发我 们，HashMap 或者 HashSet 也可以帮助我们处理⽆序数组相关的简单问题。 另外，设计的核⼼在于权衡，利⽤不同的数据结构，可以得到⼀些针对性的 加强。 </p>
<p>最后，如果 TwoSum I 中给的数组是有序的，应该如何编写算法呢？答案很 简单，前⽂「双指针技巧汇总」写过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right]; </span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123; </span><br><span class="line">            left++; <span class="comment">// 让 sum ⼤⼀点 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123; </span><br><span class="line">            right--; <span class="comment">// 让 sum ⼩⼀点 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在这样两个数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找详解"><a href="#二分查找详解" class="headerlink" title="二分查找详解"></a>二分查找详解</h1><p>⼆分查找并不简单，Knuth ⼤佬（发明 KMP 算法的那位）都说⼆分查找： </p>
<p><strong>思路很简单，细节是魔⿁</strong>。很多⼈喜欢拿整型溢出的 bug 说事⼉，但是⼆分 查找真正的坑根本就不是那个细节问题，⽽是在于到底要给 mid 加⼀还是 减⼀，while ⾥到底⽤ &lt;= 还是 &lt; 。 </p>
<h2 id="二分搜索诗"><a href="#二分搜索诗" class="headerlink" title="二分搜索诗"></a>二分搜索诗</h2><p>管他左侧还右侧，搜索区间定乾坤。</p>
<p>搜索一个元素时，搜索区间两端闭。</p>
<p>while条件带等号，否则需要打补丁。</p>
<p>if相等就返回，其他的事甭操心。</p>
<p>mid必须加减一，因为区间两端闭。</p>
<p>while结束就凉凉，凄凄惨惨返-1。</p>
<p>搜索左右边界时，搜索区间要阐明。</p>
<p>左闭右开最常见，其余逻辑便自明。</p>
<p>while要用小于号，这样才能不漏掉。</p>
<p>if相等别返回，利用mid锁边界。</p>
<p>mid加一或减一？要看区间区间开或闭。</p>
<p>while结束不算完，因为你还没返回。</p>
<p>索引可能出边界，if检查保平安。</p>
<h2 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...; </span><br><span class="line">    <span class="keyword">while</span>(...) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123; </span><br><span class="line">            ... </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123; </span><br><span class="line">            left = ... </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123; </span><br><span class="line">            right = ... </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析⼆分查找的⼀个技巧是：不要出现</strong> <strong>else**</strong>，⽽是把所有情况⽤** <strong>else if</strong> <strong>写清</strong> <strong>楚，这样可以清楚地展现所有细节</strong>。本⽂都会使⽤ else if，旨在讲清楚。</p>
<p>其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分 查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样 的变化。 </p>
<p>另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防⽌了 left 和right 太⼤直接相加导致溢出</p>
<h2 id="寻找一个数：基本二分查找"><a href="#寻找一个数：基本二分查找" class="headerlink" title="寻找一个数：基本二分查找"></a>寻找一个数：基本二分查找</h2><p>这个场景是最简单的，肯能也是⼤家最熟悉的，即搜索⼀个数，如果存在， 返回其索引，否则返回 -1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意 </span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1**</strong>、为什么** <strong>while</strong> <strong>循环的条件中是</strong> <strong>&lt;=**</strong>，⽽不是** **&lt;**？ </p>
<p>答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索 引，⽽不是 nums.length 。 </p>
<p>这⼆者可能出现在不同功能的⼆分查找中，区别是：前者相当于两端都闭区 间 [left, right] ，后者相当于左闭右开区间 [left, right) ，因为索引⼤⼩为 nums.length 是越界的。</p>
<p>我们这个算法中使⽤的是前者 [left, right] 两端都闭的区间。<strong>这个区间</strong> </p>
<p><strong>其实就是每次进⾏搜索的区间</strong>。 </p>
<p>2、什么时候应该停⽌搜索呢？</p>
<p>当然，找到了⽬标值的时候可以终⽌： </p>
<p>if(nums[mid] == target) return mid; </p>
<p>但如果没找到，就需要 while 循环终⽌，然后返回 -1。那 while 循环什么时 候应该终⽌？<strong>搜索区间为空的时候应该终⽌</strong>，意味着你没得找了，就等于没 找到嘛。 </p>
<p>while(left &lt;= right) 的终⽌条件是 left == right + 1 ，写成区间的形式 就是 [right + 1, right] ，或者带个具体的数字进去 [3, 2] ，可⻅<strong>这时候</strong> <strong>区间为空</strong>，</p>
<p>while(left &lt; right) 的终⽌条件是 left == right ，写成区间的形式就是 [left, right] ，或者带个具体的数字进去 [2, 2] ，<strong>这时候区间⾮空</strong>，还 有⼀个数 2，但此时 while 循环终⽌了。也就是说这区间 [2, 2] 被漏掉 了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p><strong>3**</strong>、为什么** <strong>left = mid + 1</strong> <strong>，</strong> <strong>right = mid - 1</strong> <strong>？我看有的代码是</strong> <strong>right =</strong> <strong>mid</strong> <strong>或者</strong> <strong>left = mid</strong> <strong>，没有这些加加减减，到底怎么回事，怎么判断</strong>？ </p>
<p>答：这也是⼆分查找的⼀个难点，不过只要你能理解前⾯的内容，就能够很 容易判断。 </p>
<p>刚才明确了「搜索区间」这个概念，⽽且本算法的搜索区间是两端都闭的， 即 [left, right] 。那么当我们发现索引 mid 不是要找的 target 时，下 ⼀步应该去搜索哪⾥呢？ 当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？<strong>因为</strong> <strong>mid</strong> <strong>已</strong> <strong>经搜索过，应该从搜索区间中去除</strong>。</p>
<p><strong>4**</strong>、此算法有什么缺陷**？ </p>
<p>答：⾄此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但 是，这个算法存在局限性。 </p>
<p>⽐如说给你有序数组 nums = [1,2,2,2,3] ， target 为 2，此算法返回的索 引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我 想得到 target 的右侧边界，即索引 3，这样的话此算法是⽆法处理的。</p>
<h2 id="寻找左侧边界的⼆分搜索"><a href="#寻找左侧边界的⼆分搜索" class="headerlink" title="寻找左侧边界的⼆分搜索"></a><strong>寻找左侧边界的⼆分搜索</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意 </span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意 </span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123; </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123; </span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123; </span><br><span class="line">            right = mid; <span class="comment">// 注意 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1**</strong>、为什么** <strong>while</strong> <strong>中是</strong> <strong>&lt;</strong> <strong>⽽不是</strong> <strong>&lt;=</strong> ? </p>
<p>答：⽤相同的⽅法分析，因为 right = nums.length ⽽不是 nums.length - 1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。 while(left &lt; right) 终⽌的条件是 left == right ，此时搜索区间 [left, left) 为空，所以可以正确终⽌。 </p>
<h2 id="寻找右侧边界的⼆分查找"><a href="#寻找右侧边界的⼆分查找" class="headerlink" title="寻找右侧边界的⼆分查找"></a><strong>寻找右侧边界的⼆分查找</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123; </span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123; </span><br><span class="line">            right = mid; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;<span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串乘法"><a href="#字符串乘法" class="headerlink" title="字符串乘法"></a>字符串乘法</h1><p>对于⽐较⼩的数字，做运算可以直接使⽤编程语⾔提供的运算符，但是如果 相乘的两个因数⾮常⼤，语⾔提供的数据类型可能就会溢出。⼀种替代⽅案 就是，运算数以字符串的形式输⼊，然后模仿我们⼩学学习的乘法算术过程 计算出结果，并且也⽤字符串表⽰。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个以字符串形式表示的非负整数num1、num2，返回num1和num2的乘积，它们的乘积也表示为字符串的形式。</p>
<p>需要注意的是， num1 和 num2 可以⾮常⻓，所以不可以把他们直接转成 整型然后运算，唯⼀的思路就是模仿我们⼿算乘法。 </p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>计算 123 × 5 ，再计算 123 × 4 ，最后错⼀位相加。这个流程恐怕⼩学⽣ 都可以熟练完成，但是你是否能<strong>把这个运算过程进⼀步机械化</strong>，写成⼀套算 法指令让没有任何智商的计算机来执⾏呢？ </p>
<p>你看这个简单过程，其中涉及乘法进位，涉及错位相加，还涉及加法进位； ⽽且还有⼀些不易察觉的问题，⽐如说两位数乘以两位数，结果可能是四位 数，也可能是三位数，你怎么想出⼀个标准化的处理⽅式？这就是算法的魅 ⼒，如果没有计算机思维，简单的问题可能都没办法⾃动化处理。 </p>
<p>⾸先，我们这种⼿算⽅式还是太「⾼级」了，我们要再「低级」⼀点， 123 × 5 和 123 × 4 的过程还可以进⼀步分解，最后再相加： </p>
<p>现在 123 并不⼤，如果是个很⼤的数字的话，是⽆法直接计算乘积的。我 们可以⽤⼀个数组在底下接收相加结果： </p>
<p>整个计算过程⼤概是这样，<strong>有两个指针</strong> *<em>i**</em>，<strong>j</strong> <strong>在</strong> <strong>num1</strong> <strong>和</strong> <strong>num2</strong> <strong>上游⾛，</strong> </p>
<p><strong>计算乘积，同时将乘积叠加到</strong> <strong>res</strong> <strong>的正确位置</strong>：  现在还有⼀个关键问题，如何将乘积叠加到 res 的正确位置，或者说，如 何通过 i，j 计算 res 的对应索引呢？ 其实，细⼼观察之后就发现， <strong>num1[i]</strong> <strong>和</strong> <strong>num2[j]</strong> <strong>的乘积对应的就是</strong> <strong>res[i+j]</strong> <strong>和</strong> <strong>res[i+j+1]</strong> <strong>这两个位置</strong>。 </p>
<p>明⽩了这⼀点，就可以⽤代码模仿出这个计算过程了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> m = num1.<span class="built_in">size</span>(), n = num2.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="comment">// 结果最多为 m + n 位数 </span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(m + n, <span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="comment">// 从个位数开始逐位相乘 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123; </span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i]-<span class="string">&#x27;0&#x27;</span>) * (num2[j]-<span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">            <span class="comment">// 乘积在 res 对应的索引位置 </span></span><br><span class="line">            <span class="keyword">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>; </span><br><span class="line">            <span class="comment">// 叠加到 res 上 </span></span><br><span class="line">            <span class="keyword">int</span> sum = mul + res[p2]; </span><br><span class="line">            res[p2] = sum % <span class="number">10</span>; </span><br><span class="line">            res[p1] += sum / <span class="number">10</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="comment">// 结果前缀可能存的 0（未使⽤的位） </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; res.<span class="built_in">size</span>() &amp;&amp; res[i] == <span class="number">0</span>) </span><br><span class="line">        i++; </span><br><span class="line">    <span class="comment">// 将计算结果转化成字符串 </span></span><br><span class="line">    <span class="built_in">string</span> str; </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; res.<span class="built_in">size</span>(); i++) </span><br><span class="line">        str.push_back(<span class="string">&#x27;0&#x27;</span> + res[i]); </span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">size</span>() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : str; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结⼀下</strong>，我们习以为常的⼀些思维⽅式，在计算机看来是⾮常难以做到 的。⽐如说我们习惯的算术流程并不复杂，但是如果让你再进⼀步，翻译成 代码逻辑，并不简单。算法需要将计算流程再简化，通过边算边叠加的⽅式 来得到结果。 </p>
<p>俗话教育我们，不要陷⼊思维定式，不要程序化，要发散思维，要创新。但 我觉得程序化并不是坏事，可以⼤幅提⾼效率，减⼩失误率。算法不就是⼀ 套程序化的思维吗，只有程序化才能让计算机帮助我们解决复杂问题呀！</p>
<h1 id="前缀和技巧"><a href="#前缀和技巧" class="headerlink" title="前缀和技巧"></a>前缀和技巧</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>算出⼀共有⼏个和为 k 的⼦数组。给定一个整数数组和一个整数k，你需要找到该数组中和为k的连续的子数组的个数。</p>
<p>输入：nums = [1,1,1], k = 2；输出：2，[1,1]与[1,1]为两种不同的情况。</p>
<h2 id="解法思路："><a href="#解法思路：" class="headerlink" title="解法思路："></a>解法思路：</h2><p>那我把所有⼦数组都穷举出来，算它们的和，看看谁的和等于 k 不就⾏了。 关键是，<strong>如何快速得到某个⼦数组的和呢</strong>，⽐如说给你⼀个数组 nums ，让 你实现⼀个接⼝ sum(i, j) ，这个接⼝要返回 nums[i..j] 的和，⽽且会被 多次调⽤，你怎么实现这个接⼝呢？ </p>
<p>因为接⼝要被多次调⽤，显然不能每次都去遍历 nums[i..j] ，有没有⼀种 快速的⽅法在 O(1) 时间内算出 nums[i..j] 呢？这就需要<strong>前缀和</strong>技巧了。</p>
<h3 id="什么是前缀和"><a href="#什么是前缀和" class="headerlink" title="什么是前缀和"></a>什么是前缀和</h3><p>前缀和的思路是这样的，对于⼀个给定的数组 nums ，我们额外开辟⼀个前 缀和数组进⾏预处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = nums.length; <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">preSum[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br></pre></td></tr></table></figure>

<p>这个前缀和数组 preSum 的含义也很好理解， preSum[i] 就是 nums[0..i- 1] 的和。那么如果我们想求 nums[i..j] 的和，只需要⼀步操作 </p>
<p>preSum[j+1]-preSum[i] 即可，⽽不需要重新去遍历数组了。 </p>
<p>回到这个⼦数组问题，我们想求有多少个⼦数组的和为 k，借助前缀和技巧 </p>
<p>很容易写出⼀个解法： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = nums.length; </span><br><span class="line">    <span class="comment">// 构造前缀和 </span></span><br><span class="line">    <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] + nums[i]; </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 穷举所有⼦数组 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="comment">// sum of nums[j..i-1] </span></span><br><span class="line">            <span class="keyword">if</span> (sum[i] - sum[j] == k) </span><br><span class="line">                ans++; </span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法的时间复杂度 O(N^2) 空间复杂度 O(N) ，并不是最优的解法。不 过通过这个解法理解了前缀和数组的⼯作原理之后，可以使⽤⼀些巧妙的办 法把时间复杂度进⼀步降低</p>
<h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前⾯的解法有嵌套的 for 循环：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">        <span class="keyword">if</span> (sum[i] - sum[j] == k) </span><br><span class="line">            ans++;</span><br><span class="line"><span class="comment">//第⼆层 for 循环在⼲嘛呢？翻译⼀下就是，在计算，有⼏个 j 能够使得 sum[i] 和 sum[j] 的差为 k。毎找到⼀个这样的 j ，就把结果加⼀。 我们可以把 if 语句⾥的条件判断移项，这样写：</span></span><br><span class="line"><span class="keyword">if</span> (sum[j] == sum[i] - k) </span><br><span class="line">    ans++;</span><br><span class="line"><span class="comment">//优化的思路是：我直接记录下有⼏个 sum[j] 和 sum[i] - k 相等，直接更 新结果，就避免了内层的 for 循环。</span></span><br><span class="line"><span class="comment">//我们可以⽤哈希表，在记录前缀和的同 时记录该前缀和出现的次数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n = nums.length; <span class="comment">// map：前缀和 -&gt; 该前缀和出现的次数 </span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt;;</span><br><span class="line">    preSum = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    preSum.<span class="built_in">put</span>(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, sum0_i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        sum0_i += nums[i]; </span><br><span class="line">        <span class="comment">// 这是我们想找的前缀和 nums[0..j] </span></span><br><span class="line">        <span class="keyword">int</span> sum0_j = sum0_i - k; </span><br><span class="line">        <span class="comment">// 如果前⾯有这个前缀和，则直接更新答案 </span></span><br><span class="line">        <span class="keyword">if</span> (preSum.containsKey(sum0_j)) </span><br><span class="line">            ans += preSum.<span class="built_in">get</span>(sum0_j); </span><br><span class="line">        <span class="comment">// 把前缀和 nums[0..i] 加⼊并记录出现次数 </span></span><br><span class="line">        preSum.<span class="built_in">put</span>(sum0_i, preSum.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就把时间复杂度降到了 O(N) ，是最优解法了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前缀和不难，却很有⽤，主要⽤于处理数组区间的问题。 ⽐如说，让你统计班上同学考试成绩在不同分数段的百分⽐，也可以利⽤前 缀和技巧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] scores; <span class="comment">// 存储着所有同学的分数 </span></span><br><span class="line"><span class="comment">// 试卷满分 150 分 </span></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">150</span> + <span class="number">1</span>] <span class="comment">// 记录每个分数有⼏个同学 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> score : scores)</span><br><span class="line">        count[score]++;</span><br><span class="line"><span class="comment">// 构造前缀和 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) </span><br><span class="line">    count[i] = count[i] + count[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>

<p>这样，给你任何⼀个分数段，你都能通过前缀和相减快速计算出这个分数段 \的⼈数，百分⽐也就很容易计算了。 </p>
<p>但是，稍微复杂⼀些的算法问题，不⽌考察简单的前缀和技巧。⽐如本⽂探 讨的这道题⽬，就需要借助前缀和的思路做进⼀步的优化，借助哈希表去除 不必要的嵌套循环。可⻅对题⽬的理解和细节的分析能⼒对于算法的优化是 ⾄关重要的。 </p>

      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/23/%E5%89%8D%E7%AB%AF/jQuery%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Li Yudong">
      <meta itemprop="description" content="请乐观，请珍惜">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/%E5%89%8D%E7%AB%AF/jQuery%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">jQuery教程</a>
        </h2>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
    
              <time title="创建时间：2020-09-23 22:53:01" itemprop="dateCreated datePublished" datetime="2020-09-23T22:53:01+08:00">2020-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-24 14:48:37" itemprop="dateModified" datetime="2020-09-24T14:48:37+08:00">2020-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/" itemprop="url" rel="index"><span itemprop="name">前端页面</span></a>
                </span>
            </span>
    
          
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
          <h1 id="jQuery基础"><a href="#jQuery基础" class="headerlink" title="jQuery基础"></a>jQuery基础</h1><p>jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程。</p>
<p>jQuery库包含以下功能：</p>
<ul>
<li>HTML 元素选取</li>
<li>HTML 元素操作</li>
<li>CSS 操作</li>
<li>HTML 事件函数</li>
<li>JavaScript 特效和动画</li>
<li>HTML DOM 遍历和修改</li>
<li>AJAX</li>
<li>Utilities</li>
</ul>
<p><strong>提示：</strong> 除此之外，Jquery还提供了大量的插件。</p>
<h2 id="jQuery语法"><a href="#jQuery语法" class="headerlink" title="jQuery语法"></a>jQuery语法</h2><p>jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。</p>
<p>基础语法： <strong>$(*selector*).*action*()</strong></p>
<ul>
<li>美元符号定义 jQuery</li>
<li>选择符（selector）”查询”和”查找” HTML 元素</li>
<li>jQuery 的 action() 执行对元素的操作</li>
</ul>
<p>实例:</p>
<ul>
<li>$(this).hide() - 隐藏当前元素</li>
<li>$(“p”).hide() - 隐藏所有 <p> 元素</p></li>
<li>$(“p.test”).hide() - 隐藏所有 class=”test” 的 <p> 元素</p></li>
<li>$(“#test”).hide() - 隐藏 id=”test” 的元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">试图隐藏一个不存在的元素</span></span><br><span class="line"><span class="comment">获得未完全加载的图像的大小*/</span></span><br></pre></td></tr></table></figure>

<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><p>jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-selectors.html">CSS 选择器</a>，除此之外，它还有一些自定义的选择器。</p>
<p>jQuery 中所有选择器都以美元符号开头：$()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery 元素选择器基于元素名选取元素,在页面中选取所有 &lt;p&gt; 元素。</span></span><br><span class="line"><span class="comment">//用户点击按钮后，所有 &lt;p&gt; 元素都隐藏。</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;p&quot;</span>).hide();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。</span></span><br><span class="line"><span class="comment">//页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#test&quot;</span>).hide();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//jQuery 类选择器可以通过指定的 class 查找元素。</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;.test&quot;</span>).hide();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果您的网站包含许多页面，并且您希望您的 jQuery 函数易于维护，那么请把您的 jQuery 函数放到独立的 .js 文件中。</span></span><br><span class="line"><span class="comment">//当我们在教程中演示 jQuery 时，会将函数直接添加到 &lt;head&gt; 部分中。不过，把它们放到一个单独的文件中会更好，就像这样（通过 src 属性来引用文件）：</span></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;my_jquery_functions.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><p>在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。页面中指定一个点击事件：下一步是定义什么时间触发事件，可以通过一个事件函数来实现；</p>
<h3 id="常用的-jQuery-事件方法"><a href="#常用的-jQuery-事件方法" class="headerlink" title="常用的 jQuery 事件方法"></a>常用的 jQuery 事件方法</h3><h4 id="document-ready"><a href="#document-ready" class="headerlink" title="$(document).ready()"></a>$(document).ready()</h4><p>$(document).ready() 方法允许我们在文档完全加载完后执行函数。该事件方法在 <a target="_blank" rel="noopener" href="https://www.runoob.com/jquery/jquery-syntax.html">jQuery 语法</a> 章节中已经提到过。</p>
<h4 id="click"><a href="#click" class="headerlink" title="click()"></a>click()</h4><p>click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。</p>
<h4 id="dblclick"><a href="#dblclick" class="headerlink" title="dblclick()"></a>dblclick()</h4><p>当双击元素时，会发生 dblclick 事件。</p>
<p>dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数：</p>
<h4 id="mouseenter"><a href="#mouseenter" class="headerlink" title="mouseenter()"></a>mouseenter()</h4><p>当鼠标指针穿过元素时，会发生 mouseenter 事件。</p>
<p>mouseenter() 方法触发 mouseenter 事件，或规定当发生 mouseenter 事件时运行的函数：</p>
<h4 id="mouseleave"><a href="#mouseleave" class="headerlink" title="mouseleave()"></a>mouseleave()</h4><p>当鼠标指针离开元素时，会发生 mouseleave 事件。</p>
<p>mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数：</p>
<h4 id="mousedown"><a href="#mousedown" class="headerlink" title="mousedown()"></a>mousedown()</h4><p>当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。</p>
<p>mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数</p>
<h4 id="mouseup"><a href="#mouseup" class="headerlink" title="mouseup()"></a>mouseup()</h4><p>当在元素上松开鼠标按钮时，会发生 mouseup 事件。</p>
<p>mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数：</p>
<h4 id="hover"><a href="#hover" class="headerlink" title="hover()"></a>hover()</h4><p>hover()方法用于模拟光标悬停事件。</p>
<p>当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。</p>
<h4 id="focus"><a href="#focus" class="headerlink" title="focus()"></a>focus()</h4><p>当元素获得焦点时，发生 focus 事件。</p>
<p>当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。</p>
<p>focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数</p>
<h4 id="blur"><a href="#blur" class="headerlink" title="blur()"></a>blur()</h4><p>当元素失去焦点时，发生 blur 事件。</p>
<p>blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数：</p>
<h1 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h1><h2 id="隐藏与显示"><a href="#隐藏与显示" class="headerlink" title="隐藏与显示"></a>隐藏与显示</h2><p>通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(selector).hide(speed,callback);</span><br><span class="line">$(selector).show(speed,callback);</span><br><span class="line"><span class="comment">//可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span></span><br><span class="line"><span class="comment">//可选的 callback 参数是隐藏或显示完成后所执行的函数名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。</span></span><br><span class="line"><span class="comment">//显示被隐藏的元素，并隐藏已显示的元素：</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;p&quot;</span>).toggle();</span><br><span class="line">&#125;);</span><br><span class="line">$(selector).toggle(speed,callback);</span><br><span class="line"><span class="comment">//可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。可选的 callback 参数是隐藏或显示完成后所执行的函数名称。</span></span><br></pre></td></tr></table></figure>

<h2 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h2><p>通过 jQuery，您可以实现元素的淡入淡出效果。jQuery 拥有下面四种 fade 方法：</p>
<ul>
<li>fadeIn()</li>
<li>fadeOut()</li>
<li>fadeToggle()</li>
<li>fadeTo()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery fadeIn() 用于淡入已隐藏的元素;</span></span><br><span class="line">$(selector).fadeIn(speed,callback);</span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#div1&quot;</span>).fadeIn();</span><br><span class="line">  $(<span class="string">&quot;#div2&quot;</span>).fadeIn(<span class="string">&quot;slow&quot;</span>);</span><br><span class="line">  $(<span class="string">&quot;#div3&quot;</span>).fadeIn(<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery fadeOut() 方法用于淡出可见元素</span></span><br><span class="line">$(selector).fadeOut(speed,callback);</span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#div1&quot;</span>).fadeOut();</span><br><span class="line">  $(<span class="string">&quot;#div2&quot;</span>).fadeOut(<span class="string">&quot;slow&quot;</span>);</span><br><span class="line">  $(<span class="string">&quot;#div3&quot;</span>).fadeOut(<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。</span></span><br><span class="line"><span class="comment">//如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#div1&quot;</span>).fadeToggle();</span><br><span class="line">  $(<span class="string">&quot;#div2&quot;</span>).fadeToggle(<span class="string">&quot;slow&quot;</span>);</span><br><span class="line">  $(<span class="string">&quot;#div3&quot;</span>).fadeToggle(<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#div1&quot;</span>).fadeTo(<span class="string">&quot;slow&quot;</span>,<span class="number">0.15</span>);</span><br><span class="line">  $(<span class="string">&quot;#div2&quot;</span>).fadeTo(<span class="string">&quot;slow&quot;</span>,<span class="number">0.4</span>);</span><br><span class="line">  $(<span class="string">&quot;#div3&quot;</span>).fadeTo(<span class="string">&quot;slow&quot;</span>,<span class="number">0.7</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="滑动效果"><a href="#滑动效果" class="headerlink" title="滑动效果"></a>滑动效果</h2><p>通过 jQuery，您可以在元素上创建滑动效果。jQuery 拥有以下滑动方法：</p>
<ul>
<li>slideDown()</li>
<li>slideUp()</li>
<li>slideToggle()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery slideDown() 方法用于向下滑动元素。</span></span><br><span class="line"><span class="comment">//jQuery slideUp() 方法用于向上滑动元素。</span></span><br><span class="line"><span class="comment">//jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。</span></span><br><span class="line"><span class="comment">//如果元素向下滑动，则 slideToggle() 可向上滑动它们。如果元素向上滑动，则 slideToggle() 可向下滑动它们。</span></span><br></pre></td></tr></table></figure>

<h2 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h2><p>jQuery animate() 方法用于创建自定义动画。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$(selector).animate(&#123;params&#125;,speed,callback);</span><br><span class="line"><span class="comment">/*必需的 params 参数定义形成动画的 CSS 属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可选的 speed 参数规定效果的时长。它可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可选的 callback 参数是动画完成后所执行的函数名称。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面的例子演示 animate() 方法的简单应用。它把 &lt;div&gt; 元素往右边移动了 250 像素：*/</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;div&quot;</span>).animate(&#123;<span class="attr">left</span>:<span class="string">&#x27;250px&#x27;</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同样生成动画的过程中可以同时使用多个属性</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;div&quot;</span>).animate(&#123;</span><br><span class="line">    left:<span class="string">&#x27;250px&#x27;</span>,</span><br><span class="line">    opacity:<span class="string">&#x27;0.5&#x27;</span>,</span><br><span class="line">    height:<span class="string">&#x27;150px&#x27;</span>,</span><br><span class="line">    width:<span class="string">&#x27;150px&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=：</span></span><br><span class="line"><span class="comment">//默认地，jQuery 提供针对动画的队列功能。</span></span><br><span class="line"><span class="comment">//这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的&quot;内部&quot;队列。然后逐一运行这些 animate 调用。</span></span><br><span class="line">$(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div=$(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  div.animate(&#123;<span class="attr">left</span>:<span class="string">&#x27;100px&#x27;</span>&#125;,<span class="string">&quot;slow&quot;</span>);</span><br><span class="line">  div.animate(&#123;<span class="attr">fontSize</span>:<span class="string">&#x27;3em&#x27;</span>&#125;,<span class="string">&quot;slow&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>jQuery stop() 方法用于在动画或效果完成前对它们进行停止。stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画</p>
<p>$(<em>selector</em>).stop(<em>stopAll,goToEnd</em>)。</p>
<p>可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。因此，默认地，stop() 会清除在被选元素上指定的当前动画。</p>
<p>Callback 函数在当前动画 100% 完成之后执行。</p>
<h2 id="jQuery链"><a href="#jQuery链" class="headerlink" title="jQuery链"></a>jQuery链</h2><p>通过 jQuery，可以把动作/方法链接在一起。Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）</p>
<p>直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。</p>
<p>不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。<strong>提示：</strong> 这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，您只需简单地把该动作追加到之前的动作上。下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，再然后向下滑动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#p1&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>).slideUp(<span class="number">2000</span>).slideDown(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//如果需要，我们也可以添加多个方法调用。</span></span><br><span class="line"><span class="comment">//提示：当进行链接时，代码行会变得很长。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。如下书写也可以很好地运行：</span></span><br><span class="line">$(<span class="string">&quot;#p1&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>)</span><br><span class="line">  .slideUp(<span class="number">2000</span>)</span><br><span class="line">  .slideDown(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//jQuery 会抛掉多余的空格，并当成一行长代码来执行上面的代码行。</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是链式调用"><a href="#什么是链式调用" class="headerlink" title="什么是链式调用"></a>什么是链式调用</h2><p>链式调用完方法后，return this返回当前调用方法的对象。普通的定义类方法，在多次调用一个对象的不同方法时有一个弊端，就是会多次重复使用一个对象变量，进行了多次查找，可以在原本的实现类中增添一行return this 从而能简单地实现链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个bird类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.run=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(name+<span class="string">&quot; &quot;</span>+<span class="string">&quot;start run;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">// return this返回当前调用方法的对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stopRun=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(name+<span class="string">&quot; &quot;</span>+<span class="string">&quot;start run;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.sing=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(name+<span class="string">&quot; &quot;</span>+<span class="string">&quot;start sing;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stopSing=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(name+<span class="string">&quot; &quot;</span>+<span class="string">&quot;start stopSing;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bird=<span class="keyword">new</span> Bird(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">    bird.run().sing().stopSing().stopRun();</span><br><span class="line"><span class="comment">//结果为;测试 start run;测试 start sing;测试 start stopSing;测试 start run;</span></span><br></pre></td></tr></table></figure>

<h2 id="jq的链式调用"><a href="#jq的链式调用" class="headerlink" title="jq的链式调用"></a>jq的链式调用</h2><p>jq的链式调用其实就是比如我们在选择dom的时候，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;input[type=&quot;button&quot;]&#x27;</span>)</span><br><span class="line">    .eq(<span class="number">0</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;点击我!&#x27;</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">1</span>)</span><br><span class="line">.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;input[type=&quot;button&quot;]:eq(0)&#x27;</span>).trigger(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">2</span>)</span><br><span class="line">.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.aa&#x27;</span>).hide(<span class="string">&#x27;slow&#x27;</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;.aa&#x27;</span>).show(<span class="string">&#x27;slow&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>比如如上代码，先选择type类型为button的所有DOM，然后再选择第一个…</p>
<p>我们自然想到每次其实就是返回选择后的结果，在js里面有什么东西可以指代这个吗？<br>如果你想到this就对了。</p>
<p>q的方法都是挂在原型的，那么如果我们每次在内部方法返回this，也就是返回实例对象，那么我们就可以继续调用原型上的方法了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。</p>
<p>但是也会出现一个问题：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。</p>
<h2 id="模仿jQuery的链式调用"><a href="#模仿jQuery的链式调用" class="headerlink" title="模仿jQuery的链式调用"></a>模仿jQuery的链式调用</h2><p>1、定义一个含参数的空对象；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//下划线：表示私有变量的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_$</span>(<span class="params">els</span>) </span>&#123; &#125;;<span class="comment">//有参数的空函数对象</span></span><br><span class="line">&#125;)()<span class="comment">//程序启动的时候 里面的代码直接执行了</span></span><br></pre></td></tr></table></figure>

<p>2、准备方法：在_$上定义一个onrReady方法；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//第一步，下划线：表示私有变量的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_$</span>(<span class="params">els</span>) </span>&#123; &#125;;<span class="comment">//有参数的空对象</span></span><br><span class="line">    <span class="comment">//第二步，准备方法  在_$上定义一个onrReady方法</span></span><br><span class="line">    _$.onrReady=<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//按要求把对象（_$）注册到window对象上</span></span><br><span class="line">        <span class="comment">//对外开放的接口</span></span><br><span class="line">        <span class="built_in">window</span>.$=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _$(<span class="built_in">arguments</span>);</span><br><span class="line">            <span class="comment">//传递相应的方法调用参数  返回一可以使用function类原型上的方法的对象（$(&quot;&quot;)=_$(参数)）</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>3、为了类能扩展函数，我们定义一个它的静态函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.method=<span class="function"><span class="keyword">function</span> (<span class="params">name,fn</span>) </span>&#123;<span class="comment">//（函数名称，函数本身）</span></span><br><span class="line">     <span class="built_in">this</span>.prototype[name]=fn;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>;<span class="comment">//链式调用关键</span></span><br><span class="line">&#125;;<span class="comment">//这个函数的意思：为function对象增加函数，会用链式调用，链式调用有两个参数name,和fn</span></span><br></pre></td></tr></table></figure>

<p>4、扩展类的相应方法，链式的对象增加jquery库提供的操作函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//下划线：表示私有变量的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_$</span>(<span class="params">els</span>) </span>&#123; &#125;;<span class="comment">//有参数的空对象</span></span><br><span class="line">    <span class="comment">//第二步，准备方法  在_$上定义一个onrReady方法</span></span><br><span class="line">    _$.onrReady=<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//按要求把对象（_$）注册到window对象上   </span></span><br><span class="line">        <span class="comment">//对外开放的接口</span></span><br><span class="line">        <span class="built_in">window</span>.$=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _$(<span class="built_in">arguments</span>);<span class="comment">//传递相应的方法调用参数  返回一可以使用function类原型上的方法的对象（$(&quot;&quot;)=_$(参数)）</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//第四步</span></span><br><span class="line">    <span class="comment">//扩展类的相应方法  链式的对象增加jquery库提供的操作函数  </span></span><br><span class="line">_$.method(<span class="string">&quot;AddEvent&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">type,fn</span>) </span>&#123;<span class="comment">//_$本身是一个function要继承原型链上的东西。</span></span><br><span class="line">    fn();</span><br><span class="line">&#125;).method(<span class="string">&quot;getEvent&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">fn,e</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>5、使用，需要调用_$.onReady方法才可以返回对象使用从function类继承而来的原型上的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// （1）下划线：表示私有变量的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_$</span>(<span class="params">els</span>) </span>&#123; &#125;;<span class="comment">//有参数的空对象</span></span><br><span class="line">    <span class="comment">//（2）准备方法  在_$上定义一个onrReady方法</span></span><br><span class="line">      <span class="comment">// window.$=_$;</span></span><br><span class="line">    _$.onrReady=<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//按要求把对象（_$）注册到window对象上   在任何地方都可以使用</span></span><br><span class="line">        <span class="comment">//对外开放的接口</span></span><br><span class="line">        <span class="built_in">window</span>.$=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//window 上先注册一个全局变量 与外界产生关系</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _$(<span class="built_in">arguments</span>);<span class="comment">//传递相应的方法调用参数  返回一可以使用function类原型上的方法的对象（$(&quot;&quot;)=_$(参数)）</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//（4）扩展类的相应方法  链式的对象增加jquery库提供的操作函数</span></span><br><span class="line">_$.method(<span class="string">&quot;AddEvent&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">type,fn</span>) </span>&#123;<span class="comment">//_$本身是一个function要继承原型链上的东西。</span></span><br><span class="line">    fn();</span><br><span class="line">&#125;).method(<span class="string">&quot;getEvent&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">fn,e</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">//第五步，开始使用 ，需要调用_$.onready方法才可以返回对象使用从function类继承而来的原型上的方法</span></span><br><span class="line">     _$.onrReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//$是绑定在Windows上的</span></span><br><span class="line">        $(<span class="string">&quot;&quot;</span>).AddEvent(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/23/%E5%89%8D%E7%AB%AF/jQuery%E6%95%99%E7%A8%8B/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8.png" alt="链式调用"></p>
<p>简单的加减法链式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">Number</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isNaN</span>(<span class="built_in">Number</span>)?<span class="built_in">Number</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">        test(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> + num</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">jian</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">           test(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> - num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.Add = Add</span><br><span class="line">    <span class="built_in">Function</span>.prototype.jian = jian</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Li Yudong"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">Li Yudong</p>
  <div class="site-description" itemprop="description">请乐观，请珍惜</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tiarmor1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tiarmor1" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1157019137@qq.com" title="E-Mail → mailto:1157019137@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Yudong</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib1/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib1/anime.min.js"></script>
  <script src="/lib1/velocity/velocity.min.js"></script>
  <script src="/lib1/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/fireworks.js"></script>
  
</body>
</html>

